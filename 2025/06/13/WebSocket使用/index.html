<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>WebSocket使用 | bush's Blog</title><meta name="author" content="bush Wu"><meta name="copyright" content="bush Wu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="WebSocket WebSocket 是一种基于 TCP 协议的全双工通信协议，它允许客户端和服务器之间建立持久的、双向的通信连接。相比传统的 HTTP 请求 - 响应模式，WebSocket 提供了实时、低延迟的数据传输能力。通过 WebSocket，客户端和服务器可以随时发送数据，而不需要每次都重新建立连接。实现实时更新和即时通信的功能。 WebSocket 协议经过了多个浏览器和服务器的支">
<meta property="og:type" content="article">
<meta property="og:title" content="WebSocket使用">
<meta property="og:url" content="http://bush-cn.github.io/2025/06/13/WebSocket%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="bush&#39;s Blog">
<meta property="og:description" content="WebSocket WebSocket 是一种基于 TCP 协议的全双工通信协议，它允许客户端和服务器之间建立持久的、双向的通信连接。相比传统的 HTTP 请求 - 响应模式，WebSocket 提供了实时、低延迟的数据传输能力。通过 WebSocket，客户端和服务器可以随时发送数据，而不需要每次都重新建立连接。实现实时更新和即时通信的功能。 WebSocket 协议经过了多个浏览器和服务器的支">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://bush-cn.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-06-13T04:23:13.000Z">
<meta property="article:modified_time" content="2025-07-11T07:13:49.185Z">
<meta property="article:author" content="bush Wu">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="后端">
<meta property="article:tag" content="WebSocket">
<meta property="article:tag" content="js">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://bush-cn.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://bush-cn.github.io/2025/06/13/WebSocket%E4%BD%BF%E7%94%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: bush Wu","link":"链接: ","source":"来源: bush's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'medium_zoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'WebSocket使用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(to left, rgb(76, 161, 175), rgb(196, 224, 229));"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/favicon.png" alt="Logo"><span class="site-name">bush's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">WebSocket使用</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">WebSocket使用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-13T04:23:13.000Z" title="发表于 2025-06-13 12:23:13">2025-06-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-11T07:13:49.185Z" title="更新于 2025-07-11 15:13:49">2025-07-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91/">Java企业级开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="WebSocket"><strong>WebSocket</strong></h2>
<p>WebSocket 是一种<strong>基于 TCP 协议</strong>的<strong>全双工通信协议</strong>，它允许客户端和服务器之间建立持久的、双向的通信连接。相比传统的 HTTP 请求 - 响应模式，WebSocket 提供了实时、低延迟的数据传输能力。通过 WebSocket，客户端和服务器可以<strong>随时发送数据</strong>，而不需要每次都重新建立连接。实现<strong>实时更新和即时通信</strong>的功能。</p>
<p>WebSocket 协议经过了多个浏览器和服务器的支持，成为了现代 Web 应用中常用的通信协议之一。它广泛应用于聊天应用、实时数据更新、多人游戏等场景，为 Web 应用提供了更好的用户体验和更高效的数据传输方式。</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>持久连接</strong></td>
<td>建立一次连接后，客户端和服务器之间保持连接状态</td>
</tr>
<tr>
<td><strong>全双工通信</strong></td>
<td>客户端和服务器都可以主动发送消息</td>
</tr>
<tr>
<td><strong>低延迟、实时性强</strong></td>
<td>适合聊天、游戏、股票、实时推送等应用</td>
</tr>
<tr>
<td><strong>节省资源</strong></td>
<td>与传统 HTTP 请求相比，减少了请求头等开销</td>
</tr>
<tr>
<td><strong>基于 TCP 协议</strong></td>
<td>和 HTTP 一样基于 TCP，但是一个独立协议</td>
</tr>
</tbody>
</table>
<h3 id="Spring-Boot中使用WebSocket">Spring Boot中使用WebSocket</h3>
<p>以我们组的大作业为例，在学生答题端和教师监考端之间建立了WebSocket连接，实现答题进度及考试状态实时通信。具体步骤如下：</p>
<h4 id="1-引入依赖">1. 引入依赖</h4>
<p>在<code>pom.xml</code>中引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-创建配置类">2. 创建配置类</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.buaa.javahuikao.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.simp.config.MessageBrokerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.StompEndpointRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry config)</span> &#123;</span><br><span class="line">        config.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>); <span class="comment">// 客户端订阅地址前缀</span></span><br><span class="line">        config.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>); <span class="comment">// 服务端接收消息地址前缀</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/ws&quot;</span>) <span class="comment">// WebSocket连接端点</span></span><br><span class="line">                .setAllowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>enableSimpleBroker(&quot;/topic&quot;)</code>：启用了一个 <strong>简单的内存消息代理（message broker）</strong>，当客户端订阅 <code>/topic/*</code> 开头的地址时，消息将会被推送到这些订阅者。</p>
</li>
<li>
<p><code>setApplicationDestinationPrefixes(&quot;/app&quot;)</code>：客户端向服务端 <strong>发送消息的路径前缀</strong>。只有以 <code>/app</code> 开头的消息，才会被 <code>@MessageMapping</code> 注解的方法接收处理。</p>
</li>
<li>
<p><code>addEndpoint(&quot;/ws&quot;)</code>：注册一个 <strong>WebSocket 连接端点</strong>，客户端将通过这个地址发起连接（例如：<code>ws://localhost:8080/ws</code>）。</p>
</li>
<li>
<p><code>setAllowedOriginPatterns(&quot;*&quot;)</code>：允许所有来源跨域连接（生产环境建议指定具体域名）。</p>
<p><code>withSockJS()</code>：启用 <strong>SockJS 兼容模式</strong>，保证在 WebSocket 不可用时（如浏览器不支持）可以回退到 AJAX 长轮询。</p>
</li>
</ul>
<h4 id="3-在REST接口类中使用WebSocket">3. 在REST接口类中使用WebSocket</h4>
<p>首先注入 <code>SimpMessagingTemplate</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SimpMessagingTemplate messagingTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InvigilationController</span><span class="params">(SimpMessagingTemplate messagingTemplate)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.messagingTemplate = messagingTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>SimpMessagingTemplate</code> 是 Spring 提供的一个工具类，用于在服务端向客户端 <strong>发送 STOMP 消息</strong>。</li>
<li>可以理解为是一个“消息发送器”，配合前面的 <code>WebSocketConfig</code> 使用。</li>
</ul>
<p>接着，使用<code>messagingTemplate.convertAndSend(destination, payload)</code>向服务端推送消息。此处，</p>
<h4 id="4-前端订阅消息并更新页面">4. 前端订阅消息并更新页面</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立WebSocket连接</span></span><br><span class="line"><span class="keyword">const</span> socketProgress = <span class="keyword">new</span> <span class="title class_">SockJS</span>(<span class="string">&quot;http://localhost:8081/ws&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> stompClientProgress = <span class="title class_">Stomp</span>.<span class="title function_">over</span>(socketProgress);</span><br><span class="line">stompClientProgress.<span class="title function_">connect</span>(&#123;&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebSocket Progress 连接成功！&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> examId = exam_id</span><br><span class="line">    <span class="keyword">const</span> subscription = stompClientProgress.<span class="title function_">subscribe</span>(</span><br><span class="line">        <span class="string">`/topic/exam/<span class="subst">$&#123;examId&#125;</span>/progress`</span>,</span><br><span class="line">        <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(message.<span class="property">body</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;收到进度更新:&quot;</span>, data);</span><br><span class="line">            <span class="title function_">updateStudentProgress</span>(data.<span class="property">studentId</span>, data.<span class="property">progress</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立WebSocket连接</span></span><br><span class="line"><span class="keyword">const</span> socketStatus = <span class="keyword">new</span> <span class="title class_">SockJS</span>(<span class="string">&quot;http://localhost:8081/ws&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> stompClientStatus = <span class="title class_">Stomp</span>.<span class="title function_">over</span>(socketStatus);</span><br><span class="line">stompClientStatus.<span class="title function_">connect</span>(&#123;&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebSocket Status 连接成功！&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> examId = exam_id</span><br><span class="line">    <span class="keyword">const</span> subscription = stompClientStatus.<span class="title function_">subscribe</span>(</span><br><span class="line">        <span class="string">`/topic/exam/<span class="subst">$&#123;examId&#125;</span>/status`</span>,</span><br><span class="line">        <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(message.<span class="property">body</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;收到状态更新:&quot;</span>, data);</span><br><span class="line">            <span class="title function_">updateStudentStatus</span>(data.<span class="property">studentId</span>, data.<span class="property">status</span>, data.<span class="property">description</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://bush-cn.github.io">bush Wu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://bush-cn.github.io/2025/06/13/WebSocket%E4%BD%BF%E7%94%A8/">http://bush-cn.github.io/2025/06/13/WebSocket%E4%BD%BF%E7%94%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://bush-cn.github.io" target="_blank">bush's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF/">后端</a><a class="post-meta__tags" href="/tags/WebSocket/">WebSocket</a><a class="post-meta__tags" href="/tags/js/">js</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/13/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="跨域问题及解决方案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">跨域问题及解决方案</div></div><div class="info-2"><div class="info-item-1">跨域请求问题 跨域请求问题是**浏览器的同源策略（Same-Origin Policy, SOP）**所导致的一种前端限制。 同源 所谓“同源”，是指两个页面的协议（protocol）、域名（host）和端口（port）必须完全相同。 例如：    URL 是否同源 说明     http://example.com/page1 是 与自己比   http://example.com:8080/page1 否 端口不同   https://example.com/page1 否 协议不同   http://api.example.com/page1 否 子域不同    跨域 当浏览器的网页尝试向不同源的服务器发送请求时，就发生了跨域请求，如：  当前网页在 http://localhost:8080 JS 发起 AJAX 请求到 http://api.example.com，此时就是跨域请求  常见跨域行为包括：  Ajax 请求接口 加载第三方脚本、样式、图片（部分不受限制） 使用 fetch 获取不同域资源 WebSocket（需特殊处理）  Spring Boot...</div></div></div></a><a class="pagination-related" href="/2025/06/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Java 多线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java 多线程</div></div><div class="info-2"><div class="info-item-1">Java多线程 Java SE中的多线程 Java SE中最基础的多线程方式（适用于任何Java程序）包括两种：   方法1：继承 Thread 类 123456public class MyThread extends Thread &#123;    @Override    public void run() &#123;        System.out.println(&quot;线程名：&quot; + Thread.currentThread().getName());    &#125;&#125; 使用： 123456public class Main &#123;    public static void main(String[] args) &#123;        MyThread t1 = new MyThread();        t1.start();  // 启动线程，run() 方法会被自动调用    &#125;&#125;   方法2：实现 Runnable 接口 123456public class MyRunnable...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/11/Java%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91%E7%AE%80%E7%AD%94%E9%A2%981%EF%BC%88Spring%EF%BC%89/" title="Java企业级开发简答题1（Spring）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-11</div><div class="info-item-2">Java企业级开发简答题1（Spring）</div></div><div class="info-2"><div class="info-item-1">作业 1：简答题  22371495 吴自强  [TOC] 1. Spring 的核心容器有哪些模块组成？列举 Spring 框架的优点 Spring核心容器的四个模块为：  Spring-core模块：提供了框架的基本功能，包括 IoC（控制反转）和依赖注入（DI）机制。 Spring-beans模块：提供对 Bean 的配置、创建和管理，是 IoC 的核心部分。 Spring-context模块：基于 Core 和 Beans 模块构建，提供更高级的应用框架（如国际化、事件传播、资源访问等），常用类如 ApplicationContext。 Spring-expression模块：提供强大的表达式语言，用于在运行时查询和操作对象图（如 #&#123;user.name&#125;）。  Spring 框架的优点：  轻量级、非侵入性 Spring 是轻量级的，依赖注入不依赖于具体实现类，业务代码不需要继承特定类，降低耦合。 IoC（控制反转）和 DI（依赖注入） 通过 IoC...</div></div></div></a><a class="pagination-related" href="/2025/07/11/Java%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91%E7%AE%80%E7%AD%94%E9%A2%982%EF%BC%88MyBatis%EF%BC%89/" title="Java企业级开发简答题2（MyBatis）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-11</div><div class="info-item-2">Java企业级开发简答题2（MyBatis）</div></div><div class="info-2"><div class="info-item-1">作业 2：简答题  22371495 吴自强  [TOC] 1. 简述 MyBatis 的工作原理 MyBatis 的工作原理可以概括如下： 一、配置阶段  加载配置文件 MyBatis 启动时会加载 mybatis-config.xml 配置文件，其中包括数据库连接信息、Mapper 映射文件路径等。 构建 SqlSessionFactory 通过 SqlSessionFactoryBuilder 读取配置文件并构建 SqlSessionFactory。这个工厂负责创建 SqlSession。  二、运行阶段  创建 SqlSession 应用程序通过 SqlSessionFactory 创建一个 SqlSession 对象，用于执行 SQL。 执行 SQL 映射  使用接口绑定（Mapper 接口）或者 XML 映射文件中的 SQL 语句。 MyBatis 会根据 Mapper.xml 中的 SQL 映射，将参数传入、生成最终 SQL，并执行。   执行 JDBC 操作 MyBatis 底层仍然使用 JDBC 执行 SQL，通过 JDBC 与数据库交互。 结果映射 SQL...</div></div></div></a><a class="pagination-related" href="/2025/06/13/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Redis学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-13</div><div class="info-item-2">Redis学习笔记</div></div><div class="info-2"><div class="info-item-1">Redis学习笔记 Redis Redis简介 Redis（Remote Dictionary Server）是一种开源的、基于内存的键值对（key-value）数据库，可以用作数据库、缓存和消息中间件。它以极高的性能、丰富的数据结构和多种实用功能而著称，被广泛用于高并发、低延迟的应用场景中，如电商秒杀、社交应用、排行榜、会话缓存等。 Redis特点    特点 说明     高性能 所有数据操作都在内存中完成，读写速度极快（百万级QPS）。   丰富数据结构 支持多种数据类型：字符串（string）、列表（list）、集合（set）、有序集合（zset）、哈希表（hash）、位图、HyperLogLog、地理位置等。   持久化 虽然是内存数据库，但支持将数据持久化到磁盘，防止宕机数据丢失（RDB快照和AOF日志）。   支持事务 可以一次执行多个命令，具备基本的事务特性（MULTI/EXEC）。   支持发布/订阅 可实现消息系统的 pub/sub 通信模型。   支持主从复制与集群 具备高可用（哨兵）与分布式（Redis Cluster）能力。   原子操作 所有单条...</div></div></div></a><a class="pagination-related" href="/2025/06/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Java 多线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-13</div><div class="info-item-2">Java 多线程</div></div><div class="info-2"><div class="info-item-1">Java多线程 Java SE中的多线程 Java SE中最基础的多线程方式（适用于任何Java程序）包括两种：   方法1：继承 Thread 类 123456public class MyThread extends Thread &#123;    @Override    public void run() &#123;        System.out.println(&quot;线程名：&quot; + Thread.currentThread().getName());    &#125;&#125; 使用： 123456public class Main &#123;    public static void main(String[] args) &#123;        MyThread t1 = new MyThread();        t1.start();  // 启动线程，run() 方法会被自动调用    &#125;&#125;   方法2：实现 Runnable 接口 123456public class MyRunnable...</div></div></div></a><a class="pagination-related" href="/2025/06/13/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="跨域问题及解决方案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-13</div><div class="info-item-2">跨域问题及解决方案</div></div><div class="info-2"><div class="info-item-1">跨域请求问题 跨域请求问题是**浏览器的同源策略（Same-Origin Policy, SOP）**所导致的一种前端限制。 同源 所谓“同源”，是指两个页面的协议（protocol）、域名（host）和端口（port）必须完全相同。 例如：    URL 是否同源 说明     http://example.com/page1 是 与自己比   http://example.com:8080/page1 否 端口不同   https://example.com/page1 否 协议不同   http://api.example.com/page1 否 子域不同    跨域 当浏览器的网页尝试向不同源的服务器发送请求时，就发生了跨域请求，如：  当前网页在 http://localhost:8080 JS 发起 AJAX 请求到 http://api.example.com，此时就是跨域请求  常见跨域行为包括：  Ajax 请求接口 加载第三方脚本、样式、图片（部分不受限制） 使用 fetch 获取不同域资源 WebSocket（需特殊处理）  Spring Boot...</div></div></div></a><a class="pagination-related" href="/2025/07/04/Java%20SE%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Java SE复习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-04</div><div class="info-item-2">Java SE复习笔记</div></div><div class="info-2"><div class="info-item-1"> 第一次找实习wwwwwwww好紧张希望能顺利。  Java SE复习笔记 JVM Java虚拟机（Java Virtual Machine，简称JVM）是运行所有Java程序的抽象计算机，是Java语言的运行环境。 Java语言的一个非常重要的特点就是与平台的无关性（一次编译、处处运行）。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。 JVM中提供的JIT（即时编译方式）将字节码直接转化成高性能的本地机器码，即JIT使得Java程序既能跨平台又能高速运行。 Java集合  ArrayList Java ArrayList 常用方法列表如下：    方法 描述     add() 将元素插入到指定位置的...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">bush Wu</div><div class="author-info-description">北京航空航天大学21系软件工程专业22级本科生。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/bush-cn"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/bush-cn" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:bush_wu@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#WebSocket"><span class="toc-text">WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot%E4%B8%AD%E4%BD%BF%E7%94%A8WebSocket"><span class="toc-text">Spring Boot中使用WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-text">1. 引入依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">2. 创建配置类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%A8REST%E6%8E%A5%E5%8F%A3%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8WebSocket"><span class="toc-text">3. 在REST接口类中使用WebSocket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%89%8D%E7%AB%AF%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF%E5%B9%B6%E6%9B%B4%E6%96%B0%E9%A1%B5%E9%9D%A2"><span class="toc-text">4. 前端订阅消息并更新页面</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/11/Java%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91%E7%AE%80%E7%AD%94%E9%A2%982%EF%BC%88MyBatis%EF%BC%89/" title="Java企业级开发简答题2（MyBatis）">Java企业级开发简答题2（MyBatis）</a><time datetime="2025-07-11T07:11:42.000Z" title="发表于 2025-07-11 15:11:42">2025-07-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/11/Java%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91%E7%AE%80%E7%AD%94%E9%A2%981%EF%BC%88Spring%EF%BC%89/" title="Java企业级开发简答题1（Spring）">Java企业级开发简答题1（Spring）</a><time datetime="2025-07-11T07:11:11.000Z" title="发表于 2025-07-11 15:11:11">2025-07-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E5%9B%9E%E9%A1%BE/" title="算法导论笔记整理回顾">算法导论笔记整理回顾</a><time datetime="2025-07-10T14:25:51.000Z" title="发表于 2025-07-10 22:25:51">2025-07-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="数据库复习笔记">数据库复习笔记</a><time datetime="2025-07-10T09:07:26.000Z" title="发表于 2025-07-10 17:07:26">2025-07-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/04/Java%20SE%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Java SE复习笔记">Java SE复习笔记</a><time datetime="2025-07-04T08:54:32.000Z" title="发表于 2025-07-04 16:54:32">2025-07-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By bush Wu</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>