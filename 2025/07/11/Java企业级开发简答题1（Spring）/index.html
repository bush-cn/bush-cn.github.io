<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java企业级开发简答题1（Spring） | bush's Blog</title><meta name="author" content="bush Wu"><meta name="copyright" content="bush Wu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="作业 1：简答题  22371495 吴自强  [TOC] 1. Spring 的核心容器有哪些模块组成？列举 Spring 框架的优点 Spring核心容器的四个模块为：  Spring-core模块：提供了框架的基本功能，包括 IoC（控制反转）和依赖注入（DI）机制。 Spring-beans模块：提供对 Bean 的配置、创建和管理，是 IoC 的核心部分。 Spring-context模">
<meta property="og:type" content="article">
<meta property="og:title" content="Java企业级开发简答题1（Spring）">
<meta property="og:url" content="http://bush-cn.github.io/2025/07/11/Java%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91%E7%AE%80%E7%AD%94%E9%A2%981%EF%BC%88Spring%EF%BC%89/index.html">
<meta property="og:site_name" content="bush&#39;s Blog">
<meta property="og:description" content="作业 1：简答题  22371495 吴自强  [TOC] 1. Spring 的核心容器有哪些模块组成？列举 Spring 框架的优点 Spring核心容器的四个模块为：  Spring-core模块：提供了框架的基本功能，包括 IoC（控制反转）和依赖注入（DI）机制。 Spring-beans模块：提供对 Bean 的配置、创建和管理，是 IoC 的核心部分。 Spring-context模">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://bush-cn.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-07-11T07:11:11.000Z">
<meta property="article:modified_time" content="2025-07-11T07:14:29.714Z">
<meta property="article:author" content="bush Wu">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="后端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://bush-cn.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://bush-cn.github.io/2025/07/11/Java%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91%E7%AE%80%E7%AD%94%E9%A2%981%EF%BC%88Spring%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: bush Wu","link":"链接: ","source":"来源: bush's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'medium_zoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java企业级开发简答题1（Spring）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(to left, rgb(76, 161, 175), rgb(196, 224, 229));"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/favicon.png" alt="Logo"><span class="site-name">bush's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Java企业级开发简答题1（Spring）</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java企业级开发简答题1（Spring）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-11T07:11:11.000Z" title="发表于 2025-07-11 15:11:11">2025-07-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-11T07:14:29.714Z" title="更新于 2025-07-11 15:14:29">2025-07-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91/">Java企业级开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="作业-1：简答题">作业 1：简答题</h1>
<blockquote>
<p>22371495 吴自强</p>
</blockquote>
<p>[TOC]</p>
<h3 id="1-Spring-的核心容器有哪些模块组成？列举-Spring-框架的优点">1. Spring 的核心容器有哪些模块组成？列举 Spring 框架的优点</h3>
<p><u>Spring核心容器的四个模块为</u>：</p>
<ul>
<li>Spring-core模块：提供了框架的基本功能，包括 IoC（控制反转）和依赖注入（DI）机制。</li>
<li>Spring-beans模块：提供对 Bean 的配置、创建和管理，是 IoC 的核心部分。</li>
<li>Spring-context模块：基于 Core 和 Beans 模块构建，提供更高级的应用框架（如国际化、事件传播、资源访问等），常用类如 <code>ApplicationContext</code>。</li>
<li>Spring-expression模块：提供强大的表达式语言，用于在运行时查询和操作对象图（如 <code>#&#123;user.name&#125;</code>）。</li>
</ul>
<p><u>Spring 框架的优点</u>：</p>
<ol>
<li><strong>轻量级、非侵入性</strong><br>
Spring 是轻量级的，依赖注入不依赖于具体实现类，业务代码不需要继承特定类，降低耦合。</li>
<li><strong>IoC（控制反转）和 DI（依赖注入）</strong><br>
通过 IoC 容器管理对象生命周期和依赖关系，使得组件更容易解耦和测试。</li>
<li><strong>AOP（面向切面编程）支持</strong><br>
方便实现事务管理、日志记录、安全控制等横切关注点。</li>
<li><strong>统一事务管理</strong><br>
提供对声明式和编程式事务的支持，能整合 JDBC、Hibernate、JPA、MyBatis 等事务处理。</li>
<li><strong>良好的集成能力</strong><br>
能很好地整合第三方框架（如 Hibernate、MyBatis、Quartz、Redis）和 Java EE 技术（如 JPA、JMS、Servlet）。</li>
<li><strong>模块化设计</strong><br>
各模块相互独立，可按需引入，避免臃肿。</li>
<li><strong>支持多种视图技术</strong><br>
如 JSP、Thymeleaf、FreeMarker 等，适用于不同前端技术栈。</li>
<li><strong>强大的社区和生态</strong><br>
Spring Boot、Spring Cloud 等项目简化了微服务和企业级开发的复杂性。</li>
</ol>
<h3 id="2-在-Spring-框架中，什么是控制反转？什么是依赖注入？使用控制反转与依赖注入有什么优点？">2. 在 Spring 框架中，什么是控制反转？什么是依赖注入？使用控制反转与依赖注入有什么优点？</h3>
<p><u>控制反转</u>指的是<strong>对象的创建和依赖关系的管理不再由程序本身控制，而是交由 Spring 容器统一管理</strong>。<br>
传统方式中，类通常会通过 <code>new</code> 创建依赖对象；使用 IoC 后，这个过程被“反转”到了框架中。控制权由调用者转移到Spring容器，控制权发生了反转，这就是Spring的控制反转。</p>
<p><u>依赖注入</u>是控制反转的一种实现方式，指的是<strong>由 Spring 容器将对象所依赖的组件（依赖项）“注入”到对象中</strong>，而不是由对象自己创建依赖。</p>
<p><u>使用控制反转与依赖注入的优点</u>：</p>
<table>
<thead>
<tr>
<th>优点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>解耦</strong></td>
<td>对象之间通过接口和容器联系，降低模块间依赖</td>
</tr>
<tr>
<td><strong>提高可测试性</strong></td>
<td>易于使用 Mock 替代真实依赖进行单元测试</td>
</tr>
<tr>
<td><strong>可配置性强</strong></td>
<td>对象关系可以通过配置文件或注解灵活管理</td>
</tr>
<tr>
<td><strong>复用性高</strong></td>
<td>可重用组件被容器统一管理，避免重复创建</td>
</tr>
<tr>
<td><strong>增强扩展性</strong></td>
<td>容易实现 AOP（如事务、日志）等功能</td>
</tr>
<tr>
<td><strong>降低维护成本</strong></td>
<td>对象关系集中管理，修改影响范围小</td>
</tr>
</tbody>
</table>
<h3 id="3-在-Spring-框架中，有哪些不同类型的依赖注入实现方式？">3. 在 Spring 框架中，有哪些不同类型的依赖注入实现方式？</h3>
<p>Spring框架的依赖注入通常有两种实现方式：</p>
<ul>
<li>一种是<strong>构造方法</strong>注入</li>
<li>另一种是<strong>属性setter方法</strong>注入。</li>
</ul>
<p>对于两种方法注入，Spring框架都是基于Java的反射机制实现的。</p>
<h3 id="4-在Spring-框架中，BeanFactory与AppliacationContext有什么区别？ApplicationContext的实现类有哪些">4. 在Spring 框架中，BeanFactory与AppliacationContext有什么区别？ApplicationContext的实现类有哪些?</h3>
<p>ApplicaitonContext是BeanFactory的子接口。</p>
<ul>
<li>BeanFactory：IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用，这种方式加载配置文件时候不会创建对象，在获取对象（使用时）才去创建对象 。（晚加载）</li>
<li>ApplicationContext：BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人员进行使用,这种方式在加载配置文件时候就会把配置文件中的对象进行创建。(早加载)</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>BeanFactory</code></th>
<th><code>ApplicationContext</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>层次关系</strong></td>
<td>最基本的容器接口</td>
<td>是 <code>BeanFactory</code> 的子接口，扩展功能更强</td>
</tr>
<tr>
<td><strong>加载方式</strong></td>
<td><strong>懒加载</strong>（延迟加载 Bean，使用时才创建）</td>
<td><strong>预加载</strong>（启动时创建所有单例 Bean）</td>
</tr>
<tr>
<td><strong>国际化支持</strong></td>
<td>不支持</td>
<td>支持（如 <code>getMessage()</code>）</td>
</tr>
<tr>
<td><strong>事件发布机制</strong></td>
<td>不支持</td>
<td>支持（如 <code>ApplicationEventPublisher</code>）</td>
</tr>
<tr>
<td><strong>AOP 支持</strong></td>
<td>支持（需手动配置）</td>
<td>更好支持，集成更方便</td>
</tr>
<tr>
<td><strong>资源访问</strong></td>
<td>基本无</td>
<td>提供资源加载（如 ClassPath、FileSystem）</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>内存资源紧张、仅管理少量 Bean</td>
<td>常规开发中推荐使用</td>
</tr>
</tbody>
</table>
<p><u>ApplicationContext 的常见实现类</u>：</p>
<table>
<thead>
<tr>
<th>实现类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ClassPathXmlApplicationContext</strong></td>
<td>从类路径下加载 XML 配置文件</td>
</tr>
<tr>
<td><strong>FileSystemXmlApplicationContext</strong></td>
<td>从文件系统中加载 XML 配置文件</td>
</tr>
<tr>
<td><strong>AnnotationConfigApplicationContext</strong></td>
<td>用于基于注解的配置（如 <code>@Configuration</code>）</td>
</tr>
<tr>
<td><strong>WebApplicationContext</strong></td>
<td>专用于 Web 应用（Spring MVC 中使用）</td>
</tr>
<tr>
<td><strong>ConfigurableWebApplicationContext</strong></td>
<td>扩展了 WebApplicationContext，它允许通过配置的方式实例化WebApplicationContext</td>
</tr>
</tbody>
</table>
<h3 id="5-Spring-支持-bean-的作用域有几种？">5. Spring 支持 bean 的作用域有几种？</h3>
<p>Spring 支持的 bean 的作用域如下：</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>singleton</code></td>
<td>默认的作用域，使用singleton定义的Bean在Spring容器中只有一个Bean实例。</td>
</tr>
<tr>
<td><code>prototype</code></td>
<td>Spring容器每次获取prototype定义的Bean，容器都将创建一个新的Bean实例。</td>
</tr>
<tr>
<td><code>request</code></td>
<td>在一次HTTP请求中容器将返回一个Bean实例，不同的HTTP请求返回不同的Bean实例。仅在Web Spring应用程序上下文中使用。</td>
</tr>
<tr>
<td><code>session</code></td>
<td>在一个HTTP Session中，容器将返回同一个Bean实例。仅在WebSpring应用程序上下文中使用。</td>
</tr>
<tr>
<td><code>application</code></td>
<td>为每个ServletContext对象创建一个实例，即同一个应用共享一个Bean实例。仅在Web Spring应用程序上下文中使用。</td>
</tr>
<tr>
<td><code>websocket</code></td>
<td>为每个WebSocket对象创建一个Bean实例。仅在Web Spring应用程序上下文中使用。</td>
</tr>
</tbody>
</table>
<h3 id="6-Spring-有几种配置方式？（基于-xml、基于注解、基于-Java-配置）针对上述配置，请举例说明。">6. Spring 有几种配置方式？（基于 xml、基于注解、基于 Java 配置）针对上述配置，请举例说明。</h3>
<p><u>一、基于 XML 的配置方式</u></p>
<p>特点：</p>
<ul>
<li>配置集中，清晰可见，适合配置大量 Bean。</li>
<li>不需要修改代码即可改变配置（例如数据源等）。</li>
</ul>
<p>示例：</p>
<p><strong>beans.xml</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userRepository&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userRepository&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userRepository&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserRepository&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>使用方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br></pre></td></tr></table></figure>
<p><u>二、基于注解的配置方式（常用于 Spring Boot）</u></p>
<p>特点：</p>
<ul>
<li>使用注解减少 XML 配置，代码更紧凑。</li>
<li>与 Java 类紧耦合，适合小项目或组件内部。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepository</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>开启注解扫描</strong>（XML 方式或 Java 配置方式）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.example&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><u>三、基于 Java 配置类（JavaConfig）</u></p>
<p>特点：</p>
<ul>
<li>完全用 Java 代码代替 XML。</li>
<li>强类型检查，编译期就能发现错误。</li>
<li>适用于中大型项目、Spring Boot 推荐方式。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserRepository <span class="title function_">userRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserRepository</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserService</span>(userRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br></pre></td></tr></table></figure>
<h3 id="7-什么是基于-Java-的-Spring-注解配置-请举例说明？">7. 什么是基于 Java 的 Spring 注解配置? 请举例说明？</h3>
<p><strong><u>基于 Java 的 Spring 注解配置</u>（Java-based configuration）</strong> 是指：使用普通的 Java 类和注解（如 <code>@Configuration</code>、<code>@Bean</code>、<code>@ComponentScan</code> 等）来代替传统的 XML 配置文件，完成 Spring 容器的初始化与 Bean 的定义与装配。这是 <strong>Spring 3.0+</strong> 引入的一种更灵活、类型安全的配置方式，也是 <strong>Spring Boot 推荐的主流方式</strong>。</p>
<p><u>举例如下</u>：</p>
<ol>
<li>
<p>定义业务类和依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserRepository.save()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        userRepository.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>配置类（JavaConfig）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserRepository <span class="title function_">userRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserRepository</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 手动注入依赖</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserService</span>(userRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动 Spring 容器并使用 Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        service.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="8-什么是注解？Spring-的常用注解有哪些？怎样开启注解装配？">8. 什么是注解？Spring 的常用注解有哪些？怎样开启注解装配？</h3>
<p><strong><u>注解</u></strong> 是 Java 5 引入的一种 <strong>元数据机制</strong>，用于为程序中的类、方法、字段等添加额外的信息。它本质上是标记，用于被编译器或框架识别并执行特定逻辑。在 Spring 中，注解被广泛用于实现配置、依赖注入、面向切面编程等功能，是替代 XML 配置的主流方式。</p>
<hr>
<p><u>Spring 常用注解</u>：</p>
<ol>
<li>
<p>通用组件声明注解（用于标记为 Bean）</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>用途</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Component</code></td>
<td>通用组件</td>
<td>表示一个通用 Bean，会被扫描到容器中</td>
</tr>
<tr>
<td><code>@Service</code></td>
<td>业务逻辑组件</td>
<td>表示 Service 层 Bean</td>
</tr>
<tr>
<td><code>@Repository</code></td>
<td>数据访问组件</td>
<td>表示 DAO 层 Bean，支持数据访问异常转换</td>
</tr>
<tr>
<td><code>@Controller</code></td>
<td>Web 控制器</td>
<td>Spring MVC 控制器类</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>依赖注入相关注解</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>用途</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Autowired</code></td>
<td>自动注入</td>
<td>默认按类型注入 Bean，可与 <code>@Qualifier</code> 配合指定名称</td>
</tr>
<tr>
<td><code>@Qualifier</code></td>
<td>指定 Bean 名称注入</td>
<td>配合 <code>@Autowired</code> 使用</td>
</tr>
<tr>
<td><code>@Value</code></td>
<td>注入常量、配置值</td>
<td>可从 <code>application.properties</code> 注入值</td>
</tr>
<tr>
<td><code>@Inject</code>（JSR-330）</td>
<td>自动注入（标准）</td>
<td>与 <code>@Autowired</code> 类似，但无 Spring 特有功能</td>
</tr>
<tr>
<td><code>@Resource</code>（JSR-250）</td>
<td>自动注入</td>
<td>默认按名称注入，也可按类型</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>配置相关注解</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>用途</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Configuration</code></td>
<td>配置类</td>
<td>等价于一个 XML 配置文件</td>
</tr>
<tr>
<td><code>@Bean</code></td>
<td>定义 Bean</td>
<td>在配置类中定义方法并返回 Bean</td>
</tr>
<tr>
<td><code>@ComponentScan</code></td>
<td>扫描组件</td>
<td>指定扫描的包路径</td>
</tr>
<tr>
<td><code>@Import</code></td>
<td>导入其他配置类</td>
<td>用于模块化配置</td>
</tr>
<tr>
<td><code>@PropertySource</code></td>
<td>加载配置文件</td>
<td>例如加载 <code>application.properties</code></td>
</tr>
</tbody>
</table>
</li>
</ol>
<hr>
<p><u>开启注解装配的两种方法</u>：</p>
<ol>
<li>
<p>基于 Java 配置开启组件扫描：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>基于 XML 开启组件扫描</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.example&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="9-Component-Controller-Repository-Service-有何区别？">9. @Component, @Controller, @Repository, @Service 有何区别？</h3>
<table>
<thead>
<tr>
<th>注解</th>
<th>适用层</th>
<th>语义作用</th>
<th>特殊支持</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Component</code></td>
<td>通用组件层</td>
<td>标准的组件类，无特定角色</td>
<td>无</td>
</tr>
<tr>
<td><code>@Service</code></td>
<td><strong>业务逻辑层</strong></td>
<td>表示这是一个 Service 组件</td>
<td>用于业务逻辑封装，可能与 AOP 搭配使用</td>
</tr>
<tr>
<td><code>@Repository</code></td>
<td><strong>持久层（DAO）</strong></td>
<td>表示数据访问组件</td>
<td>自动转换数据库相关异常为 Spring 异常</td>
</tr>
<tr>
<td><code>@Controller</code></td>
<td><strong>表现层（MVC 控制器）</strong></td>
<td>表示控制器类，处理 Web 请求</td>
<td>配合 Spring MVC 处理前端请求</td>
</tr>
</tbody>
</table>
<h3 id="10-Autowired-和-Resource-之间的区别，-Qualifier-注解有什么作用？">10. @Autowired 和@Resource 之间的区别，@Qualifier 注解有什么作用？</h3>
<p><u>@Autowired 和@Resource 之间的区别如下</u>：</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th><code>@Autowired</code>（Spring 提供）</th>
<th><code>@Resource</code>（JDK 提供，JSR-250）</th>
</tr>
</thead>
<tbody>
<tr>
<td>所属框架</td>
<td>Spring 专属注解</td>
<td>Java 标准注解</td>
</tr>
<tr>
<td>依赖注入方式</td>
<td><strong>默认按类型注入</strong>（byType）</td>
<td><strong>默认按名称注入</strong>（byName）</td>
</tr>
<tr>
<td>是否支持按名称注入</td>
<td>可以搭配 <code>@Qualifier(&quot;beanName&quot;)</code> 实现</td>
<td>默认就按名称注入</td>
</tr>
<tr>
<td>是否支持构造方法注入</td>
<td>支持</td>
<td>不支持（只能字段或 setter）</td>
</tr>
<tr>
<td>是否支持 <code>@Primary</code></td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>是否支持 <code>required = false</code></td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>是否推荐</td>
<td>Spring 推荐使用</td>
<td>兼容标准但功能有限</td>
</tr>
</tbody>
</table>
<p><u>@Qualifier 注解的作用如下</u>：</p>
<p>默认情况下，@Autowired 按类型装配 Spring Bean。当存在 <strong>多个相同类型的 Bean</strong> 时，<code>@Autowired</code> 无法唯一确定注入哪个 Bean，就会报错。</p>
<p>此时使用 <code>@Qualifier</code> 指定 <strong>Bean 的名称</strong>，用于明确选择哪一个 Bean。</p>
<h3 id="11-Spring-支持两种类型的事务管理，分别是什么？如何实现的？你更倾向用那种事务管理类型？为什么？">11. Spring 支持两种类型的事务管理，分别是什么？如何实现的？你更倾向用那种事务管理类型？为什么？</h3>
<p><u>Spring 支持两种类型的事务管理</u>：</p>
<p><strong>1. 编程式事务管理（Programmatic Transaction Management）</strong></p>
<ul>
<li>
<p>编程式事务管理是通过编写代码实现的事务管理。这种方式能够在代码中精确地定义事务的边界,我们可以根据需求规定事务从哪里开始,到哪里结束。</p>
</li>
<li>
<p><strong>实现方式</strong>：程序员通过代码显式地控制事务的开启、提交和回滚。通常通过 Spring 提供的 <code>PlatformTransactionManager</code> 和 <code>TransactionTemplate</code> 来实现。</p>
</li>
<li>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TransactionTemplate</span> <span class="variable">transactionTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionTemplate</span>(transactionManager);</span><br><span class="line">transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>特点</strong>：</p>
<ul>
<li>细粒度控制，灵活。</li>
<li>代码侵入性强，业务代码和事务管理耦合度高。</li>
<li>维护成本较高，不利于代码复用。</li>
</ul>
</li>
</ul>
<p><strong>2. 声明式事务管理（Declarative Transaction Management）</strong></p>
<ul>
<li>
<p>Spring声明式事务管理在底层采用了AOP技术，其最大的优点在于无须通过编程的方式管理事务，只需要在配置文件中进行相关的规则声明,就可以将事务规则应用到业务逻辑中。</p>
</li>
<li>
<p><strong>实现方式</strong>：通过配置（XML 或注解）声明事务的边界，Spring AOP（代理机制）自动为目标方法生成事务代理，无需在代码中手动控制事务。</p>
</li>
<li>
<p><strong>常用实现</strong>：</p>
<ul>
<li>使用 <code>@Transactional</code> 注解</li>
<li>XML 配置 <code>&lt;tx:advice&gt;</code> 和事务切面</li>
</ul>
</li>
<li>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someServiceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 业务代码，Spring 自动管理事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>特点</strong>：</p>
<ul>
<li>代码与事务逻辑分离，业务代码更简洁。</li>
<li>易于维护和管理。</li>
<li>灵活配置事务属性（传播行为、隔离级别、超时等）。</li>
</ul>
</li>
</ul>
<hr>
<p>我更倾向于使用<strong>声明式事务管理</strong>，原因如下：</p>
<ol>
<li><strong>简洁清晰</strong>：使用注解或配置即可实现事务管理，无需在业务代码中写大量事务控制逻辑。</li>
<li><strong>低耦合</strong>：业务逻辑和事务控制分离，代码更易于维护和理解。</li>
<li><strong>灵活配置</strong>：可以通过配置灵活调整事务属性，支持不同方法使用不同事务策略。</li>
<li><strong>Spring 推荐方式</strong>：Spring 官方和社区普遍推荐声明式事务，适合绝大多数业务场景。</li>
</ol>
<p>如果需要非常细粒度或动态的事务控制，或者在特定复杂场景下，才会考虑编程式事务管理。大多数日常开发推荐用声明式事务。</p>
<h3 id="12-Spring-框架的事务管理有哪些优点？">12. Spring 框架的事务管理有哪些优点？</h3>
<p><u>Spring 框架的事务管理有以下几个优点</u>：</p>
<ol>
<li><strong>统一的事务管理接口</strong><br>
Spring 提供统一的 <code>PlatformTransactionManager</code> 接口，支持多种事务管理器（JDBC、JTA、Hibernate、JPA 等），方便开发者在不同持久化技术间切换而不改业务代码。</li>
<li><strong>声明式事务支持，简化开发</strong><br>
通过注解（如 <code>@Transactional</code>）或 XML 配置即可实现事务管理，业务代码无需显式管理事务，减少代码侵入，增强代码的可读性和维护性。</li>
<li><strong>灵活的事务配置</strong><br>
可以针对不同方法设置不同的事务属性，如传播行为（Propagation）、隔离级别（Isolation）、超时（Timeout）、只读（Read-only）等，满足复杂业务需求。</li>
<li><strong>支持多种事务传播行为</strong><br>
Spring 支持多种传播机制，比如 <code>REQUIRED</code>、<code>REQUIRES_NEW</code> 等，能够处理复杂的事务嵌套和事务边界，保证事务的一致性和完整性。</li>
<li><strong>跨多个资源的分布式事务支持</strong><br>
Spring 能集成 JTA 事务管理器，支持分布式事务，协调多个资源管理器（如多个数据库、消息队列等）的一致提交和回滚。</li>
<li><strong>良好的异常回滚机制</strong><br>
支持根据异常类型自动决定事务是否回滚，默认运行时异常触发回滚，也可以自定义规则，提高事务的可靠性。</li>
<li><strong>基于 AOP 实现，非侵入式</strong><br>
利用 Spring AOP 实现事务管理，不需要修改业务逻辑代码，做到关注点分离，提高代码整洁度。</li>
<li><strong>易于集成与扩展</strong><br>
Spring 事务管理与其他 Spring 组件（如 Spring Data、Spring MVC、Spring Boot）无缝集成，方便构建企业级应用。</li>
</ol>
<h3 id="13-什么是-AOP，AOP-中有哪些关键术语，什么是切面（Aspect），什么是通知（Advice）？Spring-通知有哪些类型？">13. 什么是 AOP，AOP 中有哪些关键术语，什么是切面（Aspect），什么是通知（Advice）？Spring 通知有哪些类型？</h3>
<p><strong><u>AOP</u>（Aspect-Oriented Programming，面向切面编程）</strong> 是一种编程范式，它通过将横切关注点（cross-cutting concerns，如事务管理、日志、安全等）从业务逻辑中分离出来，实现关注点的模块化。<br>
简而言之，AOP 能帮助我们在不改变业务代码的情况下，把一些公共功能（如日志、事务）“切入”到程序的执行流程中。</p>
<p><u>AOP 中的关键术语</u>：</p>
<ul>
<li><strong>切面（Aspect）</strong><br>
切面是指封装横切到系统功能（如事务处理）的类，是横切关注点的模块化表现，是通知和切点的结合体。它定义了具体在哪些位置（切点）执行什么样的额外行为（通知）。</li>
<li><strong>连接点（Join point）</strong><br>
程序执行中的某个特定点，比如方法调用、方法执行、异常抛出等。在 Spring AOP 中，连接点通常指与方法执行相关的特定节点。</li>
<li><strong>切入点（Pointcut）</strong><br>
切入点是对连接点的定义和筛选，是指那些需要处理的连接点的集合，告诉 AOP 框架在哪些连接点上应用通知。它通过表达式匹配特定的方法或类。</li>
<li><strong>通知（Advice）</strong><br>
通知是由切面添加到特定的连接点（满足切入点规则）的一段代码，是切面中定义的具体动作，指在切点上要执行的代码，比如前置通知、后置通知等。</li>
<li><strong>目标对象（Target Object）</strong><br>
被通知的业务对象，通知所作用的目标业务类就是目标对象。</li>
<li><strong>代理对象（Proxy）</strong><br>
由 Spring AOP 创建的包装了目标对象的对象，通过代理实现对目标对象方法的增强。目标类被AOP织入增强后产生的一个结果类，这个结果类就是代理类，代理类融合了原类和增强的逻辑。</li>
<li><strong>织入（Weaving）</strong><br>
织入是将通知添加到目标类具体连接点的过程，这些可以在编译时、类加载时和运行时完成。</li>
<li><strong>引入（Introduction）</strong><br>
引介是一种特殊的通知，它为类添加一些属性和方法。即使一个业务类原本没有实现某一个接口，通过AOP的引介功能，也可以动态地为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。</li>
</ul>
<hr>
<p><u>Spring 通知的类型</u>：</p>
<ul>
<li>
<p>**环绕通知<br>
环绕通知是在目标方法执行前和执行后实施增强，可以应用于日志记录、事务处理等功能。</p>
</li>
<li>
<p>**前置通知<br>
前置通知是在目标方法执行前实施增强，可应用于权限管理等功能。</p>
</li>
<li>
<p><strong>后置通知</strong><br>
后置返回通知是在目标方法成功执行后实施增强，可应用于关闭流、删除临时文件等功能。</p>
</li>
<li>
<p><strong>后置（最终）通知</strong><br>
后置通知是在目标方法执行后实施增强，与后置返回通知不同的是，不管是否发生异常都要执行该通知，可应用于释放资源。</p>
</li>
<li>
<p>**异常通知<br>
异常通知是在方法抛出异常后实施增强，可以应用于处理异常、记录日志等功能。</p>
</li>
<li>
<p><strong>引入通知</strong><br>
引入通知是在目标类中添加一些新的方法和属性，可以应用于修改目标类（增强类）。</p>
</li>
</ul>
<h3 id="14-Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？">14. Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</h3>
<p><u>Spring AOP 与 AspectJ AOP 的区别</u>：</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>Spring AOP</th>
<th>AspectJ AOP</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>实现机制</strong></td>
<td>基于 <strong>动态代理</strong>（JDK 或 CGLIB）</td>
<td>基于 <strong>编译时织入</strong> 或 <strong>类加载时织入</strong></td>
</tr>
<tr>
<td><strong>织入时机</strong></td>
<td>运行时（Runtime）</td>
<td>编译期或类加载期</td>
</tr>
<tr>
<td><strong>目标</strong></td>
<td>主要用于方法级别增强</td>
<td>支持方法、构造函数、字段等更细粒度的增强</td>
</tr>
<tr>
<td><strong>配置复杂度</strong></td>
<td>简单（基于 Spring 配置或注解）</td>
<td>相对复杂（需要额外编译器或插件支持）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>性能较好（只增强 Spring 管理的 Bean）</td>
<td>性能最佳（直接织入字节码）</td>
</tr>
<tr>
<td><strong>灵活性与功能强大程度</strong></td>
<td>功能相对有限（主要方法级别）</td>
<td>功能强大（支持更多连接点类型）</td>
</tr>
<tr>
<td><strong>常见使用场景</strong></td>
<td>大多数企业开发中足够使用</td>
<td>对性能和织入粒度要求更高的项目中使用</td>
</tr>
</tbody>
</table>
<p><u>AOP 的实现方式</u>主要包括以下几种：</p>
<ol>
<li>
<p><strong>基于代理的 AOP</strong></p>
<ul>
<li>
<p>Spring AOP 的核心方式。</p>
</li>
<li>
<p>使用 JDK 动态代理（针对接口）或 CGLIB 字节码生成（针对类）。</p>
</li>
<li>
<p>运行时通过代理对象织入增强逻辑。</p>
</li>
<li>
<p>优点：不修改原始类，Spring 自动管理；缺点：只能作用于 Spring 容器中的 Bean 且主要支持方法级别增强。</p>
</li>
</ul>
</li>
<li>
<p><strong>基于字节码织入的 AOP（如 AspectJ）</strong></p>
<ul>
<li>
<p>在编译阶段或类加载阶段修改字节码，直接将增强代码嵌入到目标类中。</p>
</li>
<li>
<p>支持更丰富的连接点（如字段、构造器）。</p>
</li>
<li>
<p>优点：性能高，灵活性强；缺点：配置复杂，依赖 AspectJ 编译器或 LTW（Load-Time Weaving）机制。</p>
</li>
</ul>
</li>
<li>
<p><strong>基于字节码操作框架（如 ASM、Javassist）</strong></p>
<ul>
<li>
<p>手动或通过框架修改类字节码，实现 AOP 功能。</p>
</li>
<li>
<p>更底层，通常用于构建自己的 AOP 框架或进行底层性能优化。</p>
</li>
<li>
<p>一般不推荐直接使用，除非有特殊需求。</p>
</li>
</ul>
</li>
<li>
<p><strong>基于自定义注解 + 反射 +代理</strong></p>
<ul>
<li>
<p>使用自定义注解标记方法 + 反射拦截执行 + 动态代理注入增强逻辑。</p>
</li>
<li>
<p>比较原始，但可以满足简单 AOP 需求，常用于学习或特定轻量场景。</p>
</li>
</ul>
</li>
</ol>
<h3 id="15-什么是-Spring-MVC-？简单介绍下你对-springMVC-的理解">15. 什么是 Spring MVC ？简单介绍下你对 springMVC 的理解</h3>
<p>Spring MVC（Model-View-Controller）是 Spring 框架中的一个<strong>基于请求驱动的 Web 框架</strong>，用于构建<strong>Web 应用程序</strong>。它采用了经典的 MVC 设计模式，目的是将表现层（前端展示）和业务逻辑层（后端处理）解耦，使 Web 应用更清晰、更易于维护和扩展。</p>
<hr>
<p>我的理解：Spring MVC 是一个轻量级、高扩展性的 Web 框架，能够快速开发清晰、模块化的 Web 应用，尤其适合构建 RESTful 接口。</p>
<hr>
<ol>
<li><strong>Spring MVC 的核心流程</strong></li>
</ol>
<p>一次请求在 Spring MVC 中的处理流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">客户端 --&gt; DispatcherServlet --&gt; HandlerMapping</span><br><span class="line">             ↓</span><br><span class="line">         Controller（处理器）  </span><br><span class="line">             ↓</span><br><span class="line">         返回 ModelAndView</span><br><span class="line">             ↓</span><br><span class="line">        ViewResolver（视图解析器）</span><br><span class="line">             ↓</span><br><span class="line">            渲染页面 / JSON</span><br><span class="line">             ↓</span><br><span class="line">           返回客户端</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>核心组件说明</strong></li>
</ol>
<table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DispatcherServlet</strong></td>
<td>前端控制器，接收请求并统一调度处理。</td>
</tr>
<tr>
<td><strong>HandlerMapping</strong></td>
<td>负责根据 URL 查找对应的控制器（Controller）。</td>
</tr>
<tr>
<td><strong>Controller</strong></td>
<td>控制器，处理请求并返回数据或视图名。</td>
</tr>
<tr>
<td><strong>ModelAndView</strong></td>
<td>封装模型数据和视图名。</td>
</tr>
<tr>
<td><strong>ViewResolver</strong></td>
<td>将逻辑视图名解析为实际视图（如 JSP、Thymeleaf、JSON 等）。</td>
</tr>
<tr>
<td><strong>View</strong></td>
<td>负责展示页面或数据给用户。</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>
<p><strong>Spring MVC 的特点</strong></p>
<ul>
<li>
<p><strong>基于注解的开发简洁高效</strong>（如 <code>@Controller</code>, <code>@RequestMapping</code>, <code>@RestController</code>）</p>
</li>
<li>
<p><strong>支持 RESTful 风格 URL 路由</strong></p>
</li>
<li>
<p><strong>与 Spring 框架无缝整合</strong>（如依赖注入、事务管理）</p>
</li>
<li>
<p><strong>灵活的视图解析</strong>（支持 JSP、FreeMarker、Thymeleaf、JSON 等）</p>
</li>
<li>
<p><strong>拦截器支持</strong>，可用于登录验证、权限控制等横切逻辑</p>
</li>
<li>
<p><strong>良好的扩展性与插件机制</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>使用场景</strong></p>
<ul>
<li>
<p>构建传统 Web 页面（如后台管理系统）</p>
</li>
<li>
<p>构建 REST API 接口（结合 <code>@RestController</code> 和 JSON 序列化）</p>
</li>
<li>
<p>与前端分离式开发（如前后端分离架构：Vue + SpringBoot）</p>
</li>
</ul>
</li>
</ol>
<h3 id="16-SpringMVC-主要有几部分组成，简单描述-SpringMVC-的工作流程？">16. SpringMVC 主要有几部分组成，简单描述 SpringMVC 的工作流程？</h3>
<p><u>SpringMVC 的主要组成部分</u>（7 个核心组件）：</p>
<table>
<thead>
<tr>
<th>组件名</th>
<th>简要说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. DispatcherServlet（前端控制器）</strong></td>
<td>核心调度器，所有请求先到它，由它统一分发。</td>
</tr>
<tr>
<td><strong>2. HandlerMapping（处理器映射器）</strong></td>
<td>根据请求 URL 匹配对应的控制器（Handler）。</td>
</tr>
<tr>
<td><strong>3. Handler（处理器）</strong></td>
<td>即 <code>@Controller</code> 类中的方法，真正处理业务逻辑。</td>
</tr>
<tr>
<td><strong>4. HandlerAdapter（处理器适配器）</strong></td>
<td>调用具体的 Handler 方法，并封装结果。</td>
</tr>
<tr>
<td><strong>5. ModelAndView（模型和视图）</strong></td>
<td>Handler 返回的对象，包含模型数据和视图名。</td>
</tr>
<tr>
<td><strong>6. ViewResolver（视图解析器）</strong></td>
<td>将视图名解析为具体的视图（如 JSP 页面或 JSON）。</td>
</tr>
<tr>
<td><strong>7. View（视图）</strong></td>
<td>负责渲染页面或数据，最终返回给用户。</td>
</tr>
</tbody>
</table>
<p><u>Spring MVC的工作流程如下</u>：</p>
<ol>
<li><strong>用户发起请求</strong>：<br>
浏览器或客户端发送请求（如 <code>/user/list</code>）到服务器。</li>
<li><strong>DispatcherServlet 接收请求</strong>：<br>
所有请求首先被 <code>DispatcherServlet</code> 拦截，这是 SpringMVC 的入口。</li>
<li><strong>查找 HandlerMapping</strong>：<br>
<code>DispatcherServlet</code> 根据请求 URL，向 <code>HandlerMapping</code> 查找匹配的 <code>Controller</code> 方法。</li>
<li><strong>找到 Handler 并调用适配器</strong>：<br>
找到目标方法后，通过 <code>HandlerAdapter</code> 调用对应的 <code>@Controller</code> 方法。</li>
<li><strong>执行 Controller 方法</strong>：<br>
控制器执行业务逻辑，返回一个 <code>ModelAndView</code> 对象（包含数据和视图名）。</li>
<li><strong>视图解析器处理视图名</strong>：<br>
<code>DispatcherServlet</code> 调用 <code>ViewResolver</code> 把逻辑视图名（如 <code>&quot;userList&quot;</code>）解析为具体视图（如 <code>/WEB-INF/views/userList.jsp</code> 或 JSON）。</li>
<li><strong>视图渲染并响应客户端</strong>：<br>
由视图对象（如 JSP 引擎或 JSON 序列化）完成最终页面或数据渲染，响应返回给用户。</li>
</ol>
<h3 id="17-到目前为止，你共学习了哪些注解？请总结列举，越多越好">17. 到目前为止，你共学习了哪些注解？请总结列举，越多越好</h3>
<h4 id="一、Spring-核心注解">一、Spring 核心注解</h4>
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Component</code></td>
<td>标注为组件类，由 Spring 容器管理</td>
</tr>
<tr>
<td><code>@Controller</code></td>
<td>标注为控制器类，处理 Web 请求</td>
</tr>
<tr>
<td><code>@Service</code></td>
<td>标注为服务层组件</td>
</tr>
<tr>
<td><code>@Repository</code></td>
<td>标注为持久层组件，自动处理异常转换</td>
</tr>
<tr>
<td><code>@Autowired</code></td>
<td>自动注入依赖（按类型注入）</td>
</tr>
<tr>
<td><code>@Qualifier</code></td>
<td>与 <code>@Autowired</code> 配合，按名称注入</td>
</tr>
<tr>
<td><code>@Value</code></td>
<td>注入配置文件中的值</td>
</tr>
<tr>
<td><code>@Bean</code></td>
<td>定义一个 Bean 实例，常用于 Java 配置类中</td>
</tr>
<tr>
<td><code>@Configuration</code></td>
<td>表示当前类是配置类（替代 XML 配置）</td>
</tr>
<tr>
<td><code>@Import</code></td>
<td>引入其他配置类</td>
</tr>
<tr>
<td><code>@ComponentScan</code></td>
<td>指定要扫描的包路径</td>
</tr>
<tr>
<td><code>@Lazy</code></td>
<td>延迟初始化 Bean</td>
</tr>
<tr>
<td><code>@Primary</code></td>
<td>当有多个候选 Bean 时优先使用</td>
</tr>
</tbody>
</table>
<h4 id="二、Spring-Boot-注解">二、Spring Boot 注解</h4>
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@SpringBootApplication</code></td>
<td>包含 <code>@Configuration</code>、<code>@ComponentScan</code>、<code>@EnableAutoConfiguration</code></td>
</tr>
<tr>
<td><code>@EnableAutoConfiguration</code></td>
<td>启用 Spring Boot 自动配置</td>
</tr>
<tr>
<td><code>@ConfigurationProperties</code></td>
<td>将配置文件绑定为对象</td>
</tr>
<tr>
<td><code>@RestController</code></td>
<td>相当于 <code>@Controller + @ResponseBody</code>，用于 REST 接口</td>
</tr>
<tr>
<td><code>@RequestMapping</code></td>
<td>映射请求路径</td>
</tr>
<tr>
<td><code>@GetMapping / @PostMapping / @PutMapping / @DeleteMapping</code></td>
<td>映射 HTTP 请求方式</td>
</tr>
<tr>
<td><code>@PathVariable</code></td>
<td>获取 URL 中的路径参数</td>
</tr>
<tr>
<td><code>@RequestParam</code></td>
<td>获取请求参数（如 ?id=1）</td>
</tr>
<tr>
<td><code>@RequestBody</code></td>
<td>接收 JSON 数据并转换为 Java 对象</td>
</tr>
<tr>
<td><code>@ResponseBody</code></td>
<td>将方法返回值直接作为响应体</td>
</tr>
<tr>
<td><code>@CrossOrigin</code></td>
<td>解决跨域请求问题</td>
</tr>
</tbody>
</table>
<h4 id="三、Spring-AOP-事务相关注解">三、Spring AOP / 事务相关注解</h4>
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Transactional</code></td>
<td>声明事务（可配置传播行为、隔离级别等）</td>
</tr>
<tr>
<td><code>@EnableTransactionManagement</code></td>
<td>启用基于注解的事务管理</td>
</tr>
<tr>
<td><code>@Aspect</code></td>
<td>声明一个切面类</td>
</tr>
<tr>
<td><code>@Before / @After / @Around / @AfterReturning / @AfterThrowing</code></td>
<td>AOP 通知类型</td>
</tr>
<tr>
<td><code>@Pointcut</code></td>
<td>定义切点表达式</td>
</tr>
</tbody>
</table>
<h4 id="四、Spring-Security-常用注解">四、Spring Security 常用注解</h4>
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@EnableWebSecurity</code></td>
<td>启用 Spring Security 安全配置</td>
</tr>
<tr>
<td><code>@PreAuthorize</code></td>
<td>方法调用前进行权限校验（基于表达式）</td>
</tr>
<tr>
<td><code>@Secured</code></td>
<td>基于角色的权限控制</td>
</tr>
<tr>
<td><code>@RolesAllowed</code></td>
<td>基于角色控制访问权限（JDK 标准）</td>
</tr>
<tr>
<td><code>@AuthenticationPrincipal</code></td>
<td>获取当前登录用户对象</td>
</tr>
</tbody>
</table>
<h4 id="五、JPA-Hibernate-注解（ORM-映射）">五、JPA / Hibernate 注解（ORM 映射）</h4>
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Entity</code></td>
<td>实体类映射数据库表</td>
</tr>
<tr>
<td><code>@Table(name=&quot;...&quot;)</code></td>
<td>映射数据库表名</td>
</tr>
<tr>
<td><code>@Id</code></td>
<td>主键字段</td>
</tr>
<tr>
<td><code>@GeneratedValue</code></td>
<td>主键生成策略</td>
</tr>
<tr>
<td><code>@Column(name=&quot;...&quot;)</code></td>
<td>映射数据库列</td>
</tr>
<tr>
<td><code>@OneToMany</code> / <code>@ManyToOne</code> / <code>@OneToOne</code> / <code>@ManyToMany</code></td>
<td>关系映射注解</td>
</tr>
<tr>
<td><code>@JoinColumn</code></td>
<td>外键关联字段</td>
</tr>
<tr>
<td><code>@Transient</code></td>
<td>不映射到数据库字段</td>
</tr>
<tr>
<td><code>@Enumerated</code></td>
<td>枚举映射</td>
</tr>
</tbody>
</table>
<h4 id="六、MyBatis-注解">六、MyBatis 注解</h4>
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Mapper</code></td>
<td>标记 Mapper 接口，让 Spring 容器识别</td>
</tr>
<tr>
<td><code>@Select / @Insert / @Update / @Delete</code></td>
<td>编写 SQL 语句</td>
</tr>
<tr>
<td><code>@Results</code> / <code>@Result</code></td>
<td>结果映射关系</td>
</tr>
<tr>
<td><code>@Param</code></td>
<td>为方法参数指定名称，用于 SQL 中引用</td>
</tr>
</tbody>
</table>
<h4 id="七、验证注解（JSR-303-Hibernate-Validator）">七、验证注解（JSR 303 / Hibernate Validator）</h4>
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@NotNull</code></td>
<td>值不能为 null</td>
</tr>
<tr>
<td><code>@NotBlank</code></td>
<td>字符串不能为空（不为空且去空格后长度 &gt; 0）</td>
</tr>
<tr>
<td><code>@Size(min=, max=)</code></td>
<td>字符串或集合长度限制</td>
</tr>
<tr>
<td><code>@Email</code></td>
<td>邮箱格式验证</td>
</tr>
<tr>
<td><code>@Pattern</code></td>
<td>正则表达式验证</td>
</tr>
<tr>
<td><code>@Min</code> / <code>@Max</code></td>
<td>最小/最大值限制</td>
</tr>
<tr>
<td><code>@Valid</code> / <code>@Validated</code></td>
<td>触发对象级别的校验</td>
</tr>
</tbody>
</table>
<h4 id="八、其他常用注解">八、其他常用注解</h4>
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Slf4j</code>（Lombok）</td>
<td>自动生成 <code>log</code> 对象</td>
</tr>
<tr>
<td><code>@Data</code>（Lombok）</td>
<td>自动生成 getter/setter、equals、toString</td>
</tr>
<tr>
<td><code>@Builder</code>（Lombok）</td>
<td>支持链式构建对象</td>
</tr>
<tr>
<td><code>@PostConstruct</code></td>
<td>Bean 初始化后执行方法</td>
</tr>
<tr>
<td><code>@PreDestroy</code></td>
<td>Bean 销毁前执行方法</td>
</tr>
<tr>
<td><code>@Scheduled</code></td>
<td>定时任务执行方法</td>
</tr>
<tr>
<td><code>@Async</code></td>
<td>异步执行方法</td>
</tr>
</tbody>
</table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://bush-cn.github.io">bush Wu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://bush-cn.github.io/2025/07/11/Java%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91%E7%AE%80%E7%AD%94%E9%A2%981%EF%BC%88Spring%EF%BC%89/">http://bush-cn.github.io/2025/07/11/Java%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91%E7%AE%80%E7%AD%94%E9%A2%981%EF%BC%88Spring%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://bush-cn.github.io" target="_blank">bush's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Spring/">Spring</a><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF/">后端</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/11/Java%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91%E7%AE%80%E7%AD%94%E9%A2%982%EF%BC%88MyBatis%EF%BC%89/" title="Java企业级开发简答题2（MyBatis）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java企业级开发简答题2（MyBatis）</div></div><div class="info-2"><div class="info-item-1">作业 2：简答题  22371495 吴自强  [TOC] 1. 简述 MyBatis 的工作原理 MyBatis 的工作原理可以概括如下： 一、配置阶段  加载配置文件 MyBatis 启动时会加载 mybatis-config.xml 配置文件，其中包括数据库连接信息、Mapper 映射文件路径等。 构建 SqlSessionFactory 通过 SqlSessionFactoryBuilder 读取配置文件并构建 SqlSessionFactory。这个工厂负责创建 SqlSession。  二、运行阶段  创建 SqlSession 应用程序通过 SqlSessionFactory 创建一个 SqlSession 对象，用于执行 SQL。 执行 SQL 映射  使用接口绑定（Mapper 接口）或者 XML 映射文件中的 SQL 语句。 MyBatis 会根据 Mapper.xml 中的 SQL 映射，将参数传入、生成最终 SQL，并执行。   执行 JDBC 操作 MyBatis 底层仍然使用 JDBC 执行 SQL，通过 JDBC 与数据库交互。 结果映射 SQL...</div></div></div></a><a class="pagination-related" href="/2025/07/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E5%9B%9E%E9%A1%BE/" title="算法导论笔记整理回顾"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">算法导论笔记整理回顾</div></div><div class="info-2"><div class="info-item-1"> 这是笔者大二上学的课了，现在把之前的笔记整理复习一遍。 部分内容由AI生成。。。  第2章 算法基础 2.1 插入排序 c++代码： 12345678INSERTION-SORT(A)for j = 2 to A.length	key = A[j]	i = j - 1	while i &gt; 0 and A[i] &gt; key		A[i+1] =A[i];		i = i - 1;	A[i + 1] = key 123456789101112131415/**插入排序@para array and array&#x27;s length下标从0开始*/void insertion_sort(int&amp; A, int n)&#123;	for(int j = 1; j &lt; n; j++)&#123;		int key = A[j];		i = j - 1;		while(i &gt;= 0 &amp;&amp; A[i] &gt; key)&#123;			A[i + 1] = A[i];			i = i - 1;		&#125;	 A[i + 1] =...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/11/Java%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91%E7%AE%80%E7%AD%94%E9%A2%982%EF%BC%88MyBatis%EF%BC%89/" title="Java企业级开发简答题2（MyBatis）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-11</div><div class="info-item-2">Java企业级开发简答题2（MyBatis）</div></div><div class="info-2"><div class="info-item-1">作业 2：简答题  22371495 吴自强  [TOC] 1. 简述 MyBatis 的工作原理 MyBatis 的工作原理可以概括如下： 一、配置阶段  加载配置文件 MyBatis 启动时会加载 mybatis-config.xml 配置文件，其中包括数据库连接信息、Mapper 映射文件路径等。 构建 SqlSessionFactory 通过 SqlSessionFactoryBuilder 读取配置文件并构建 SqlSessionFactory。这个工厂负责创建 SqlSession。  二、运行阶段  创建 SqlSession 应用程序通过 SqlSessionFactory 创建一个 SqlSession 对象，用于执行 SQL。 执行 SQL 映射  使用接口绑定（Mapper 接口）或者 XML 映射文件中的 SQL 语句。 MyBatis 会根据 Mapper.xml 中的 SQL 映射，将参数传入、生成最终 SQL，并执行。   执行 JDBC 操作 MyBatis 底层仍然使用 JDBC 执行 SQL，通过 JDBC 与数据库交互。 结果映射 SQL...</div></div></div></a><a class="pagination-related" href="/2025/06/13/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Redis学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-13</div><div class="info-item-2">Redis学习笔记</div></div><div class="info-2"><div class="info-item-1">Redis学习笔记 Redis Redis简介 Redis（Remote Dictionary Server）是一种开源的、基于内存的键值对（key-value）数据库，可以用作数据库、缓存和消息中间件。它以极高的性能、丰富的数据结构和多种实用功能而著称，被广泛用于高并发、低延迟的应用场景中，如电商秒杀、社交应用、排行榜、会话缓存等。 Redis特点    特点 说明     高性能 所有数据操作都在内存中完成，读写速度极快（百万级QPS）。   丰富数据结构 支持多种数据类型：字符串（string）、列表（list）、集合（set）、有序集合（zset）、哈希表（hash）、位图、HyperLogLog、地理位置等。   持久化 虽然是内存数据库，但支持将数据持久化到磁盘，防止宕机数据丢失（RDB快照和AOF日志）。   支持事务 可以一次执行多个命令，具备基本的事务特性（MULTI/EXEC）。   支持发布/订阅 可实现消息系统的 pub/sub 通信模型。   支持主从复制与集群 具备高可用（哨兵）与分布式（Redis Cluster）能力。   原子操作 所有单条...</div></div></div></a><a class="pagination-related" href="/2025/06/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Java 多线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-13</div><div class="info-item-2">Java 多线程</div></div><div class="info-2"><div class="info-item-1">Java多线程 Java SE中的多线程 Java SE中最基础的多线程方式（适用于任何Java程序）包括两种：   方法1：继承 Thread 类 123456public class MyThread extends Thread &#123;    @Override    public void run() &#123;        System.out.println(&quot;线程名：&quot; + Thread.currentThread().getName());    &#125;&#125; 使用： 123456public class Main &#123;    public static void main(String[] args) &#123;        MyThread t1 = new MyThread();        t1.start();  // 启动线程，run() 方法会被自动调用    &#125;&#125;   方法2：实现 Runnable 接口 123456public class MyRunnable...</div></div></div></a><a class="pagination-related" href="/2025/06/13/WebSocket%E4%BD%BF%E7%94%A8/" title="WebSocket使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-13</div><div class="info-item-2">WebSocket使用</div></div><div class="info-2"><div class="info-item-1">WebSocket WebSocket 是一种基于 TCP 协议的全双工通信协议，它允许客户端和服务器之间建立持久的、双向的通信连接。相比传统的 HTTP 请求 - 响应模式，WebSocket 提供了实时、低延迟的数据传输能力。通过 WebSocket，客户端和服务器可以随时发送数据，而不需要每次都重新建立连接。实现实时更新和即时通信的功能。 WebSocket 协议经过了多个浏览器和服务器的支持，成为了现代 Web 应用中常用的通信协议之一。它广泛应用于聊天应用、实时数据更新、多人游戏等场景，为 Web 应用提供了更好的用户体验和更高效的数据传输方式。    特点 描述     持久连接 建立一次连接后，客户端和服务器之间保持连接状态   全双工通信 客户端和服务器都可以主动发送消息   低延迟、实时性强 适合聊天、游戏、股票、实时推送等应用   节省资源 与传统 HTTP 请求相比，减少了请求头等开销   基于 TCP 协议 和 HTTP 一样基于 TCP，但是一个独立协议    Spring...</div></div></div></a><a class="pagination-related" href="/2025/06/13/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="跨域问题及解决方案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-13</div><div class="info-item-2">跨域问题及解决方案</div></div><div class="info-2"><div class="info-item-1">跨域请求问题 跨域请求问题是**浏览器的同源策略（Same-Origin Policy, SOP）**所导致的一种前端限制。 同源 所谓“同源”，是指两个页面的协议（protocol）、域名（host）和端口（port）必须完全相同。 例如：    URL 是否同源 说明     http://example.com/page1 是 与自己比   http://example.com:8080/page1 否 端口不同   https://example.com/page1 否 协议不同   http://api.example.com/page1 否 子域不同    跨域 当浏览器的网页尝试向不同源的服务器发送请求时，就发生了跨域请求，如：  当前网页在 http://localhost:8080 JS 发起 AJAX 请求到 http://api.example.com，此时就是跨域请求  常见跨域行为包括：  Ajax 请求接口 加载第三方脚本、样式、图片（部分不受限制） 使用 fetch 获取不同域资源 WebSocket（需特殊处理）  Spring Boot...</div></div></div></a><a class="pagination-related" href="/2025/07/04/Java%20SE%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Java SE复习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-04</div><div class="info-item-2">Java SE复习笔记</div></div><div class="info-2"><div class="info-item-1"> 第一次找实习wwwwwwww好紧张希望能顺利。  Java SE复习笔记 JVM Java虚拟机（Java Virtual Machine，简称JVM）是运行所有Java程序的抽象计算机，是Java语言的运行环境。 Java语言的一个非常重要的特点就是与平台的无关性（一次编译、处处运行）。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。 JVM中提供的JIT（即时编译方式）将字节码直接转化成高性能的本地机器码，即JIT使得Java程序既能跨平台又能高速运行。 Java集合  ArrayList Java ArrayList 常用方法列表如下：    方法 描述     add() 将元素插入到指定位置的...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">bush Wu</div><div class="author-info-description">北京航空航天大学21系软件工程专业22级本科生。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/bush-cn"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/bush-cn" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:bush_wu@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A-1%EF%BC%9A%E7%AE%80%E7%AD%94%E9%A2%98"><span class="toc-text">作业 1：简答题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Spring-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%9D%97%E7%BB%84%E6%88%90%EF%BC%9F%E5%88%97%E4%B8%BE-Spring-%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">1. Spring 的核心容器有哪些模块组成？列举 Spring 框架的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9C%A8-Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9F%E4%BD%BF%E7%94%A8%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-text">2. 在 Spring 框架中，什么是控制反转？什么是依赖注入？使用控制反转与依赖注入有什么优点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9C%A8-Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">3. 在 Spring 框架中，有哪些不同类型的依赖注入实现方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9C%A8Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%EF%BC%8CBeanFactory%E4%B8%8EAppliacationContext%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9FApplicationContext%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">4. 在Spring 框架中，BeanFactory与AppliacationContext有什么区别？ApplicationContext的实现类有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Spring-%E6%94%AF%E6%8C%81-bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-text">5. Spring 支持 bean 的作用域有几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Spring-%E6%9C%89%E5%87%A0%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88%E5%9F%BA%E4%BA%8E-xml%E3%80%81%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E3%80%81%E5%9F%BA%E4%BA%8E-Java-%E9%85%8D%E7%BD%AE%EF%BC%89%E9%92%88%E5%AF%B9%E4%B8%8A%E8%BF%B0%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AF%B7%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E3%80%82"><span class="toc-text">6. Spring 有几种配置方式？（基于 xml、基于注解、基于 Java 配置）针对上述配置，请举例说明。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E4%BA%8E-Java-%E7%9A%84-Spring-%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE-%E8%AF%B7%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9F"><span class="toc-text">7. 什么是基于 Java 的 Spring 注解配置? 请举例说明？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%A8%E8%A7%A3%EF%BC%9FSpring-%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%80%8E%E6%A0%B7%E5%BC%80%E5%90%AF%E6%B3%A8%E8%A7%A3%E8%A3%85%E9%85%8D%EF%BC%9F"><span class="toc-text">8. 什么是注解？Spring 的常用注解有哪些？怎样开启注解装配？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Component-Controller-Repository-Service-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">9. @Component, @Controller, @Repository, @Service 有何区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Autowired-%E5%92%8C-Resource-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C-Qualifier-%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">10. @Autowired 和@Resource 之间的区别，@Qualifier 注解有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Spring-%E6%94%AF%E6%8C%81%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%E4%BD%A0%E6%9B%B4%E5%80%BE%E5%90%91%E7%94%A8%E9%82%A3%E7%A7%8D%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B1%BB%E5%9E%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">11. Spring 支持两种类型的事务管理，分别是什么？如何实现的？你更倾向用那种事务管理类型？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Spring-%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-text">12. Spring 框架的事务管理有哪些优点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BB%80%E4%B9%88%E6%98%AF-AOP%EF%BC%8CAOP-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%85%B3%E9%94%AE%E6%9C%AF%E8%AF%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%87%E9%9D%A2%EF%BC%88Aspect%EF%BC%89%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%9A%E7%9F%A5%EF%BC%88Advice%EF%BC%89%EF%BC%9FSpring-%E9%80%9A%E7%9F%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">13. 什么是 AOP，AOP 中有哪些关键术语，什么是切面（Aspect），什么是通知（Advice）？Spring 通知有哪些类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Spring-AOP-and-AspectJ-AOP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9FAOP-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">14. Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%BB%80%E4%B9%88%E6%98%AF-Spring-MVC-%EF%BC%9F%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8B%E4%BD%A0%E5%AF%B9-springMVC-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">15. 什么是 Spring MVC ？简单介绍下你对 springMVC 的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-SpringMVC-%E4%B8%BB%E8%A6%81%E6%9C%89%E5%87%A0%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90%EF%BC%8C%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0-SpringMVC-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">16. SpringMVC 主要有几部分组成，简单描述 SpringMVC 的工作流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%88%B0%E7%9B%AE%E5%89%8D%E4%B8%BA%E6%AD%A2%EF%BC%8C%E4%BD%A0%E5%85%B1%E5%AD%A6%E4%B9%A0%E4%BA%86%E5%93%AA%E4%BA%9B%E6%B3%A8%E8%A7%A3%EF%BC%9F%E8%AF%B7%E6%80%BB%E7%BB%93%E5%88%97%E4%B8%BE%EF%BC%8C%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD"><span class="toc-text">17. 到目前为止，你共学习了哪些注解？请总结列举，越多越好</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81Spring-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3"><span class="toc-text">一、Spring 核心注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Spring-Boot-%E6%B3%A8%E8%A7%A3"><span class="toc-text">二、Spring Boot 注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81Spring-AOP-%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="toc-text">三、Spring AOP &#x2F; 事务相关注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Spring-Security-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-text">四、Spring Security 常用注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%81JPA-Hibernate-%E6%B3%A8%E8%A7%A3%EF%BC%88ORM-%E6%98%A0%E5%B0%84%EF%BC%89"><span class="toc-text">五、JPA &#x2F; Hibernate 注解（ORM 映射）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AD%E3%80%81MyBatis-%E6%B3%A8%E8%A7%A3"><span class="toc-text">六、MyBatis 注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%AA%8C%E8%AF%81%E6%B3%A8%E8%A7%A3%EF%BC%88JSR-303-Hibernate-Validator%EF%BC%89"><span class="toc-text">七、验证注解（JSR 303 &#x2F; Hibernate Validator）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-text">八、其他常用注解</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/11/Java%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91%E7%AE%80%E7%AD%94%E9%A2%982%EF%BC%88MyBatis%EF%BC%89/" title="Java企业级开发简答题2（MyBatis）">Java企业级开发简答题2（MyBatis）</a><time datetime="2025-07-11T07:11:42.000Z" title="发表于 2025-07-11 15:11:42">2025-07-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/11/Java%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91%E7%AE%80%E7%AD%94%E9%A2%981%EF%BC%88Spring%EF%BC%89/" title="Java企业级开发简答题1（Spring）">Java企业级开发简答题1（Spring）</a><time datetime="2025-07-11T07:11:11.000Z" title="发表于 2025-07-11 15:11:11">2025-07-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E5%9B%9E%E9%A1%BE/" title="算法导论笔记整理回顾">算法导论笔记整理回顾</a><time datetime="2025-07-10T14:25:51.000Z" title="发表于 2025-07-10 22:25:51">2025-07-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="数据库复习笔记">数据库复习笔记</a><time datetime="2025-07-10T09:07:26.000Z" title="发表于 2025-07-10 17:07:26">2025-07-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/04/Java%20SE%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Java SE复习笔记">Java SE复习笔记</a><time datetime="2025-07-04T08:54:32.000Z" title="发表于 2025-07-04 16:54:32">2025-07-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By bush Wu</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>