<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>算法导论笔记整理回顾 | bush's Blog</title><meta name="author" content="bush Wu"><meta name="copyright" content="bush Wu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="这是笔者大二上学的课了，现在把之前的笔记整理复习一遍。 部分内容由AI生成。。。  第2章 算法基础2.1 插入排序c++代码： 12345678INSERTION-SORT(A)for j &#x3D; 2 to A.length	key &#x3D; A[j]	i &#x3D; j - 1	while i &gt; 0 and A[i] &gt; key		A[i+1] &#x3D;A[i];		i &#x3D; i - 1;	A[i +">
<meta property="og:type" content="article">
<meta property="og:title" content="算法导论笔记整理回顾">
<meta property="og:url" content="http://bush-cn.github.io/2025/07/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E5%9B%9E%E9%A1%BE/index.html">
<meta property="og:site_name" content="bush&#39;s Blog">
<meta property="og:description" content="这是笔者大二上学的课了，现在把之前的笔记整理复习一遍。 部分内容由AI生成。。。  第2章 算法基础2.1 插入排序c++代码： 12345678INSERTION-SORT(A)for j &#x3D; 2 to A.length	key &#x3D; A[j]	i &#x3D; j - 1	while i &gt; 0 and A[i] &gt; key		A[i+1] &#x3D;A[i];		i &#x3D; i - 1;	A[i +">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://bush-cn.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-07-10T14:25:51.000Z">
<meta property="article:modified_time" content="2025-07-10T14:44:16.957Z">
<meta property="article:author" content="bush Wu">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://bush-cn.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://bush-cn.github.io/2025/07/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E5%9B%9E%E9%A1%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: bush Wu","link":"链接: ","source":"来源: bush's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'medium_zoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法导论笔记整理回顾',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(to left, rgb(76, 161, 175), rgb(196, 224, 229));"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/favicon.png" alt="Logo"><span class="site-name">bush's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">算法导论笔记整理回顾</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">算法导论笔记整理回顾</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-10T14:25:51.000Z" title="发表于 2025-07-10 22:25:51">2025-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-10T14:44:16.957Z" title="更新于 2025-07-10 22:44:16">2025-07-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>这是笔者大二上学的课了，现在把之前的笔记整理复习一遍。</p>
<p>部分内容由AI生成。。。</p>
</blockquote>
<h1 id="第2章-算法基础"><a href="#第2章-算法基础" class="headerlink" title="第2章 算法基础"></a>第2章 算法基础</h1><h2 id="2-1-插入排序"><a href="#2-1-插入排序" class="headerlink" title="2.1 插入排序"></a>2.1 插入排序</h2><p>c++代码：</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSERTION-SORT(A)</span><br><span class="line"><span class="keyword">for</span> j = <span class="number">2</span> <span class="keyword">to</span> A.length</span><br><span class="line">	key = A[j]</span><br><span class="line">	i = j - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key</span><br><span class="line">		A[i+<span class="number">1</span>] =A[i];</span><br><span class="line">		i = i - <span class="number">1</span>;</span><br><span class="line">	A[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**插入排序</span></span><br><span class="line"><span class="comment">@para array and array&#x27;s length</span></span><br><span class="line"><span class="comment">下标从0开始</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="type">int</span>&amp; A, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">		<span class="type">int</span> key = A[j];</span><br><span class="line">		i = j - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; A[i] &gt; key)&#123;</span><br><span class="line">			A[i + <span class="number">1</span>] = A[i];</span><br><span class="line">			i = i - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	 A[i + <span class="number">1</span>] = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-分析算法"><a href="#2-2-分析算法" class="headerlink" title="2.2 分析算法"></a>2.2 分析算法</h2><h2 id="2-3-设计算法"><a href="#2-3-设计算法" class="headerlink" title="2.3 设计算法"></a>2.3 设计算法</h2><h3 id="分治法："><a href="#分治法：" class="headerlink" title="分治法："></a>分治法：</h3><ol>
<li>**分解：**原问题为若干子问题，这些子问题是原问题的规模较小的实例</li>
<li>**解决：**解决这些子问题，递归地求解各子问题</li>
<li>**合并：**合并这些子问题的解成原问题的解</li>
</ol>
<h3 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h3><p>归并排序是一种采用分治法思想的排序算法。它的基本思想是将待排序的序列不断划分为更小的子序列，直到每个子序列只有一个元素，然后再将这些子序列两两合并，最终得到一个有序的序列。</p>
<p>下面是归并排序的C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = q - p + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n2 = r - q;</span><br><span class="line">		<span class="comment">//分割成A[p,q],A[q+1,r]</span></span><br><span class="line">    <span class="type">int</span>* L = <span class="keyword">new</span> <span class="type">int</span>[n1];</span><br><span class="line">    <span class="type">int</span>* R = <span class="keyword">new</span> <span class="type">int</span>[n2];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">        L[i] = arr[p + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n2; j++)</span><br><span class="line">        R[j] = arr[q + <span class="number">1</span> + j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;</span><br><span class="line">            arr[k] = L[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = R[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k] = L[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k] = R[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] L;</span><br><span class="line">    <span class="keyword">delete</span>[] R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> p, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> q = (p + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, p, q);</span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, q + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">merge</span>(arr, p, q, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用归并排序算法可以对数组进行排序。</p>
<h3 id="递归算法的时间复杂度分析"><a href="#递归算法的时间复杂度分析" class="headerlink" title="递归算法的时间复杂度分析"></a>递归算法的时间复杂度分析</h3><p>对于递归算法的时间复杂度分析，可以使用递归树来进行推导。递归树的每一层表示递归算法的一次调用，而每一层中的节点表示该层中执行的基本操作次数。</p>
<p>以归并排序算法为例，设原始序列的长度为n。在每次递归调用中，将序列划分为两个子序列，直到每个子序列只有一个元素为止。因此，递归树的高度为log(n)。</p>
<p>在每一层的合并操作中，需要将两个子序列合并为一个有序的序列。合并操作的时间复杂度为O(n)，其中n表示当前层的序列长度。</p>
<p>因此，递归算法的总时间复杂度可以表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(n) = 2T(n/2) + O(n)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据主定理，可以得到归并排序的时间复杂度为O(nlog(n))。</p>
<p>总结：递归算法的时间复杂度分析需要考虑递归树的高度和每层的操作次数，通过递归关系式和主定理来计算总的时间复杂度。</p>
<h1 id="第3章-函数的增长"><a href="#第3章-函数的增长" class="headerlink" title="第3章 函数的增长"></a>第3章 函数的增长</h1><h2 id="3-1-渐进记号"><a href="#3-1-渐进记号" class="headerlink" title="3.1 渐进记号"></a>3.1 渐进记号</h2><h3 id="算法的渐进记号及含义"><a href="#算法的渐进记号及含义" class="headerlink" title="算法的渐进记号及含义"></a>算法的渐进记号及含义</h3><p>在计算机科学中，我们使用渐进记号来描述算法的时间复杂度和空间复杂度。以下是常见的渐进记号及其含义：</p>
<ul>
<li>大O记号（O）：表示算法的上界，即算法的最坏情况时间复杂度。例如，O(n)表示线性时间复杂度，O(n^2)表示平方时间复杂度。</li>
<li>Ω记号（Ω）：表示算法的下界，即算法的最好情况时间复杂度。例如，Ω(n)表示线性时间复杂度，Ω(1)表示常数时间复杂度。</li>
<li>Θ记号（Θ）：表示算法的紧密界限，即算法的平均情况时间复杂度。例如，Θ(n)表示线性时间复杂度，Θ(1)表示常数时间复杂度。</li>
<li>小o记号（o）：表示算法的非紧密界限，即算法的最好情况时间复杂度没有上界。例如，o(n)表示比线性时间复杂度更好的复杂度。</li>
<li>小ω记号（ω）：表示算法的非紧密界限，即算法的最坏情况时间复杂度没有下界。例如，ω(n)表示比线性时间复杂度更差的复杂度。</li>
</ul>
<p>这些渐进记号帮助我们比较和分析不同算法的性能，以便选择最适合特定问题的算法。</p>
<h1 id="第4章-分治策略"><a href="#第4章-分治策略" class="headerlink" title="第4章 分治策略"></a>第4章 分治策略</h1><p>在算法中，求解递归式（recurrence relation）的方法有几种常见的技巧。这些方法对于分析算法的时间复杂度非常有帮助。以下是一些常见的求解递归式的方法：</p>
<ol>
<li><strong>代入法（Substitution Method）：</strong> 这是一种直观的方法，其中你猜测解的形式，然后用数学归纳法证明你的猜测是正确的。</li>
<li><strong>递归树法（Recurrence Tree Method）：</strong> 将递归式表示为一棵树，然后分析这棵树的深度和每个层次的代价。这对于理解递归调用的次数以及每次调用的代价很有帮助。</li>
<li><strong>主方法（Master Theorem）：</strong> 主方法是一种特定形式递归式的通用解法，适用于具有特定形式的分治算法。主方法有三种情况，每种情况对应于不同类型的递归式。</li>
</ol>
<p>这些方法通常在分析递归算法的时间复杂度时使用。选择哪种方法取决于递归式的形式以及你希望分析的粒度。在学习算法和数据结构时，这些方法通常会在课程中进行详细讲解。</p>
<p>主方法（Master Theorem）是一种用于分析递归算法时间复杂度的技术，特别适用于分治算法。主方法提供了一种简化的方式来确定递归算法的时间复杂度，尤其是对于具有特定形式的递归式。主方法通常用于解决以下形式的递归关系：</p>
<p> $T(n) &#x3D; a \cdot T\left(\frac{n}{b}\right) + f(n)$ </p>
<p>其中：</p>
<ul>
<li>$T(n)$ 是递归函数的时间复杂度。</li>
<li>$a$ 是递归调用的次数。</li>
<li>$b$ 是问题规模缩小的比例。</li>
<li>$f(n)$ 是递归之外的其他操作的时间复杂度。</li>
</ul>
<p>主方法的一般形式为：</p>
<p> $T(n) &#x3D; \begin{cases} \Theta (1) &amp; ,n&#x3D;1\a \cdot T\left(\frac{n}{b}\right) + f(n)&amp;,n&#x3D;b^i\end{cases}$ </p>
<p>其中 $a \geq 1，b &gt; 1 ，f(n)$ 是渐进正函数。</p>
<p>主方法定理提供了对这类递归式的通用解决方案，其中包含了三种情况。这些情况涵盖了许多常见的递归算法。具体的情况取决于 a，b，和 f(n) 的关系。</p>
<p>主方法的三种情况如下：</p>
<ol>
<li><p><strong>情况一：</strong> 如果 $f(n)$ 是 $O(n^{\log_b{a - \epsilon}})$（其中 $\epsilon &gt; 0$），那么 $T(n)$ 是 $Θ(n^{\log_b{a}})$。</p>
</li>
<li><p><strong>情况二：</strong> 如果 $f(n)$ 是 $Θ(n^{\log_b{a}} \cdot \log^k n)$（其中 $k \geq 0$），那么 $T(n)$ 是 $Θ(n^{\log_b{a}} \cdot \log^{k+1} n)$。</p>
<aside>
💡 特别地，如果$f(n)=\Theta(n^{\log_ba})$，则$T(n)=\Theta(n^{\log_ba}\cdot \log n)$。


</aside>
</li>
<li><p><strong>情况三：</strong> 如果 $f(n)$ 是 $Ω(n^{\log_b{a + \epsilon}})$（其中 $\epsilon &gt; 0$），如果 $a f\left(\frac{n}{b}\right) \leq kf(n)$（其中 $k &lt; 1$）对于足够大的 $n$ 成立，那么 $T(n)$ 是 $Θ(f(n))$。</p>
</li>
</ol>
<p>在应用主方法时，首先需要将递归式 $T(n)$ 表达为上述形式，然后根据 $f(n)$ 的增长速度与 $n^{\log_b{a}}$ 进行比较，确定适用于哪一种情况。这样可以更方便地推导递归算法的渐进时间复杂度。</p>
<hr>
<p>P55 练习4.5-1</p>
<ol>
<li>$T(n)&#x3D;2T(n&#x2F;4)+1$，a&#x3D;2，b&#x3D;4，$log_ba$$&#x3D;\frac 12$，$f(n)&#x3D;n^0$$&#x3D;O(n^{log_ba}-\epsilon)$，因此$T(n)&#x3D;\Theta(\sqrt n)$。、</li>
<li>同理，$T(n)&#x3D;\Theta(\sqrt n\log n)$</li>
<li>$T(n)&#x3D;\Theta(n)$</li>
<li>$T(n)&#x3D;\Theta(n^2)$</li>
</ol>
<hr>
<h1 id="第6章-堆排序"><a href="#第6章-堆排序" class="headerlink" title="第6章 堆排序"></a>第6章 堆排序</h1><h2 id="堆、堆排序算法"><a href="#堆、堆排序算法" class="headerlink" title="堆、堆排序算法"></a>堆、堆排序算法</h2><p>堆（Heap）是一种数据结构，通常用于实现优先队列。堆分为最大堆和最小堆，最大堆的每个节点的值都大于或等于其子节点，而最小堆的每个节点的值都小于或等于其子节点。</p>
<p>堆排序算法是一种基于堆数据结构的排序方法。它的基本思想是首先将待排序的元素构建成一个最大堆或最小堆，然后依次将堆顶元素（最大值或最小值）取出并调整堆，直到所有元素都被取出，从而得到一个有序序列。</p>
<p>堆排序的步骤如下：</p>
<ol>
<li>构建堆：将待排序的元素按顺序插入到堆中，然后依次调整堆，使得每个节点都满足堆的性质。</li>
<li>堆顶元素与末尾元素交换：将堆顶元素与堆的最后一个元素交换位置。</li>
<li>调整堆：将交换后的堆顶元素重新调整为堆，保持堆的性质。</li>
<li>重复步骤2和步骤3，直到堆为空。</li>
</ol>
<p>堆排序的时间复杂度为$O(n log n)$，其中n是待排序元素的个数。它是一种原地排序算法，不需要额外的空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整堆的函数，确保以i为根的子树是一个最大堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;    <span class="comment">// 初始化最大元素的索引为当前节点</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;   <span class="comment">// 左子节点的索引</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;  <span class="comment">// 右子节点的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较左子节点与当前节点的值，找出较大值的索引</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])</span><br><span class="line">        largest = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较右子节点与当前节点的值，找出较大值的索引</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">        largest = right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大值的索引不是当前节点，交换它们，并递归调整交换后的子树</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">		<span class="comment">// 最后一个节点的下标为n-1，则父节点的下标为n/2-1：</span></span><br><span class="line">		<span class="comment">// 若为左节点，n-1为奇，n为偶，（n-1-1）/2=n/2-1</span></span><br><span class="line">		<span class="comment">// 若为右节点，n-1为偶，n为奇，（n-1-2）/2=（n-1）/2-1=[n/2]-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换堆顶元素与末尾元素，然后调整堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用堆排序函数</span></span><br><span class="line">    <span class="built_in">heapSort</span>(arr);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后的数组：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是一种常用的排序算法，它基于分治的思想。其主要步骤包括选择一个基准元素，将数组分成两部分，小于基准的元素放在左边，大于基准的元素放在右边，然后对左右两部分分别递归进行快速排序。</p>
<p>以下是快速排序的基本原理：</p>
<ol>
<li><strong>选择基准元素：</strong> 从数组中选择一个元素作为基准，通常选择最后一个元素。</li>
<li><strong>分区：</strong> 将数组重新排列，使得小于基准的元素在基准的左边，大于基准的元素在基准的右边。基准元素最终在其最终排序的位置上。</li>
<li><strong>递归：</strong> 对基准元素左右两边的子数组分别递归应用快速排序。</li>
</ol>
<p>下面是一个简单的C++实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数，选取最后一个元素作为基准值，将小于基准值的元素放在左侧，大于基准值的元素放在右侧</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];  <span class="comment">// 选择最后一个元素作为基准值</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;  <span class="comment">// 初始化i为比基准值小的元素的最后一个索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组，将小于基准值的元素交换到左侧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt; high; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将基准值放到最终的位置上</span></span><br><span class="line">    <span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[high]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 找到基准值的位置</span></span><br><span class="line">        <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(arr, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归对基准值左右两侧的子数组进行快速排序</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pivotIndex + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用快速排序函数</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后的数组：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>partition</code> 函数用于对数组进行分区，确定基准值的位置。然后，<code>quickSort</code> 函数递归地对基准值左右两侧的子数组进行快速排序。整体的快速排序算法时间复杂度为$O(n log n)$。</p>
<hr>
<p>快速排序的平均时间复杂度是 O(n log n)。这使得它成为一种非常高效的排序算法。</p>
<p>以下是快速排序时间复杂度的详细分析：</p>
<ol>
<li><strong>最好情况：</strong><ul>
<li>在最好的情况下，每次选择的基准值都将数组准确地分成两个大小相等的子数组。这导致递归树是平衡的，每一层都有 O(n) 个元素。</li>
<li>在这种情况下，递归的深度是 O(log n)，因为每次都将数组一分为二。</li>
<li>最好情况下的时间复杂度是 O(n log n)。</li>
</ul>
</li>
<li><strong>最坏情况：</strong><ul>
<li>在最坏的情况下，每次选择的基准值都是数组中的最小或最大元素。这导致递归树是不平衡的，其中一个分支没有元素，而另一个分支有 n-1 个元素。</li>
<li>在这种情况下，递归的深度是 O(n)。</li>
<li>最坏情况下的时间复杂度是 O(n^2)。</li>
</ul>
</li>
<li><strong>平均情况：</strong><ul>
<li>平均情况下，快速排序的时间复杂度为 O(n log n)。</li>
<li>这是通过对所有可能的输入情况进行平均计算得出的结果。</li>
<li>在实际应用中，快速排序通常是最好的选择，因为它的平均性能非常好。</li>
</ul>
</li>
</ol>
<p>总体而言，快速排序在平均情况下的性能较好，但在最坏情况下可能变得不太理想。为了降低最坏情况的发生概率，通常可以采用随机化的方法来选择基准值，或者采用三数中值分割法等策略来选择更好的基准值。这些方法可以提高快速排序的稳定性。</p>
<h1 id="第7章-快速排序"><a href="#第7章-快速排序" class="headerlink" title="第7章 快速排序"></a>第7章 快速排序</h1><p>快速排序（Quick Sort）是一种常用的排序算法，它基于分治法（Divide and Conquer）的思想。分治法的基本思想是将问题分成一些小的子问题，递归地解决这些子问题，然后合并其结果以解决原始问题。</p>
<p>以下是快速排序的详细过程：</p>
<ol>
<li><strong>选择枢纽元素：</strong> 从数组中选择一个元素作为枢纽元素（pivot）。通常选择数组的最后一个元素，但也可以选择其他位置的元素。</li>
<li><strong>分割阶段：</strong> 将数组中的元素重新排列，使得小于枢纽元素的元素位于其左侧，而大于枢纽元素的元素位于其右侧。枢纽元素此时已经处于正确的位置，称为分割点（pivot point）。<ul>
<li>设置两个指针，一个指向当前处理的元素，一个指向数组的起始位置。开始时，两个指针重合。</li>
<li>从数组的起始位置遍历到倒数第二个元素，将小于枢纽元素的元素交换到左侧，同时移动指针。</li>
<li>最后，将枢纽元素交换到正确的位置，使得左侧的元素都小于它，右侧的元素都大于它。</li>
<li>分割点的位置确定后，数组被分成两个部分，分别对这两个部分递归地应用快速排序。</li>
</ul>
</li>
<li><strong>递归排序：</strong> 对分割点左右两侧的子数组分别进行递归排序。</li>
<li><strong>合并：</strong> 递归排序的最终结果就是整个数组有序。由于分治法的特性，各个子数组在排序完成后，整个数组也就自然有序了。</li>
</ol>
<p>下面是一个简单的例子，演示了快速排序的过程：</p>
<p>假设数组为 <code>[12, 7, 11, 8, 5, 3, 2, 10]</code>，选择最后一个元素 10 作为枢纽元素：</p>
<ol>
<li>初始数组：<code>[12, 7, 11, 8, 5, 3, 2, 10]</code></li>
<li>枢纽元素选择为 10，分割点位置：4</li>
<li>分割后的数组：<code>[7, 8, 5, 3, 2, 10, 12, 11]</code></li>
<li>递归排序左侧子数组 <code>[7, 8, 5, 3, 2]</code></li>
<li>递归排序右侧子数组 <code>[12, 11]</code></li>
<li>最终有序数组：<code>[2, 3, 5, 7, 8, 10, 11, 12]</code></li>
</ol>
<p>这就是快速排序的基本思想和实现过程。它的平均时间复杂度为 $O(n log n)$，其中 $n$ 是数组的长度。快速排序在实践中表现出色，被广泛应用于各种应用场景。</p>
<p>快速排序（Quick Sort）是一种常用的排序算法，属于分治法的一种。以下是一个简单的C++实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分割数组并返回分割点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];  <span class="comment">// 选择数组最后一个元素作为枢纽元素</span></span><br><span class="line">    <span class="type">int</span> i = (low - <span class="number">1</span>);      <span class="comment">// 设置分割点的初始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新排列数组，将小于枢纽元素的元素移到左侧，大于的移到右侧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt;= high - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将枢纽元素放到正确的位置</span></span><br><span class="line">    std::<span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[high]);</span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 获取分割点</span></span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对分割点左右两侧的子数组进行递归排序</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">12</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;原始数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\\n排序后的数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个程序演示了快速排序的基本原理，通过递归调用对数组进行排序。希望对你有帮助！如果有任何问题，欢迎提问。</p>
<h1 id="第15章-动态规划"><a href="#第15章-动态规划" class="headerlink" title="第15章 动态规划"></a>第15章 动态规划</h1><p>动态规划（Dynamic Programming，简称DP）是一种解决复杂问题的优化方法，它通常用于解决具有重叠子问题和最优子结构性质的问题。动态规划的核心思想是将问题分解成子问题，并通过存储子问题的解来避免重复计算，从而提高效率。</p>
<p>动态规划的一般步骤包括：</p>
<ol>
<li><strong>定义子问题：</strong> 将原问题分解成更小的子问题。</li>
<li><strong>找到状态转移方程：</strong> 定义问题的状态以及状态之间的关系，即如何通过已解决的子问题的解来计算原问题的解。</li>
<li><strong>解决基本问题：</strong> 找到最小子问题的解，通常是通过初始条件或边界条件来定义的。</li>
<li><strong>自底向上或自顶向下求解：</strong> 动态规划可以采用自底向上的迭代方法，也可以采用自顶向下的递归方法。</li>
</ol>
<p>动态规划常见的应用场景包括：</p>
<ul>
<li><strong>最优子结构：</strong> 问题的最优解可以通过子问题的最优解来构造。</li>
<li><strong>重叠子问题：</strong> 问题可以被分解成一些相同的子问题，这些子问题在求解过程中会被重复计算。</li>
<li><strong>状态转移方程：</strong> 问题的解可以通过状态之间的转移得到。</li>
</ul>
<p>一些经典的动态规划问题包括：</p>
<ol>
<li><strong>斐波那契数列：</strong> 寻找第n个斐波那契数。</li>
<li><strong>最长递增子序列：</strong> 找到给定数组中的最长递增子序列的长度。</li>
<li><strong>背包问题：</strong> 给定一组物品的重量和价值，确定如何选择这些物品以获得最大的总价值，在限定总重量的情况下。</li>
<li><strong>编辑距离：</strong> 计算两个字符串之间的最小编辑操作数，如插入、删除、替换，使得一个字符串变成另一个字符串。</li>
<li><strong>最短路径问题：</strong> 在图中找到从一个顶点到另一个顶点的最短路径。</li>
</ol>
<p>下面是一个简单的动态规划示例，计算斐波那契数列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">6</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Fibonacci(&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; <span class="built_in">fibonacci</span>(n) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>dp</code> 数组存储了计算过的子问题的解，通过迭代的方式自底向上计算斐波那契数列。</p>
<h2 id="经典动态规划问题"><a href="#经典动态规划问题" class="headerlink" title="经典动态规划问题"></a>经典动态规划问题</h2><ul>
<li><p>钢条切割问题</p>
<p>钢条切割问题是动态规划中经典的例子之一。问题的描述是给定一段长度为n的钢条和一个价格表，如何切割钢条使得销售收益最大。</p>
<p>下面是一个简化的问题描述：</p>
<ul>
<li>钢条长度为i的价格为p[i]。</li>
<li>如果要切割钢条，会有不同的价格。</li>
</ul>
<p>问题的目标是找到一种切割方式，使得销售收益最大。这是一个典型的动态规划问题。</p>
<p>下面是一个简单的C++代码，用于解决钢条切割问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cutRod</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; price, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">// 钢条为i时</span></span><br><span class="line">        <span class="type">int</span> maxVal = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123; <span class="comment">// 切割成j和i-j两段</span></span><br><span class="line">            maxVal = <span class="built_in">max</span>(maxVal, price[j] + dp[i - j]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = maxVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; price = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">30</span>&#125;;  <span class="comment">// 价格表，下标对应钢条长度</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">8</span>;  <span class="comment">// 钢条长度</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxRevenue = <span class="built_in">cutRod</span>(price, n);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Maximum revenue for a rod of length &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; maxRevenue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子中，<code>price</code>向量表示每个长度的钢条的价格，<code>cutRod</code>函数通过动态规划计算最大的销售收益。在主函数中，我们可以改变钢条长度和价格表，以测试不同情况下的最大收益。</p>
<p>请注意，这只是钢条切割问题的一种解法，具体问题和实际应用可能需要适当的调整。</p>
</li>
</ul>
<h1 id="第17章-摊还分析"><a href="#第17章-摊还分析" class="headerlink" title="第17章 摊还分析"></a>第17章 摊还分析</h1><h3 id="什么是摊还分析？"><a href="#什么是摊还分析？" class="headerlink" title="什么是摊还分析？"></a><strong>什么是摊还分析？</strong></h3><p>摊还分析其实就是评价某一个操作的代价，方法就是求某<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">数据结构</a>中一系列操作的平均时间。</p>
<p>摊还分析与概率无关，可以保证某一系列操作在最坏情况下的平均性能。</p>
<h2 id="1-聚合分析"><a href="#1-聚合分析" class="headerlink" title="1. 聚合分析"></a>1. 聚合分析</h2><p>一个n个操作的序列最坏情况下花费的总时间为$T(n)$。在最坏情况下，每个操作的平均代价，或<strong>摊还代价</strong>为$T(n)&#x2F;n$。</p>
<h2 id="2-核算法（accounting-method）"><a href="#2-核算法（accounting-method）" class="headerlink" title="2. 核算法（accounting method）"></a>2. 核算法（accounting method）</h2><h2 id="3-势能法"><a href="#3-势能法" class="headerlink" title="3. 势能法"></a>3. 势能法</h2><h1 id="第22章-基本的图算法"><a href="#第22章-基本的图算法" class="headerlink" title="第22章 基本的图算法"></a>第22章 基本的图算法</h1><h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><p>有两种主要的图表示方法：</p>
<ol>
<li><strong>邻接矩阵：</strong> 邻接矩阵是一个二维数组，用于表示图中节点之间的关系。如果图是有向的，邻接矩阵是一个方阵。对于无向图，邻接矩阵是对称的。矩阵的行和列代表图中的节点，矩阵中的值表示对应节点之间是否有边以及边的权重。</li>
<li><strong>邻接列表：</strong> 邻接列表是一种以列表的形式表示图的方法。对于每个节点，都有一个与之相邻的节点列表。这种表示方法更节省空间，特别是在稀疏图（边相对较少）的情况下。</li>
</ol>
<p>在实际编程中，选择哪种图表示方法取决于具体问题的要求和图的规模。如果图是稠密的（边相对较多），邻接矩阵可能更适合。而对于稀疏图，邻接列表可能更有效。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; vis;</span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt; adj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> adj[u][v]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vis[u]) <span class="keyword">return</span>;</span><br><span class="line">  vis[u] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; ++v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (adj[u][v]) &#123;</span><br><span class="line">      <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  vis.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">  adj.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    adj[u][v] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="广度优先搜索、深度优先搜索"><a href="#广度优先搜索、深度优先搜索" class="headerlink" title="广度优先搜索、深度优先搜索"></a>广度优先搜索、深度优先搜索</h2><p>广度优先搜索（Breadth-First Search，简称BFS）是一种图搜索算法，用于遍历或搜索图的结构。以下是一个简单的C++实现，假设图的表示是邻接列表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> vertices;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjacencyList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> v) : <span class="built_in">vertices</span>(v), <span class="built_in">adjacencyList</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        adjacencyList[v].<span class="built_in">push_back</span>(w);</span><br><span class="line">        adjacencyList[w].<span class="built_in">push_back</span>(v);  <span class="comment">// undirected graph</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> startVertex)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(vertices, <span class="literal">false</span>)</span></span>;  <span class="comment">// Mark all vertices as not visited</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">        visited[startVertex] = <span class="literal">true</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(startVertex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> currentVertex = q.<span class="built_in">front</span>();</span><br><span class="line">            cout &lt;&lt; currentVertex &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjacencyList[currentVertex]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                    visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> startVertex)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(vertices, <span class="literal">false</span>)</span></span>;  <span class="comment">// Mark all vertices as not visited</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        visited[startVertex] = <span class="literal">true</span>;</span><br><span class="line">        s.<span class="built_in">push</span>(startVertex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> currentVertex = s.<span class="built_in">top</span>();</span><br><span class="line">            cout &lt;&lt; currentVertex &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjacencyList[currentVertex]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                    visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                    s.<span class="built_in">push</span>(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Example usage</span></span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BFS starting from vertex 0: &quot;</span>;</span><br><span class="line">    g.<span class="built_in">BFS</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;DFS starting from vertex 0: &quot;</span>;</span><br><span class="line">    g.<span class="built_in">DFS</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Graph</code> 类表示图，<code>addEdge</code> 方法用于添加边，而<code>BFS</code> 方法实现了广度优先搜索。你可以根据实际情况修改图的表示和算法的实现。这个示例是基于邻接列表的图表示。如果你使用邻接矩阵或其他表示方法，相应的数据结构和算法可能会有所不同。</p>
<aside>
💡 **重点：DFS（接下来的拓扑排序要用到）**


</aside>

<h3 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a><strong>算法特点</strong></h3><ul>
<li>深度优先搜索是一个递归的过程。<ul>
<li>首先，选定一个出发点后进行遍历，如果有邻接的未被访问过的节点则继续前进。</li>
<li>若不能继续前进，则回退一步再前进</li>
<li>若回退一步仍然不能前进，则连续回退至可以前进的位置为止。</li>
<li>重复此过程，直到所有与选定点相通的所有顶点都被遍历。</li>
</ul>
</li>
<li>深度优先搜索是递归过程，带有回退操作，因此需要使用栈存储访问的路径信息。当访问到的当前顶点没有可以前进的邻接顶点时，需要进行出栈操作，将当前位置回退至出栈元素位置。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表的深度有限递归算法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Boolean; <span class="comment">// 这里我们定义Boolean为布尔类型，其值为TRUE或FALSE</span></span><br><span class="line">Boolean visited[MAX]; <span class="comment">// 访问标志的数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphAdjList GL, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">  EdgeNode *p;</span><br><span class="line">  </span><br><span class="line">  visited[i] = TRUE;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span> GL-&gt;adjList[i].data);</span><br><span class="line">  p = GL-&gt;adjList[i].firstEdge;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(p)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>( !visited[p-&gt;adjvex] )</span><br><span class="line">    &#123;</span><br><span class="line">      DFS(GL, p-&gt;adjvex);</span><br><span class="line">    &#125;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表的深度遍历操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(GraphAdjList GL)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; GL-&gt;numVertexes; i++ )</span><br><span class="line">  &#123;</span><br><span class="line">    visited[i] = FALSE; <span class="comment">// 初始化所有顶点状态都是未访问过状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; GL-&gt;numVertexes; i++ )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>( !visited[i] ) <span class="comment">// 若是连通图，只会执行一次</span></span><br><span class="line">    &#123;</span><br><span class="line">      DFS(GL, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/10/20250710223149.png" alt="Untitled"></p>
<p>实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="type">int</span> in[MAXN];  <span class="comment">// 存储每个结点的入度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (in[i] == <span class="number">0</span>) S.<span class="built_in">push</span>(i);</span><br><span class="line">  <span class="keyword">while</span> (!S.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = S.<span class="built_in">front</span>();</span><br><span class="line">    S.<span class="built_in">pop</span>();</span><br><span class="line">    L.<span class="built_in">push_back</span>(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (--in[v] == <span class="number">0</span>) &#123;</span><br><span class="line">        S.<span class="built_in">push</span>(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (L.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : L) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DFS实现拓扑排序"><a href="#DFS实现拓扑排序" class="headerlink" title="DFS实现拓扑排序"></a>DFS实现拓扑排序</h2><p><a target="_blank" rel="noopener" href="http://t.csdnimg.cn/8NATr">基本图算法(二) 拓扑排序_拓扑排序算法-CSDN博客</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 边的结构体，表示图中的边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EdgeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> adjVertex;       <span class="comment">// 相邻顶点的索引</span></span><br><span class="line">    <span class="comment">// 其他边的信息，例如权重等，根据实际情况添加</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    EdgeNode* next;      <span class="comment">// 指向下一条边的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点的结构体，表示图中的顶点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexNode</span> &#123;</span><br><span class="line">    <span class="comment">// 顶点的其他信息，例如顶点值等，根据实际情况添加</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    EdgeNode* firstEdge;  <span class="comment">// 指向第一条与该顶点相邻的边的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的结构体，使用邻接表表示</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ALGraph</span> &#123;</span><br><span class="line">    std::vector&lt;VertexNode&gt; vertices;  <span class="comment">// 顶点数组，每个元素表示一个顶点</span></span><br><span class="line">    <span class="comment">// 其他图的信息，例如顶点数、边数等，根据实际情况添加</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>访问时三个状态：</p>
<blockquote>
<p>⋅「未搜索」：我们还没有搜索到这个节点，用0表示，标记为白色；</p>
<p>⋅「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成，用1表示，标记为灰色；</p>
<p>⋅「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求，用2表示，标记为绿色。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断有向图中是否有环</span></span><br><span class="line"><span class="type">bool</span> valid;</span><br><span class="line"><span class="comment">// 栈</span></span><br><span class="line"><span class="type">int</span>* stack;</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ALGraph G, <span class="type">int</span>* visited, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 设置当前节点状态为访问中(1)</span></span><br><span class="line">	visited[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 访问节点u的所有临节点v</span></span><br><span class="line">	EdgeNode* e = G.vertices[u].firstEdge;</span><br><span class="line">	<span class="keyword">while</span> (e) &#123;</span><br><span class="line">		<span class="type">int</span> v = e-&gt;adjvex;</span><br><span class="line">		<span class="keyword">if</span> (!visited[v]) </span><br><span class="line">			<span class="built_in">dfs</span>(G, visited, v);</span><br><span class="line">		<span class="comment">// 如果节点v的状态为搜索中(1),则有向图有环</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">			valid = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		e = e-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置当前节点状态为已访问(2)并入栈</span></span><br><span class="line">	visited[u] = <span class="number">2</span>;</span><br><span class="line">	stack[top++] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TopologicalSort</span><span class="params">(ALGraph G)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 设置每个顶点的状态为未搜索(0)</span></span><br><span class="line">	<span class="type">int</span>* visited = <span class="built_in">calloc</span>(G.vertexNum, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	stack = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * G.vertexNum);</span><br><span class="line">	valid = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexNum; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!valid)   <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">			<span class="built_in">dfs</span>(G, visited, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!valid)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;There are loops in Graph\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (top) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, stack[--top]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第23章-最小生成树"><a href="#第23章-最小生成树" class="headerlink" title="第23章 最小生成树"></a>第23章 最小生成树</h1><h2 id="一、最小生成树是什么？"><a href="#一、最小生成树是什么？" class="headerlink" title="一、最小生成树是什么？"></a>一、最小生成树是什么？</h2><p>最小生成树，全称是Minimum Spanning Tree，简称为MST，其具体定义如下：<br>  在一给定的无向图$G &#x3D; ( V , E )$中，$( u , v )$ 代表连接顶点 $u$ 与顶点$v$ 的边，而$w ( u , v )$ 代表此边的权重。若存在$T$ 为$E$ 的子集且为无循环图，使得联通所有结点的的$w ( T )$ 最小，则此$T$ 为$G$ 的最小生成树。即：<br>$w(t)&#x3D;\underset{(u,v)\in t}{\sum}w(u,v)$</p>
<p>因此，最小生成树其实是最小权重生成树的简称。</p>
<h2 id="二、最小生成树的算法"><a href="#二、最小生成树的算法" class="headerlink" title="二、最小生成树的算法"></a><strong>二、最小生成树的算法</strong></h2><h3 id="1-Kurskal算法"><a href="#1-Kurskal算法" class="headerlink" title="1. Kurskal算法"></a>1. Kurskal算法</h3><p><em>俗称“加边法”，算法复杂度：$O(E\log V)$,其中E是边的数量，V是顶点数量，适合于边比较少的【稀疏图】。</em></p>
<p>Kruskal 算法提供一种在 $O(E\log V)$ 运行时间确定最小生成树的方案。Kruskal 算法基于贪心算法（Greedy Algorithm）的思想进行设计，其选择的贪心策略就是，每次都选择权重最小的但未形成环路的边加入到生成树中。实现利用【并查集】合并和检查是否形成环。其算法结构如下：</p>
<aside>
👉 1、将所有的边按照权重非递减排序；
2、选择最小权重的边，判断是否其在当前的生成树中形成了一个环路。
如果环路没有形成，则将该边加入树中，否则放弃。
3、重复步骤 2，直到有 V – 1 条边在生成树中。


</aside>

<p>Kruskal算法是一种用于求解最小生成树（Minimum Spanning Tree）的贪心算法。以下是一个简单的C++实现，假设图是以边的形式表示的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边的结构体，包含起点、终点和权重</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较函数，用于排序</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt; other.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集（Union-Find）的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> size) &#123;</span><br><span class="line">        parent.<span class="built_in">resize</span>(size);</span><br><span class="line">        rank.<span class="built_in">resize</span>(size, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找根节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个集合</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">            <span class="comment">// 将rank较小的树连接到rank较大的树上</span></span><br><span class="line">            <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">                parent[rootX] = rootY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">                parent[rootY] = rootX;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果rank相等，则选择一个作为根，并增加其rank</span></span><br><span class="line">                parent[rootX] = rootY;</span><br><span class="line">                rank[rootY]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rank;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kruskal算法实现</span></span><br><span class="line"><span class="function">vector&lt;Edge&gt; <span class="title">kruskal</span><span class="params">(vector&lt;Edge&gt;&amp; edges, <span class="type">int</span> numVertices)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将边按权重升序排序</span></span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="function">UnionFind <span class="title">uf</span><span class="params">(numVertices)</span></span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;Edge&gt; result; <span class="comment">// 存储最小生成树的边</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : edges) &#123;</span><br><span class="line">        <span class="comment">// 如果加入这条边不会形成环，则加入最小生成树</span></span><br><span class="line">        <span class="keyword">if</span> (uf.<span class="built_in">find</span>(edge.start) != uf.<span class="built_in">find</span>(edge.end)) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(edge);</span><br><span class="line">            uf.<span class="built_in">unite</span>(edge.start, edge.end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用类：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> src, dest, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareEdges</span><span class="params">(<span class="type">const</span> Edge&amp; a, <span class="type">const</span> Edge&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.weight &lt; b.weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findParent</span><span class="params">(<span class="type">int</span> u, vector&lt;<span class="type">int</span>&gt;&amp; parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (parent[u] == u) ? u : (parent[u] = <span class="built_in">findParent</span>(parent[u], parent));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, vector&lt;<span class="type">int</span>&gt;&amp; parent, vector&lt;<span class="type">int</span>&gt;&amp; rank)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rootU = <span class="built_in">findParent</span>(u, parent);</span><br><span class="line">    <span class="type">int</span> rootV = <span class="built_in">findParent</span>(v, parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank[rootU] &gt; rank[rootV]) &#123;</span><br><span class="line">        parent[rootV] = rootU;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootU] &lt; rank[rootV]) &#123;</span><br><span class="line">        parent[rootU] = rootV;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[rootV] = rootU;</span><br><span class="line">        rank[rootU]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Edge&gt; <span class="title">kruskal</span><span class="params">(vector&lt;Edge&gt;&amp; edges, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;Edge&gt; result;</span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), compareEdges);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rank</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : edges) &#123;</span><br><span class="line">        <span class="type">int</span> rootSrc = <span class="built_in">findParent</span>(edge.src, parent);</span><br><span class="line">        <span class="type">int</span> rootDest = <span class="built_in">findParent</span>(edge.dest, parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootSrc != rootDest) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(edge);</span><br><span class="line">            <span class="built_in">merge</span>(rootSrc, rootDest, parent, rank);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 示例图的边集合，包括起点、终点和权重</span></span><br><span class="line">    vector&lt;Edge&gt; edges = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>&#125;</span><br><span class="line">        <span class="comment">// 可以根据需要添加更多的边</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图的顶点数</span></span><br><span class="line">    <span class="type">int</span> numVertices = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Kruskal算法求最小生成树</span></span><br><span class="line">    vector&lt;Edge&gt; minSpanningTree = <span class="built_in">kruskal</span>(edges, numVertices);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最小生成树的边</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Edges in the Minimum Spanning Tree:\\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : minSpanningTree) &#123;</span><br><span class="line">        cout &lt;&lt; edge.start &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; edge.end &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; edge.weight &lt;&lt; <span class="string">&quot;\\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个示例实现了一个简单的Kruskal算法，你可以根据需要修改边的集合和顶点数。在这个例子中，<code>Edge</code>结构体表示图的边，<code>UnionFind</code>类表示并查集，<code>kruskal</code>函数执行Kruskal算法，最后在<code>main</code>函数中输出最小生成树的边。</p>
<h3 id="2-Prim算法"><a href="#2-Prim算法" class="headerlink" title="2. Prim算法"></a>2. Prim算法</h3><p><em>俗称“加点法”，算法复杂度：$O(V^2)$ ,其中V是顶点数量，适合于边比较多，顶点较少的【稠密图】。</em></p>
<aside>
💡 从图$G={V,E}$中的某一顶点$U_0$出发，选择与它关联的具有最小权值的边$(U_0,v)$，将其顶点加入到生成树的顶点集合$U$中。以后每一步从一个顶点在$U$中，而另一个顶点不在$U$中的各条边中选择权值最小的边($u,v)$,把它的顶点加入到集合U中。如此继续下去，直到网中的所有顶点都加入到生成树顶点集合U中为止。


</aside>

<p>Prim算法是一种用于求解最小生成树（Minimum Spanning Tree）的贪心算法，与Kruskal算法类似，但实现方式略有不同。Prim算法从一个初始顶点开始，逐步选择连接到当前生成树的最短边，直到生成树覆盖了图中所有的顶点。以下是Prim算法的详细解释和C++实现示例：</p>
<h3 id="Prim算法步骤："><a href="#Prim算法步骤：" class="headerlink" title="Prim算法步骤："></a>Prim算法步骤：</h3><ol>
<li><strong>选择一个起始顶点作为初始生成树</strong>。</li>
<li><strong>将选择的顶点标记为已访问</strong>。</li>
<li><strong>在与当前生成树相邻的所有未访问顶点中，选择权值最小的边</strong>。</li>
<li><strong>将选择的边加入生成树，将连接的顶点标记为已访问</strong>。</li>
<li><strong>重复步骤3和步骤4，直到生成树包含了图中的所有顶点</strong>。</li>
</ol>
<h3 id="Prim算法C-实现："><a href="#Prim算法C-实现：" class="headerlink" title="Prim算法C++实现："></a>Prim算法C++实现：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义边的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> dest, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用于最小堆的比较函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Edge&amp; a, <span class="type">const</span> Edge&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &gt; b.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prim算法实现</span></span><br><span class="line"><span class="function">vector&lt;Edge&gt; <span class="title">prim</span><span class="params">(vector&lt;vector&lt;Edge&gt;&gt;&amp; graph, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    vector&lt;Edge&gt; result;</span><br><span class="line">    priority_queue&lt;Edge, vector&lt;Edge&gt;, Compare&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将起始顶点标记为已访问</span></span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将起始顶点的所有边加入最小堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : graph[start]) &#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(edge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 从最小堆中取出权值最小的边</span></span><br><span class="line">        Edge current = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dest = current.dest;</span><br><span class="line">        <span class="type">int</span> weight = current.weight;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果目标顶点未访问，则将边加入生成树，并将目标顶点标记为已访问</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[dest]) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(&#123;dest, weight&#125;);</span><br><span class="line">            visited[dest] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将目标顶点的所有边加入最小堆</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : graph[dest]) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(edge);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>; <span class="comment">// 节点数</span></span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边信息（无向图）</span></span><br><span class="line">    graph[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    graph[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">6</span>&#125;);</span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">8</span>&#125;);</span><br><span class="line">    graph[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    graph[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    graph[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">6</span>&#125;);</span><br><span class="line">    graph[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">8</span>&#125;);</span><br><span class="line">    graph[<span class="number">4</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> startVertex = <span class="number">0</span>; <span class="comment">// 选择起始顶点</span></span><br><span class="line"></span><br><span class="line">    vector&lt;Edge&gt; result = <span class="built_in">prim</span>(graph, startVertex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最小生成树的边</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Edges in the Minimum Spanning Tree:\\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : result) &#123;</span><br><span class="line">        cout &lt;&lt; startVertex &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; edge.dest &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; edge.weight &lt;&lt; <span class="string">&quot;\\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是一个简单的Prim算法实现示例。请注意，Prim算法的实现可能因图的表示方式而异，上述代码使用邻接表来表示图。在实际应用中，你可能需要根据具体情况进行适当的修改。</p>
<h1 id="第24章-单源最短路径"><a href="#第24章-单源最短路径" class="headerlink" title="第24章 单源最短路径"></a>第24章 单源最短路径</h1><p>我们给定一个带权重的有向图$G(V,E)$ 和权重函数$w:E\to \bm{R}$ ，该权重函数将每条边映射到实数值的权重上。图中一条路径$p&#x3D;\langle v_0,v_1,\cdots,v_k\rangle$ 的权重$w(p)$是构成该路径的所有边的权重之和： </p>
<p>$w(p)&#x3D;\sum_{i&#x3D;1}^kw(v_{i-1},v_i)$</p>
<h2 id="松弛操作（relaxation）"><a href="#松弛操作（relaxation）" class="headerlink" title="松弛操作（relaxation）"></a>松弛操作（relaxation）</h2><p>维持一个属性$v.d$，用来记录从源节点$s$到节点$v$的最短路径的上界。</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZE-SINGLE-SOURCE(G,s)</span><br><span class="line"><span class="keyword">for</span> each vertex v \belong G.V</span><br><span class="line">	v.d = \infty </span><br><span class="line">	v.\pi = <span class="keyword">NIL</span></span><br><span class="line">s.d = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">RELAX(u,v,w)</span><br><span class="line"><span class="keyword">if</span> v.d&gt;u.d+w(u.v)</span><br><span class="line">	v.d = u.d+w(u,v)</span><br><span class="line">	v.\pi = u</span><br></pre></td></tr></table></figure>

<h2 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h2><p>Bellman-Ford算法是一种用于解决单源最短路径问题的算法，它可以处理带有负权边的图。以下是Bellman-Ford算法的详细说明以及一个简单的C++实现。</p>
<h3 id="Bellman-Ford算法简介："><a href="#Bellman-Ford算法简介：" class="headerlink" title="Bellman-Ford算法简介："></a>Bellman-Ford算法简介：</h3><p>Bellman-Ford算法的基本思想是通过不断迭代，更新从源节点到其他节点的最短路径估计值，直到找到最短路径或者确定图中存在负权环。</p>
<p>算法步骤：</p>
<ol>
<li>初始化：将源节点的最短路径估计值设为0，其他节点的最短路径估计值设为正无穷大。</li>
<li>进行$|V| - 1$轮迭代，其中$|V|$是图中节点的数量。</li>
<li>在每一轮迭代中，遍历图中的所有边，更新节点的最短路径估计值。</li>
<li>如果在$|V| - 1$轮迭代后，仍然存在可以松弛的边，说明图中存在负权环。</li>
</ol>
<aside>
💡 时间复杂度：$O(VE)$


</aside>

<h3 id="C-实现："><a href="#C-实现：" class="headerlink" title="C++实现："></a>C++实现：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> src, dest, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bellmanFord</span><span class="params">(vector&lt;Edge&gt;&amp; edges, <span class="type">int</span> V, <span class="type">int</span> E, <span class="type">int</span> src)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">distance</span><span class="params">(V, INT_MAX)</span></span>;</span><br><span class="line">    distance[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Relaxation step</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= V - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; E; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> u = edges[j].src;</span><br><span class="line">            <span class="type">int</span> v = edges[j].dest;</span><br><span class="line">            <span class="type">int</span> w = edges[j].weight;</span><br><span class="line">            <span class="keyword">if</span> (distance[u] != INT_MAX &amp;&amp; distance[u] + w &lt; distance[v]) &#123;</span><br><span class="line">                distance[v] = distance[u] + w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for negative-weight cycles</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> u = edges[i].src;</span><br><span class="line">        <span class="type">int</span> v = edges[i].dest;</span><br><span class="line">        <span class="type">int</span> w = edges[i].weight;</span><br><span class="line">        <span class="keyword">if</span> (distance[u] != INT_MAX &amp;&amp; distance[u] + w &lt; distance[v]) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Graph contains negative weight cycle!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print the result</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Shortest distances from source &quot;</span> &lt;&lt; src &lt;&lt; <span class="string">&quot; to all other vertices:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; distance[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V, E; <span class="comment">// V is the number of vertices, E is the number of edges</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the number of vertices and edges: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; V &gt;&gt; E;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;Edge&gt; <span class="title">edges</span><span class="params">(E)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the source, destination, and weight for each edge:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; edges[i].src &gt;&gt; edges[i].dest &gt;&gt; edges[i].weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> src;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the source vertex: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; src;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bellmanFord</span>(edges, V, E, src);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述C++代码中，<code>Edge</code>结构体表示图的边，<code>bellmanFord</code>函数实现了Bellman-Ford算法，其中<code>distance</code>数组存储了从源节点到各个节点的最短路径估计值。在算法结束后，它会输出从源节点到所有其他节点的最短路径。如果存在负权环，则会输出相应的提示。</p>
<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>Dijkstra算法是一种用于解决单源最短路径问题的贪心算法。它通过不断选择距离源节点最近的节点来逐步确定最短路径。以下是Dijkstra算法的详细说明以及一个简单的C++实现。</p>
<aside>
💡 该算法要求所有边的权重都为非负值


</aside>

<h3 id="Dijkstra算法简介："><a href="#Dijkstra算法简介：" class="headerlink" title="Dijkstra算法简介："></a>Dijkstra算法简介：</h3><p>Dijkstra算法的基本思想是维护一个集合，其中包含了已经找到最短路径的节点，以及一个数组用于存储从源节点到其他节点的最短路径估计值。在每一步，选择距离源节点最近的未标记节点，并通过这个节点更新其他节点的最短路径估计值。重复这个过程，直到找到从源节点到目标节点的最短路径或者所有节点都被标记。</p>
<p>算法步骤：</p>
<ol>
<li>初始化：将源节点的最短路径估计值设为0，其他节点的最短路径估计值设为正无穷大。</li>
<li>在每一步中，选择未标记节点中距离源节点最近的节点，标记它，并更新通过这个节点到其他未标记节点的最短路径估计值。</li>
<li>重复步骤2，直到找到从源节点到目标节点的最短路径或者所有节点都被标记。</li>
</ol>
<h3 id="C-实现：-1"><a href="#C-实现：-1" class="headerlink" title="C++实现："></a>C++实现：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> dest, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> V; <span class="comment">// Number of vertices</span></span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; adj; <span class="comment">// Adjacency list</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> V) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">        adj.<span class="built_in">resize</span>(V);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> src, <span class="type">int</span> dest, <span class="type">int</span> weight)</span> </span>&#123;</span><br><span class="line">        Edge edge = &#123;dest, weight&#125;;</span><br><span class="line">        adj[src].<span class="built_in">push_back</span>(edge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> src)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">distance</span><span class="params">(V, INT_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line">        pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, src&#125;);</span><br><span class="line">        distance[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = pq.<span class="built_in">top</span>().second;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : adj[u]) &#123;</span><br><span class="line">                <span class="type">int</span> v = edge.dest;</span><br><span class="line">                <span class="type">int</span> w = edge.weight;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (distance[u] != INT_MAX &amp;&amp; distance[u] + w &lt; distance[v]) &#123;</span><br><span class="line">                    distance[v] = distance[u] + w;</span><br><span class="line">                    pq.<span class="built_in">push</span>(&#123;distance[v], v&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print the result</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Shortest distances from source &quot;</span> &lt;&lt; src &lt;&lt; <span class="string">&quot; to all other vertices:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; distance[i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V, E; <span class="comment">// V is the number of vertices, E is the number of edges</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the number of vertices and edges: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; V &gt;&gt; E;</span><br><span class="line"></span><br><span class="line">    <span class="function">Graph <span class="title">graph</span><span class="params">(V)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the source, destination, and weight for each edge:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> src, dest, weight;</span><br><span class="line">        cin &gt;&gt; src &gt;&gt; dest &gt;&gt; weight;</span><br><span class="line">        graph.<span class="built_in">addEdge</span>(src, dest, weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> src;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the source vertex: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; src;</span><br><span class="line"></span><br><span class="line">    graph.<span class="built_in">dijkstra</span>(src);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述C++代码中，<code>Edge</code>结构体表示图的边，<code>Graph</code>类封装了图的邻接列表和Dijkstra算法的实现。在算法结束后，它会输出从源节点到所有其他节点的最短路径。</p>
<h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn (int)1e6 + 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 2e9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line">priority_queue&lt;pr, vector&lt;pr&gt;, greater&lt;pr&gt;&gt; q;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">edgex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> head[maxn];</span><br><span class="line">edgex edge[maxn * <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].weight = w;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dis[maxn];</span><br><span class="line"><span class="type">bool</span> visit[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">        <span class="built_in">add</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> num = it.second;</span><br><span class="line">        <span class="keyword">if</span> (visit[num])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[num] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[num]; i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> to = edge[i].to;</span><br><span class="line">            <span class="type">int</span> weight = edge[i].weight;</span><br><span class="line">            dis[to] = <span class="built_in">min</span>(dis[to], <span class="built_in">max</span>(weight, dis[num]));</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[to], to));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[i] == inf)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第25章-所有节点对的最短路径问题"><a href="#第25章-所有节点对的最短路径问题" class="headerlink" title="第25章 所有节点对的最短路径问题"></a>第25章 所有节点对的最短路径问题</h1><h2 id="Floyd-Warshall算法"><a href="#Floyd-Warshall算法" class="headerlink" title="Floyd-Warshall算法"></a>Floyd-Warshall算法</h2><p>Floyd-Warshall算法是一种经典的图算法，用于求解所有点对之间的最短路径。该算法的时间复杂度为O$(V^3)$，其中V是图中顶点的数量。它基于动态规划的思想，<strong>适用于有向图或无向图，可以处理带有负权边但无负权环路的图。</strong></p>
<hr>
<p><strong>动态规划的思路：</strong></p>
<pre><code>求图上两点 i、j 之间的最短距离，可以按“从小图到全图”的步骤，在逐步扩大图的过程中计算和更新最短路。想象图中的每个点是一个灯，开始时所有灯都是灭的。然后逐个点亮灯，每点亮一个灯，就重新计算 i、j 的最短路，要求路径只能经过点亮的灯。所有灯都点亮后，计算结束。在这个过程中，点亮第 k 个灯时，能用到 1∼k−1 个亮灯的结果。

定义状态为 dp[k][i][j]，i、j、k 是点的编号，范围 1∼n 。状态 dp[k][i][j] 表示在包含 1∼k 点的子图上，点对 i、j 之间的最短路。当从子图 1∼k−1 扩展到子图 1∼k 时，状态转移方程这样设计：
</code></pre>
<aside>
💡 dp[k][i][j] = min(dp[k-1][i][j], dp[k-1][i][k] + dp[k-1][k][j])


</aside>

<p><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/10/20250710223227.png" alt="Untitled"></p>
<pre><code>计算过程如上图所示，虚线圆圈内是包含了 1∼k−1 点的子图。方程中的 dp[k−1][i][j] 是虚线子图内的点对 i、j 的最短路；dp[k−1][i][k]+dp[k−1][k][j] 是经过 k 点的新路径的长度，即这条路径从 i 出发，先到 k，再从 k 到终点 j。比较不经过 k 的最短路径 dp[k−1][i][j] 和经过 k 的新路径，较小者就是新的 dp[k][i][j]。每次扩展一个新点 k 时，都能用到 1∼k−1 的结果，从而提高了效率。这就是**动态规划**的方法。
当 k 从 1 逐步扩展到 n 时，最后得到的 dp[n][i][j] 是点对 i、j 之间的最短路径长度。由于 i 和 j 是图中所有的点对，所以能得到所有点对之间的最短路。
</code></pre>
<hr>
<h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h3><ol>
<li><strong>初始化</strong>：创建一个二维数组 <code>dist[][]</code> 用于存储节点之间的最短距离。初始化这个数组，使得 <code>dist[i][j]</code> 表示节点 <code>i</code> 到节点 <code>j</code> 的最短路径距离。如果两个节点之间有直接的边，则 <code>dist[i][j]</code> 设为这条边的权重值，否则设为一个较大的数或者无穷大。</li>
<li><strong>进行迭代</strong>：使用三重循环遍历所有节点对 <code>(i, j)</code>，在每次迭代中尝试找到节点 <code>k</code> 作为中间节点，检查是否存在一条路径经过节点 <code>k</code> 使得从 <code>i</code> 到 <code>j</code> 的路径长度变短。更新 <code>dist[i][j]</code> 为 <code>min(dist[i][j], dist[i][k] + dist[k][j])</code>。</li>
</ol>
<h3 id="用邻接矩阵表示图："><a href="#用邻接矩阵表示图：" class="headerlink" title="用邻接矩阵表示图："></a>用邻接矩阵表示图：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 99999</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">floydWarshall</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> V) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dist = graph;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; V; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; V; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] != INF &amp;&amp; dist[k][j] != INF &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V;</span><br><span class="line">    cin &gt;&gt; V;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(V, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(V, INF));</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dist = <span class="built_in">floydWarshall</span>(graph, V);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个示例首先接受用户输入图的节点数和<strong>邻接矩阵</strong>，然后使用 Floyd-Warshall 算法计算最短路径矩阵，并将结果输出。记得将输入的边权重矩阵中不存在的边表示为INF或者一个足够大的数。</p>
<h3 id="C5-上机A题：（下面的代码还可以输出最短路径）"><a href="#C5-上机A题：（下面的代码还可以输出最短路径）" class="headerlink" title="C5 上机A题：（下面的代码还可以输出最短路径）"></a>C5 上机A题：（下面的代码还可以输出最短路径）</h3><p>此题点的个数不多（不超过300），但是需要查询任意两点的最短距离，并且查询次数在$10^5$，因此特别适合用<strong>Floyd-Warshall</strong>算法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max 303 <span class="comment">// 最大点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> INF = <span class="number">1e12</span> + <span class="number">1</span>; <span class="comment">// 权值最大为10^9，INF要开得比10^9大几个数量级</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AMGraph</span> &#123;						<span class="comment">//定义邻接矩阵</span></span><br><span class="line">	<span class="type">int</span> vex, arc;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> arcs[Max][Max];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> dis[Max][Max];</span><br><span class="line"><span class="type">int</span>  path[Max][Max];				<span class="comment">//dis存最短路程，path保存路径</span></span><br><span class="line"><span class="comment">// path[i][j] = k表示从i到k经过的最后一个节点为k，可以递归path[i][k]求出完整路径</span></span><br><span class="line"><span class="comment">// 若k为-1表示i和j不连通</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(AMGraph &amp;G)</span>							<span class="comment">//弗洛伊德算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= G.vex; i++)			<span class="comment">//初始化dis和path</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= G.vex; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dis[i][j] = G.arcs[i][j];</span><br><span class="line">			<span class="keyword">if</span> (dis[i][j] != INF&amp;&amp;i != j) path[i][j] = i;</span><br><span class="line">			<span class="keyword">else</span> path[i][j] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	<span class="comment">/***************Floyd核心算法****************/</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=G.vex; k++)					<span class="comment">//遍历每个点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=G.vex; i++)				<span class="comment">//遍历每条边</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= G.vex; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (dis[i][k] + dis[k][j] &lt; dis[i][j]) &#123;	</span><br><span class="line">					dis[i][j] = dis[i][k] + dis[k][j];			<span class="comment">//松弛操作</span></span><br><span class="line">					path[i][j] = k;								<span class="comment">//保存j前驱结点k</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putin</span><span class="params">(AMGraph &amp;G)</span>							<span class="comment">//输入图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> u, v, w;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; G.vex &gt;&gt; G.arc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= G.vex; i++)			<span class="comment">//初始化邻接矩阵</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= G.vex; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == j) G.arcs[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> G.arcs[i][j] = INF;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.arc; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">if</span>(w &lt; G.arcs[u][v])</span><br><span class="line">		    G.arcs[u][v] = w;</span><br><span class="line"><span class="comment">//		G.arcs[v][u] = w;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	AMGraph G;</span><br><span class="line">	<span class="built_in">putin</span>(G);</span><br><span class="line">	<span class="built_in">Floyd</span>(G);</span><br><span class="line">    <span class="type">int</span> q, u, v;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span>((u != v) &amp;&amp; (path[u][v] == <span class="number">-1</span>))&#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; dis[u][v] &lt;&lt; endl;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第26章-最大流"><a href="#第26章-最大流" class="headerlink" title="第26章 最大流"></a>第26章 最大流</h1><h2 id="EK（Edmond—Karp）算法"><a href="#EK（Edmond—Karp）算法" class="headerlink" title="EK（Edmond—Karp）算法"></a>EK（Edmond—Karp）算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arraysize 201</span></span><br><span class="line"><span class="type">int</span> maxData = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">int</span> capacity[arraysize][arraysize]; <span class="comment">//记录残留网络的容量</span></span><br><span class="line"><span class="type">int</span> flow[arraysize];                <span class="comment">//标记从源点到当前节点实际还剩多少流量可用</span></span><br><span class="line"><span class="type">int</span> pre[arraysize];                 <span class="comment">//标记在这条路径上当前节点的前驱,同时标记该节点是否在队列中</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; myqueue;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> src,<span class="type">int</span> des)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">while</span>(!myqueue.<span class="built_in">empty</span>())       <span class="comment">//队列清空</span></span><br><span class="line">        myqueue.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m<span class="number">+1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre[src]=<span class="number">0</span>;</span><br><span class="line">    flow[src]= maxData;</span><br><span class="line">    myqueue.<span class="built_in">push</span>(src);</span><br><span class="line">    <span class="keyword">while</span>(!myqueue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = myqueue.<span class="built_in">front</span>();</span><br><span class="line">        myqueue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(index == des)            <span class="comment">//找到了增广路径</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m<span class="number">+1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=src &amp;&amp; capacity[index][i]&gt;<span class="number">0</span> &amp;&amp; pre[i]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                 pre[i] = index; <span class="comment">//记录前驱</span></span><br><span class="line">                 flow[i] = <span class="built_in">min</span>(capacity[index][i],flow[index]);   <span class="comment">//关键：迭代的找到增量</span></span><br><span class="line">                 myqueue.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre[des]==<span class="number">-1</span>)      <span class="comment">//残留图中不再存在增广路径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> flow[des];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxFlow</span><span class="params">(<span class="type">int</span> src,<span class="type">int</span> des)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> increasement= <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sumflow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((increasement=<span class="built_in">BFS</span>(src,des))!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="type">int</span> k = des;          <span class="comment">//利用前驱寻找路径</span></span><br><span class="line">         <span class="keyword">while</span>(k!=src)</span><br><span class="line">         &#123;</span><br><span class="line">              <span class="type">int</span> last = pre[k];</span><br><span class="line">              capacity[last][k] -= increasement; <span class="comment">//改变正向边的容量</span></span><br><span class="line">              capacity[k][last] += increasement; <span class="comment">//改变反向边的容量</span></span><br><span class="line">              k = last;</span><br><span class="line">         &#125;</span><br><span class="line">         sumflow += increasement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sumflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> start,end,ci;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(capacity,<span class="number">0</span>,<span class="built_in">sizeof</span>(capacity));</span><br><span class="line">        <span class="built_in">memset</span>(flow,<span class="number">0</span>,<span class="built_in">sizeof</span>(flow));</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;start&gt;&gt;end&gt;&gt;ci;</span><br><span class="line">            <span class="keyword">if</span>(start == end)               <span class="comment">//考虑起点终点相同的情况</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            capacity[start][end] +=ci;     <span class="comment">//此处注意可能出现多条同一起点终点的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">maxFlow</span>(<span class="number">1</span>,m)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Ford-Fulkerson算法"><a href="#Ford-Fulkerson算法" class="headerlink" title="Ford-Fulkerson算法"></a>Ford-Fulkerson算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> map[<span class="number">300</span>][<span class="number">300</span>];</span><br><span class="line"><span class="type">int</span> used[<span class="number">300</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t,<span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map[s][i] &gt; <span class="number">0</span> &amp;&amp; !used[i]) &#123;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> d = <span class="built_in">dfs</span>(i,t,<span class="built_in">min</span>(f,map[s][i]));</span><br><span class="line">            <span class="keyword">if</span>(d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                map[s][i] -= d;</span><br><span class="line">                map[i][s] += d;</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxflow</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="built_in">sizeof</span>(used));</span><br><span class="line">        <span class="type">int</span> f = <span class="built_in">dfs</span>(s,t,INF);<span class="comment">//不断找从s到t的增广路</span></span><br><span class="line">        <span class="keyword">if</span>(f == <span class="number">0</span>) <span class="keyword">return</span> flow;<span class="comment">//找不到了就回去</span></span><br><span class="line">        flow += f;<span class="comment">//找到一个流量f的路</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n) != EOF) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(map,<span class="number">0</span>,<span class="built_in">sizeof</span>(map));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; m ; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> from,to,cap;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;from,&amp;to,&amp;cap);</span><br><span class="line">            map[from][to] += cap;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">maxflow</span>(<span class="number">1</span>,n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&lt;/span&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> MAX = <span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> n, m; </span><br><span class="line"><span class="type">int</span> s, t;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c[MAX][MAX], dep[MAX];<span class="comment">//dep[MAX]代表当前层数</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span><span class="comment">//重新建图，按层次建图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dep));</span><br><span class="line">    dep[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c[u][v] &gt; <span class="number">0</span> &amp;&amp; dep[v] == <span class="number">-1</span>)&#123;<span class="comment">//如果可以到达且还没有访问，可以到达的条件是剩余容量大于0，没有访问的条件是当前层数还未知</span></span><br><span class="line">                dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">long</span> <span class="type">long</span> mi, <span class="type">int</span> t)</span><span class="comment">//查找路径上的最小流量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == t)</span><br><span class="line">        <span class="keyword">return</span> mi;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[u][v] &gt; <span class="number">0</span> &amp;&amp; dep[v] == dep[u] + <span class="number">1</span>  &amp;&amp; (tmp = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(mi, c[u][v]), t)))&#123;</span><br><span class="line">            c[u][v] -= tmp;</span><br><span class="line">            c[v][u] += tmp;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>, tmp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>(s, t))&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            tmp = <span class="built_in">dfs</span>(s, inf, t);</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ans += tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c));</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            c[u][v] += w;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">dinic</span>(s, t) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="算法问题选编"><a href="#算法问题选编" class="headerlink" title="算法问题选编"></a>算法问题选编</h1><h2 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h2><h3 id="基础模板"><a href="#基础模板" class="headerlink" title="基础模板"></a>基础模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> inf = <span class="number">1e100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">double</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(d) &lt; eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(d &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dcmp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x - y) &lt; eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">1.49999</span>;</span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">floor</span>(x);<span class="comment">//向下取整函数</span></span><br><span class="line">    <span class="type">int</span> cx = <span class="built_in">ceil</span>(x);<span class="comment">//向上取整函数</span></span><br><span class="line">    <span class="type">int</span> rx = <span class="built_in">round</span>(x);<span class="comment">//四舍五入函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f %d %d %d\n&quot;</span>, x, fx, cx, rx);</span><br><span class="line">    <span class="comment">//输出结果 1.499990 1 2 1</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<aside>
💡 不要直接用等号判断浮点数是否相等！


</aside>

<ol>
<li>误差判别法</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dcmp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x - y) &lt; eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>化浮为整</li>
</ol>
<p>在不溢出整数范围的情况下，可以通过乘上$10^k$转化为整数运算，最后再将结果转化为浮点数输出</p>
<aside>
💡 输出时一定要小心不要输出 −0


</aside>

<h3 id="点与向量"><a href="#点与向量" class="headerlink" title="点与向量"></a>点与向量</h3><p><img src="C:/Users/bush/Downloads/d8ccad17-591b-4ffd-839c-a7eff71de0d0_Export-d81b6b00-2ff1-46bc-ab30-566c925b0020/Untitled.png" alt="Untitled"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/10/20250710223846.png" alt="Untitled"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x = <span class="number">0</span>, <span class="type">double</span> y = <span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line">Vector <span class="keyword">operator</span> + (Vector A, Vector B)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(A.x+B.x, A.y+B.y);</span><br><span class="line">&#125;</span><br><span class="line">Vector <span class="keyword">operator</span> - (Point A, Point B)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(A.x-B.x, A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line">Vector <span class="keyword">operator</span> * (Vector A, <span class="type">double</span> p)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(A.x*p, A.y*p);</span><br><span class="line">&#125;</span><br><span class="line">Vector <span class="keyword">operator</span> / (Vector A, <span class="type">double</span> p)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(A.x/p, A.y/p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)</span><br><span class="line">        <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(a.x-b.x) == <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(a.y-b.y) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Dot</span><span class="params">(Vector A, Vector B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.x*B.x + A.y*B.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取模（长度）</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Length</span><span class="params">(Vector A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">Dot</span>(A, A));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Angle</span><span class="params">(Vector A, Vector B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">acos</span>(<span class="built_in">Dot</span>(A, B)/<span class="built_in">Length</span>(A)/<span class="built_in">Length</span>(B));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Cross</span><span class="params">(Vector A, Vector B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.x*B.y-A.y*B.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 平行四边形有向面积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Area2</span><span class="params">(Point A, Point B, Point C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cross</span>(B-A, C-A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 逆时针旋转后的向量</span></span><br><span class="line"><span class="function">Vector <span class="title">Rotate</span><span class="params">(Vector A, <span class="type">double</span> rad)</span></span>&#123;<span class="comment">//rad为弧度 且为逆时针旋转的角</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(A.x*<span class="built_in">cos</span>(rad)-A.y*<span class="built_in">sin</span>(rad), A.x*<span class="built_in">sin</span>(rad)+A.y*<span class="built_in">cos</span>(rad));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算向量逆时针旋转九十度的单位法向量</span></span><br><span class="line"><span class="function">Vector <span class="title">Normal</span><span class="params">(Vector A)</span></span>&#123;<span class="comment">//向量A左转90°的单位法向量</span></span><br><span class="line">    <span class="type">double</span> L = <span class="built_in">Length</span>(A);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(-A.y/L, A.x/L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断折线bc→是不是向ab的逆时针方向（左边）转向</span></span><br><span class="line"><span class="comment">// 凸包构造时将会频繁用到此公式</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ToLeftTest</span><span class="params">(Point a, Point b, Point c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cross</span>(b - a, c - b) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="点与线"><a href="#点与线" class="headerlink" title="点与线"></a>点与线</h3><p>![Untitled](C:&#x2F;Users&#x2F;bush&#x2F;Downloads&#x2F;d8ccad17-591b-4ffd-839c-a7eff71de0d0_Export-d81b6b00-2ff1-46bc-ab30-566c925b0020&#x2F;Untitled 2.png)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;<span class="comment">//直线定义</span></span><br><span class="line">    Point v, p;</span><br><span class="line">    <span class="built_in">Line</span>(Point v, Point p):<span class="built_in">v</span>(v), <span class="built_in">p</span>(p) &#123;&#125;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="type">double</span> t)</span></span>&#123;<span class="comment">//返回点P = v + (p - v)*t</span></span><br><span class="line">        <span class="keyword">return</span> v + (p - v)*t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//计算两直线交点</span></span><br><span class="line"><span class="comment">//调用前需保证 Cross(v, w) != 0</span></span><br><span class="line"><span class="function">Point <span class="title">GetLineIntersection</span><span class="params">(Point P, Vector v, Point Q, Vector w)</span></span>&#123;</span><br><span class="line">    Vector u = P-Q;</span><br><span class="line">    <span class="type">double</span> t = <span class="built_in">Cross</span>(w, u)/<span class="built_in">Cross</span>(v, w);</span><br><span class="line">    <span class="keyword">return</span> P+v*t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点P到直线AB距离公式</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">DistanceToLine</span><span class="params">(Point P, Point A, Point B)</span></span>&#123;</span><br><span class="line">    Vector v1 = B-A, v2 = P-A;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">Cross</span>(v1, v2)/<span class="built_in">Length</span>(v1));</span><br><span class="line">&#125;<span class="comment">//不去绝对值，得到的是有向距离</span></span><br><span class="line"><span class="comment">//点P到线段AB距离公式</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">DistanceToSegment</span><span class="params">(Point P, Point A, Point B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A == B)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Length</span>(P-A);</span><br><span class="line">    Vector v1 = B-A, v2 = P-A, v3 = P-B;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dcmp</span>(<span class="built_in">Dot</span>(v1, v2)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Length</span>(v2);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dcmp</span>(<span class="built_in">Dot</span>(v1, v3)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Length</span>(v3);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DistanceToLine</span>(P, A, B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点P在直线AB上的投影点</span></span><br><span class="line"><span class="function">Point <span class="title">GetLineProjection</span><span class="params">(Point P, Point A, Point B)</span></span>&#123;</span><br><span class="line">    Vector v = B-A;</span><br><span class="line">    <span class="keyword">return</span> A+v*(<span class="built_in">Dot</span>(v, P-A)/<span class="built_in">Dot</span>(v, v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断p点是否在线段a1a2上</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OnSegment</span><span class="params">(Point p, Point a1, Point a2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dcmp</span>(<span class="built_in">Cross</span>(a1-p, a2-p)) == <span class="number">0</span> &amp;&amp; <span class="built_in">dcmp</span>(<span class="built_in">Dot</span>(a1-p, a2-p)) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断两线段是否相交</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SegmentProperIntersection</span><span class="params">(Point a1, Point a2, Point b1, Point b2)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> c1 = <span class="built_in">Cross</span>(a2-a1, b1-a1), c2 = <span class="built_in">Cross</span>(a2-a1, b2-a1);</span><br><span class="line">    <span class="type">double</span> c3 = <span class="built_in">Cross</span>(b2-b1, a1-b1), c4 = <span class="built_in">Cross</span>(b2-b1, a2-b1);</span><br><span class="line">    <span class="comment">//if判断控制是否允许线段在端点处相交，根据需要添加</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">sgn</span>(c1) || !<span class="built_in">sgn</span>(c2) || !<span class="built_in">sgn</span>(c3) || !<span class="built_in">sgn</span>(c4))&#123;</span><br><span class="line">        <span class="type">bool</span> f1 = <span class="built_in">OnSegment</span>(b1, a1, a2);</span><br><span class="line">        <span class="type">bool</span> f2 = <span class="built_in">OnSegment</span>(b2, a1, a2);</span><br><span class="line">        <span class="type">bool</span> f3 = <span class="built_in">OnSegment</span>(a1, b1, b2);</span><br><span class="line">        <span class="type">bool</span> f4 = <span class="built_in">OnSegment</span>(a2, b1, b2);</span><br><span class="line">        <span class="type">bool</span> f = (f1|f2|f3|f4);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">sgn</span>(c1)*<span class="built_in">sgn</span>(c2) &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(c3)*<span class="built_in">sgn</span>(c4) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多边形有向面积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">PolygonArea</span><span class="params">(Point* p, <span class="type">int</span> n)</span></span>&#123;<span class="comment">//p为端点集合，n为端点个数</span></span><br><span class="line">    <span class="type">double</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; ++i)</span><br><span class="line">        s += <span class="built_in">Cross</span>(p[i]-p[<span class="number">0</span>], p[i<span class="number">+1</span>]-p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断点是否在多边形内，若点在多边形内返回1，在多边形外部返回0，在多边形上返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPointInPolygon</span><span class="params">(Point p, vector&lt;Point&gt; poly)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> wn = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = poly.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">OnSegment</span>(p, poly[i], poly[(i<span class="number">+1</span>)%n])) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">sgn</span>(<span class="built_in">Cross</span>(poly[(i<span class="number">+1</span>)%n] - poly[i], p - poly[i]));</span><br><span class="line">        <span class="type">int</span> d1 = <span class="built_in">sgn</span>(poly[i].y - p.y);</span><br><span class="line">        <span class="type">int</span> d2 = <span class="built_in">sgn</span>(poly[(i<span class="number">+1</span>)%n].y - p.y);</span><br><span class="line">        <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>) wn++;</span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(wn != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span>&#123; <span class="comment">// 定义</span></span><br><span class="line">    Point c;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line">    <span class="built_in">Circle</span>(Point c, <span class="type">double</span> r):<span class="built_in">c</span>(c), <span class="built_in">r</span>(r) &#123;&#125;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="type">double</span> a)</span></span>&#123;<span class="comment">//通过圆心角求坐标</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(c.x + <span class="built_in">cos</span>(a)*r, c.y + <span class="built_in">sin</span>(a)*r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//求圆与直线交点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getLineCircleIntersection</span><span class="params">(Line L, Circle C, <span class="type">double</span>&amp; t1, <span class="type">double</span>&amp; t2, vector&lt;Point&gt;&amp; sol)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y;</span><br><span class="line">    <span class="type">double</span> e = a*a + c*c, f = <span class="number">2</span>*(a*b + c*d), g = b*b + d*d - C.r*C.r;</span><br><span class="line">    <span class="type">double</span> delta = f*f - <span class="number">4</span>*e*g;<span class="comment">//判别式</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(delta) &lt; <span class="number">0</span>)<span class="comment">//相离</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(delta) == <span class="number">0</span>)&#123;<span class="comment">//相切</span></span><br><span class="line">        t1 = -f /(<span class="number">2</span>*e);</span><br><span class="line">        t2 = -f /(<span class="number">2</span>*e);</span><br><span class="line">        sol.<span class="built_in">push_back</span>(L.<span class="built_in">point</span>(t1));<span class="comment">//sol存放交点本身</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//相交</span></span><br><span class="line">    t1 = (-f - <span class="built_in">sqrt</span>(delta))/(<span class="number">2</span>*e);</span><br><span class="line">    sol.<span class="built_in">push_back</span>(L.<span class="built_in">point</span>(t1));</span><br><span class="line">    t2 = (-f + <span class="built_in">sqrt</span>(delta))/(<span class="number">2</span>*e);</span><br><span class="line">    sol.<span class="built_in">push_back</span>(L.<span class="built_in">point</span>(t2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两圆相交面积</span></span><br><span class="line"><span class="comment">// 通过计算两个圆相交所构成的两个扇形面积和减去其构成的筝形的面积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">AreaOfOverlap</span><span class="params">(Point c1, <span class="type">double</span> r1, Point c2, <span class="type">double</span> r2)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> d = <span class="built_in">Length</span>(c1 - c2);</span><br><span class="line">    <span class="keyword">if</span>(r1 + r2 &lt; d + eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(d &lt; <span class="built_in">fabs</span>(r1 - r2) + eps)&#123;</span><br><span class="line">        <span class="type">double</span> r = <span class="built_in">min</span>(r1, r2);</span><br><span class="line">        <span class="keyword">return</span> pi*r*r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> x = (d*d + r1*r1 - r2*r2)/(<span class="number">2.0</span>*d);</span><br><span class="line">    <span class="type">double</span> p = (r1 + r2 + d)/<span class="number">2.0</span>;</span><br><span class="line">    <span class="type">double</span> t1 = <span class="built_in">acos</span>(x/r1);</span><br><span class="line">    <span class="type">double</span> t2 = <span class="built_in">acos</span>((d - x)/r2);</span><br><span class="line">    <span class="type">double</span> s1 = r1*r1*t1;</span><br><span class="line">    <span class="type">double</span> s2 = r2*r2*t2;</span><br><span class="line">    <span class="type">double</span> s3 = <span class="number">2</span>*<span class="built_in">sqrt</span>(p*(p - r1)*(p - r2)*(p - d));</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 - s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找凸包"><a href="#寻找凸包" class="headerlink" title="寻找凸包"></a>寻找凸包</h2><h3 id="Graham扫描法"><a href="#Graham扫描法" class="headerlink" title="Graham扫描法"></a>Graham扫描法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x = <span class="number">0</span>, <span class="type">double</span> y = <span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line">Point lst[maxn];</span><br><span class="line"><span class="type">int</span> stk[maxn], top;</span><br><span class="line">Vector <span class="keyword">operator</span> - (Point A, Point B)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(A.x-B.x, A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Cross</span><span class="params">(Vector v0, Vector v1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v<span class="number">0.</span>x*v<span class="number">1.</span>y - v<span class="number">1.</span>x*v<span class="number">0.</span>y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Dis</span><span class="params">(Point p1, Point p2)</span> </span>&#123; <span class="comment">//计算 p1p2的 距离</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((p<span class="number">2.</span>x-p<span class="number">1.</span>x)*(p<span class="number">2.</span>x-p<span class="number">1.</span>x)+(p<span class="number">2.</span>y-p<span class="number">1.</span>y)*(p<span class="number">2.</span>y-p<span class="number">1.</span>y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point p1, Point p2)</span> </span>&#123; <span class="comment">//极角排序函数 ，角度相同则距离小的在前面</span></span><br><span class="line">    <span class="type">int</span> tmp = <span class="built_in">sgn</span>(<span class="built_in">Cross</span>(p1 - lst[<span class="number">0</span>], p2 - lst[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(tmp == <span class="number">0</span> &amp;&amp; <span class="built_in">Dis</span>(lst[<span class="number">0</span>], p1) &lt; <span class="built_in">Dis</span>(lst[<span class="number">0</span>], p2))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点的编号0 ~ n - 1</span></span><br><span class="line"><span class="comment">//返回凸包结果stk[0 ~ top - 1]为凸包的编号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graham</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    Point p0;</span><br><span class="line">    p<span class="number">0.</span>x = lst[<span class="number">0</span>].x;</span><br><span class="line">    p<span class="number">0.</span>y = lst[<span class="number">0</span>].y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>( (p<span class="number">0.</span>y &gt; lst[i].y) || ((p<span class="number">0.</span>y == lst[i].y) &amp;&amp; (p<span class="number">0.</span>x &gt; lst[i].x)) ) &#123;</span><br><span class="line">            p<span class="number">0.</span>x = lst[i].x;</span><br><span class="line">            p<span class="number">0.</span>y = lst[i].y;</span><br><span class="line">            k = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lst[k] = lst[<span class="number">0</span>];</span><br><span class="line">    lst[<span class="number">0</span>] = p0;</span><br><span class="line">    <span class="built_in">sort</span>(lst + <span class="number">1</span>, lst + n, cmp);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        top = <span class="number">1</span>;</span><br><span class="line">        stk[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) &#123;</span><br><span class="line">        top = <span class="number">2</span>;</span><br><span class="line">        stk[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        stk[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    stk[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    stk[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    top = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(top &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">Cross</span>(lst[stk[top - <span class="number">1</span>]] - lst[stk[top - <span class="number">2</span>]], lst[i] - lst[stk[top - <span class="number">2</span>]]) &lt;= <span class="number">0</span>)</span><br><span class="line">            --top;</span><br><span class="line">        stk[top] = i;</span><br><span class="line">        ++top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Andrew算法"><a href="#Andrew算法" class="headerlink" title="Andrew算法"></a>Andrew算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x = <span class="number">0</span>, <span class="type">double</span> y = <span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line">Vector <span class="keyword">operator</span> - (Point A, Point B)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(A.x-B.x, A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)</span><br><span class="line">        <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Cross</span><span class="params">(Vector v0, Vector v1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v<span class="number">0.</span>x*v<span class="number">1.</span>y - v<span class="number">1.</span>x*v<span class="number">0.</span>y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算凸包，输入点数组为 p，个数为 n， 输出点数组为 ch。函数返回凸包顶点数</span></span><br><span class="line"><span class="comment">//如果不希望凸包的边上有输入点，则把两个 &lt;= 改为 &lt;</span></span><br><span class="line"><span class="comment">//在精度要求高时建议用dcmp比较</span></span><br><span class="line"><span class="comment">//输入不能有重复点，函数执行完后输入点的顺序被破坏</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ConvexHull</span><span class="params">(Point* p, <span class="type">int</span> n, Point* ch)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(p, p+n);</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(m &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">Cross</span>(ch[m<span class="number">-1</span>] - ch[m<span class="number">-2</span>], p[i] - ch[m<span class="number">-2</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        ch[m++] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-2</span>; i&gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(m &gt; k &amp;&amp; <span class="built_in">Cross</span>(ch[m<span class="number">-1</span>] - ch[m<span class="number">-2</span>], p[i] - ch[m<span class="number">-2</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        ch[m++] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)</span><br><span class="line">        --m;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多项式与快速傅里叶变换"><a href="#多项式与快速傅里叶变换" class="headerlink" title="多项式与快速傅里叶变换"></a>多项式与快速傅里叶变换</h2><p>多项式与快速傅里叶变换（FFT）之间存在密切的关系，特别是在离散傅里叶变换（DFT）的计算中。FFT 是一种高效计算 DFT 的算法，而 DFT 又与多项式的乘法有关。</p>
<h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><p>在代数中，一个多项式是由变量的幂和系数的有限和组成的表达式。例如，一个一元多项式：</p>
<p>$P(x) &#x3D; a_0 + a_1x + a_2x^2 + \ldots + a_nx^n$ </p>
<p>其中 $a_0, a_1, \ldots, a_n$ 是多项式的系数，$x$ 是变量。</p>
<h3 id="离散傅里叶变换（DFT）"><a href="#离散傅里叶变换（DFT）" class="headerlink" title="离散傅里叶变换（DFT）"></a>离散傅里叶变换（DFT）</h3><p>离散傅里叶变换将一个离散序列（通常是时域上的信号）转换为其在频域上的表示。对于一个 (N)-点序列 $x_0, x_1, \ldots, x_{N-1}$，其 DFT 定义如下：</p>
<p> $X_k &#x3D; \sum_{n&#x3D;0}^{N-1} x_n \cdot e^{-\frac{2\pi i}{N}kn}$ </p>
<p>其中 $X_k$ 是频域上的第  $k$  个复数，$e$ 是自然对数的底，$i$ 是虚数单位。</p>
<h3 id="快速傅里叶变换（FFT）"><a href="#快速傅里叶变换（FFT）" class="headerlink" title="快速傅里叶变换（FFT）"></a>快速傅里叶变换（FFT）</h3><p>FFT 是一种高效计算 DFT 的算法，通过减少运算次数，从 $O(N^2)$ 的复杂度降低到 $O(N \log N)$。FFT 的算法实现多种，其中最常见的是 Cooley-Tukey 算法。</p>
<h3 id="FFT与多项式乘法"><a href="#FFT与多项式乘法" class="headerlink" title="FFT与多项式乘法"></a>FFT与多项式乘法</h3><p>由于 DFT 与多项式的系数之间存在对应关系，FFT 被广泛用于多项式乘法。对于两个多项式 $A(x)$ 和 $B(x)$，它们的乘积的系数可以通过计算它们的 DFT，相乘，再通过逆 DFT 得到。这样，可以将多项式的乘法复杂度从 $O(n^2)$，降低到 $O(n \log n)$。</p>
<p>在这个例子中，<code>multiply</code> 函数用于计算两个多项式的卷积。你可以根据自己的需要调整输入多项式的系数。这段代码使用了复数类型 <code>complex&lt;double&gt;</code> 来表示复数，其中 <code>real()</code> 函数获取实部。最后，结果被四舍五入到最接近的整数。</p>
<p>对于更高效的迭代FFT，你可以使用位逆序置换（Bit-Reversal Permutation）来优化数据的存储和访问。以下是一个使用位逆序置换的迭代FFT的C++实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> complex&lt;<span class="type">double</span>&gt; Complex;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位逆序置换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bitReverse</span><span class="params">(vector&lt;Complex&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> bits = <span class="built_in">log2</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> bit = <span class="number">0</span>; bit &lt; bits; bit++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; bit)) &#123;</span><br><span class="line">                j |= <span class="number">1</span> &lt;&lt; (bits - <span class="number">1</span> - bit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代FFT</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">iterativeFFT</span><span class="params">(vector&lt;Complex&gt;&amp; a, <span class="type">bool</span> invert)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">bitReverse</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">double</span> angle = <span class="number">2</span> * PI / len * (invert ? <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="function">Complex <span class="title">wlen</span><span class="params">(cos(angle), sin(angle))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += len) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                Complex u = a[i + j];</span><br><span class="line">                Complex v = w * a[i + j + len / <span class="number">2</span>];</span><br><span class="line">                a[i + j] = u + v;</span><br><span class="line">                a[i + j + len / <span class="number">2</span>] = u - v;</span><br><span class="line">                w *= wlen;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (invert) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            a[i] /= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多项式卷积</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;Complex&gt; <span class="title">fa</span><span class="params">(a.begin(), a.end())</span>, <span class="title">fb</span><span class="params">(b.begin(), b.end())</span></span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; <span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>())) n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    fa.<span class="built_in">resize</span>(n);</span><br><span class="line">    fb.<span class="built_in">resize</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">iterativeFFT</span>(fa, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">iterativeFFT</span>(fb, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        fa[i] *= fb[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">iterativeFFT</span>(fa, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result[i] = <span class="built_in">round</span>(fa[i].<span class="built_in">real</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 第一个多项式系数</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;; <span class="comment">// 第二个多项式系数</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">multiply</span>(a, b);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result of convolution: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : result) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个实现中，<code>bitReverse</code> 函数用于执行位逆序置换，然后在迭代FFT的过程中使用这个置换后的数据。这有助于提高数据存储和访问的效率。</p>
<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><h3 id="1-朴素字符串匹配算法（Naive-String-Matching）："><a href="#1-朴素字符串匹配算法（Naive-String-Matching）：" class="headerlink" title="1.朴素字符串匹配算法（Naive String Matching）："></a>1.<strong>朴素字符串匹配算法（Naive String Matching）：</strong></h3><p> 也称为暴力匹配算法，它从文本的第一个字符开始与模式的第一个字符匹配，然后逐个字符比较，直到找到匹配或遍历完整个文本。</p>
<h3 id="2-Rabin-Karp算法：-基于哈希的字符串匹配算法。"><a href="#2-Rabin-Karp算法：-基于哈希的字符串匹配算法。" class="headerlink" title="2. **Rabin-Karp算法：**基于哈希的字符串匹配算法。"></a>2. **Rabin-Karp算法：**基于哈希的字符串匹配算法。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> prime = <span class="number">101</span>;  <span class="comment">// 选择一个较大的质数作为哈希函数的模</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算字符串的哈希值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculateHash</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        hash += (<span class="type">int</span>)str[i] * <span class="built_in">pow</span>(prime, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新哈希值，用于滑动窗口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recalculateHash</span><span class="params">(<span class="type">int</span> oldHash, <span class="type">char</span> oldChar, <span class="type">char</span> newChar, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (oldHash - oldChar + newChar * <span class="built_in">pow</span>(prime, length - <span class="number">1</span>)) * prime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rabin-Karp算法实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rabinKarpSearch</span><span class="params">(<span class="type">const</span> string&amp; pattern, <span class="type">const</span> string&amp; text)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> patternLength = pattern.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> textLength = text.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> patternHash = <span class="built_in">calculateHash</span>(pattern, patternLength);</span><br><span class="line">    <span class="type">int</span> textHash = <span class="built_in">calculateHash</span>(text, patternLength);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= textLength - patternLength; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (patternHash == textHash) &#123;</span><br><span class="line">            <span class="comment">// 如果哈希值相等，可能找到了匹配，进一步检查字符是否真的匹配</span></span><br><span class="line">            <span class="type">bool</span> match = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; patternLength; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pattern[j] != text[i + j]) &#123;</span><br><span class="line">                    match = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Pattern found at index &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新哈希值，准备检查下一个子串</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; textLength - patternLength) &#123;</span><br><span class="line">            textHash = <span class="built_in">recalculateHash</span>(textHash, text[i], text[i + patternLength], patternLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string text = <span class="string">&quot;ABABCABABABCABCABABC&quot;</span>;</span><br><span class="line">    string pattern = <span class="string">&quot;ABABC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Text: &quot;</span> &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pattern: &quot;</span> &lt;&lt; pattern &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rabinKarpSearch</span>(pattern, text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-有限自动机法："><a href="#3-有限自动机法：" class="headerlink" title="3. 有限自动机法："></a>3. <strong>有限自动机法：</strong></h3><p>有限状态自动机（Finite State Machine，FSM）是一种用于字符串匹配的有效算法。在这种算法中，模式字符串被预处理成一个有限状态自动机，然后利用该自动机在文本中进行匹配。以下是有限状态自动机字符串匹配算法（Aho-Corasick算法）的简要说明和C++实现：</p>
<h4 id="Aho-Corasick算法"><a href="#Aho-Corasick算法" class="headerlink" title="Aho-Corasick算法"></a>Aho-Corasick算法</h4><p>Aho-Corasick算法是一种多模式字符串匹配算法，它可以同时搜索多个模式串。</p>
<h5 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h5><ol>
<li>构建Trie树：将所有模式串构建成一个Trie树，每个节点表示一个字符，从根节点到叶子节点的路径表示一个模式串。</li>
<li>添加失败路径（Failure Function）：为Trie树中的每个节点添加失败路径，使得在匹配失败时能够跳转到Trie树中的其他位置。</li>
<li>匹配过程：在文本串中按顺序遍历字符，并根据Trie树进行匹配，利用失败路径实现快速跳转。</li>
</ol>
<h5 id="C-实现：-2"><a href="#C-实现：-2" class="headerlink" title="C++实现："></a>C++实现：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, TrieNode*&gt; children;</span><br><span class="line">    TrieNode* fail;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">fail</span>(<span class="literal">nullptr</span>), <span class="built_in">isEnd</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AhoCorasick</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AhoCorasick</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加模式串到Trie树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addPattern</span><span class="params">(<span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : pattern) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children.<span class="built_in">find</span>(c) == node-&gt;children.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                node-&gt;children[c] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建失败路径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildFailureFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;TrieNode*&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : root-&gt;children) &#123;</span><br><span class="line">            kv.second-&gt;fail = root;</span><br><span class="line">            q.<span class="built_in">push</span>(kv.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TrieNode* curr = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : curr-&gt;children) &#123;</span><br><span class="line">                <span class="type">char</span> symbol = kv.first;</span><br><span class="line">                TrieNode* child = kv.second;</span><br><span class="line">                q.<span class="built_in">push</span>(child);</span><br><span class="line"></span><br><span class="line">                TrieNode* failure = curr-&gt;fail;</span><br><span class="line">                <span class="keyword">while</span> (failure != <span class="literal">nullptr</span> &amp;&amp; failure-&gt;children.<span class="built_in">find</span>(symbol) == failure-&gt;children.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    failure = failure-&gt;fail;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (failure != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    child-&gt;fail = failure-&gt;children[symbol];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    child-&gt;fail = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在文本中匹配模式串</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">match</span><span class="params">(<span class="type">const</span> string&amp; text)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; text.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">char</span> c = text[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;children.<span class="built_in">find</span>(c) == node-&gt;children.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                node = node-&gt;fail;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node = root;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node-&gt;children[c];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 打印匹配的模式串</span></span><br><span class="line">                <span class="built_in">printMatches</span>(node, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印匹配的模式串</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printMatches</span><span class="params">(TrieNode* node, <span class="type">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;isEnd) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Pattern found at index &quot;</span> &lt;&lt; endIndex &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AhoCorasick ac;</span><br><span class="line">    ac.<span class="built_in">addPattern</span>(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">    ac.<span class="built_in">addPattern</span>(<span class="string">&quot;she&quot;</span>);</span><br><span class="line">    ac.<span class="built_in">addPattern</span>(<span class="string">&quot;his&quot;</span>);</span><br><span class="line">    ac.<span class="built_in">addPattern</span>(<span class="string">&quot;hers&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ac.<span class="built_in">buildFailureFunction</span>();</span><br><span class="line"></span><br><span class="line">    string text = <span class="string">&quot;ahishers&quot;</span>;</span><br><span class="line">    ac.<span class="built_in">match</span>(text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是一个简单的Aho-Corasick算法的实现，可以根据实际需要进行优化和扩展。</p>
<h3 id="4-KMP算法"><a href="#4-KMP算法" class="headerlink" title="4. KMP算法"></a>4. <strong>KMP算法</strong></h3><p>KMP（Knuth-Morris-Pratt）算法是一种高效的字符串匹配算法，它通过利用已经匹配过的信息来避免不必要的字符比较。以下是KMP算法的简要说明和C++实现：</p>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><h5 id="基本思想：-1"><a href="#基本思想：-1" class="headerlink" title="基本思想："></a>基本思想：</h5><ol>
<li>构建部分匹配表（Partial Match Table，PMT）：PMT记录了每个前缀的最长相等的真前缀和真后缀的长度。</li>
<li>利用PMT进行匹配：在匹配过程中，当发生不匹配时，根据PMT找到一个合适的位置跳过一部分字符。</li>
</ol>
<h5 id="C-实现：-3"><a href="#C-实现：-3" class="headerlink" title="C++实现："></a>C++实现：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建部分匹配表（Partial Match Table）</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buildPMT</span><span class="params">(<span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> patternLength = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pmt</span><span class="params">(patternLength, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; patternLength) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern[i] == pattern[length]) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            pmt[i] = length;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (length != <span class="number">0</span>) &#123;</span><br><span class="line">                length = pmt[length - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pmt[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pmt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP算法实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmpSearch</span><span class="params">(<span class="type">const</span> string&amp; pattern, <span class="type">const</span> string&amp; text)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> patternLength = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> textLength = text.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建部分匹配表</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pmt = <span class="built_in">buildPMT</span>(pattern);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">// 索引用于遍历text</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">// 索引用于遍历pattern</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; textLength) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern[j] == text[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == patternLength) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Pattern found at index &quot;</span> &lt;&lt; i - j &lt;&lt; endl;</span><br><span class="line">            j = pmt[j - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; textLength &amp;&amp; pattern[j] != text[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                j = pmt[j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string text = <span class="string">&quot;ABABDABACDABABCABAB&quot;</span>;</span><br><span class="line">    string pattern = <span class="string">&quot;ABABC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Text: &quot;</span> &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pattern: &quot;</span> &lt;&lt; pattern &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">kmpSearch</span>(pattern, text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是一个简单的KMP算法的实现示例，用于在文本中查找模式串的出现。这个算法通过构建部分匹配表来提高匹配效率。在实际应用中，可以根据需要进行适当的优化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 教材实现：</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">computePrefix</span><span class="params">(<span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; pattern[k] != pattern[i]) &#123;</span><br><span class="line">            k = pi[k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pattern[k] == pattern[i])&#123;</span><br><span class="line">            k = k + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pi[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> KMP-<span class="built_in">MATCHER</span>()</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://bush-cn.github.io">bush Wu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://bush-cn.github.io/2025/07/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E5%9B%9E%E9%A1%BE/">http://bush-cn.github.io/2025/07/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E5%9B%9E%E9%A1%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://bush-cn.github.io" target="_blank">bush's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/07/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="数据库复习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">数据库复习笔记</div></div><div class="info-2"><div class="info-item-1">数据库相关概念 数据 &amp; 信息：数据+解释&#x3D;信息 数据管理：数据存储&#x2F;维护&#x2F;查询&#x2F;安全等 数据库：是存储介质上的一个&#x2F;组文件，不能直接编辑，需通过数据库管理系统来操作 数据库管理系统DBMS：管理数据库的一种大型复杂软件系统 数据库系统DMS：由应用程序、数据库、数据库管理系统和用户组成  ER模型ER 图 全称是 Entity Relationship Diagram（实体联系图），提供了表示实体类型、属性和联系的方法。 ER 图由下面 3 个要素组成：  实体：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。在 ER 图中，实体使用矩形框表示。 属性：即某个实体拥有的属性，属性用来描述组成实体的要素。在 ER 图中，属性使用椭圆形表示。 联系：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。  关系模型 元组：元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">bush Wu</div><div class="author-info-description">北京航空航天大学21系软件工程专业22级本科生。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/bush-cn"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/bush-cn" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:bush_wu@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-text">第2章 算法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">2.1 插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-text">2.2 分析算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E8%AE%BE%E8%AE%A1%E7%AE%97%E6%B3%95"><span class="toc-text">2.3 设计算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95%EF%BC%9A"><span class="toc-text">分治法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="toc-text">归并排序：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-text">递归算法的时间复杂度分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF"><span class="toc-text">第3章 函数的增长</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%B8%90%E8%BF%9B%E8%AE%B0%E5%8F%B7"><span class="toc-text">3.1 渐进记号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%B8%90%E8%BF%9B%E8%AE%B0%E5%8F%B7%E5%8F%8A%E5%90%AB%E4%B9%89"><span class="toc-text">算法的渐进记号及含义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5"><span class="toc-text">第4章 分治策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">第6章 堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">堆、堆排序算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">第7章 快速排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">第15章 动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98"><span class="toc-text">经典动态规划问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-%E6%91%8A%E8%BF%98%E5%88%86%E6%9E%90"><span class="toc-text">第17章 摊还分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%91%8A%E8%BF%98%E5%88%86%E6%9E%90%EF%BC%9F"><span class="toc-text">什么是摊还分析？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%81%9A%E5%90%88%E5%88%86%E6%9E%90"><span class="toc-text">1. 聚合分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A0%B8%E7%AE%97%E6%B3%95%EF%BC%88accounting-method%EF%BC%89"><span class="toc-text">2. 核算法（accounting method）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8A%BF%E8%83%BD%E6%B3%95"><span class="toc-text">3. 势能法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC22%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%9B%BE%E7%AE%97%E6%B3%95"><span class="toc-text">第22章 基本的图算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">图的表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E3%80%81%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">广度优先搜索、深度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E7%82%B9"><span class="toc-text">算法特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E5%AE%9E%E7%8E%B0%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">DFS实现拓扑排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC23%E7%AB%A0-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">第23章 最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">一、最小生成树是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-text">二、最小生成树的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Kurskal%E7%AE%97%E6%B3%95"><span class="toc-text">1. Kurskal算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Prim%E7%AE%97%E6%B3%95"><span class="toc-text">2. Prim算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-text">Prim算法步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95C-%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">Prim算法C++实现：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC24%E7%AB%A0-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">第24章 单源最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%BE%E5%BC%9B%E6%93%8D%E4%BD%9C%EF%BC%88relaxation%EF%BC%89"><span class="toc-text">松弛操作（relaxation）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bellman-Ford%E7%AE%97%E6%B3%95"><span class="toc-text">Bellman-Ford算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bellman-Ford%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%9A"><span class="toc-text">Bellman-Ford算法简介：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">C++实现：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-text">Dijkstra算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dijkstra%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%9A"><span class="toc-text">Dijkstra算法简介：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%AE%9E%E7%8E%B0%EF%BC%9A-1"><span class="toc-text">C++实现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F"><span class="toc-text">链式前向星</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC25%E7%AB%A0-%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E5%AF%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-text">第25章 所有节点对的最短路径问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Floyd-Warshall%E7%AE%97%E6%B3%95"><span class="toc-text">Floyd-Warshall算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-text">算法步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E5%9B%BE%EF%BC%9A"><span class="toc-text">用邻接矩阵表示图：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C5-%E4%B8%8A%E6%9C%BAA%E9%A2%98%EF%BC%9A%EF%BC%88%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%BE%93%E5%87%BA%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%89"><span class="toc-text">C5 上机A题：（下面的代码还可以输出最短路径）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC26%E7%AB%A0-%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-text">第26章 最大流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EK%EF%BC%88Edmond%E2%80%94Karp%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-text">EK（Edmond—Karp）算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ford-Fulkerson%E7%AE%97%E6%B3%95"><span class="toc-text">Ford-Fulkerson算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dinic%E7%AE%97%E6%B3%95"><span class="toc-text">Dinic算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%E9%80%89%E7%BC%96"><span class="toc-text">算法问题选编</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95"><span class="toc-text">计算几何</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF"><span class="toc-text">基础模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E4%B8%8E%E5%90%91%E9%87%8F"><span class="toc-text">点与向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E4%B8%8E%E7%BA%BF"><span class="toc-text">点与线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BE%B9%E5%BD%A2"><span class="toc-text">多边形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%86"><span class="toc-text">圆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%87%B8%E5%8C%85"><span class="toc-text">寻找凸包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Graham%E6%89%AB%E6%8F%8F%E6%B3%95"><span class="toc-text">Graham扫描法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Andrew%E7%AE%97%E6%B3%95"><span class="toc-text">Andrew算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="toc-text">多项式与快速傅里叶变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="toc-text">多项式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%88DFT%EF%BC%89"><span class="toc-text">离散傅里叶变换（DFT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%88FFT%EF%BC%89"><span class="toc-text">快速傅里叶变换（FFT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FFT%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95"><span class="toc-text">FFT与多项式乘法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D"><span class="toc-text">字符串匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%B4%E7%B4%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%88Naive-String-Matching%EF%BC%89%EF%BC%9A"><span class="toc-text">1.朴素字符串匹配算法（Naive String Matching）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Rabin-Karp%E7%AE%97%E6%B3%95%EF%BC%9A-%E5%9F%BA%E4%BA%8E%E5%93%88%E5%B8%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E3%80%82"><span class="toc-text">2. **Rabin-Karp算法：**基于哈希的字符串匹配算法。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E6%B3%95%EF%BC%9A"><span class="toc-text">3. 有限自动机法：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Aho-Corasick%E7%AE%97%E6%B3%95"><span class="toc-text">Aho-Corasick算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-text">基本思想：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E5%AE%9E%E7%8E%B0%EF%BC%9A-2"><span class="toc-text">C++实现：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-KMP%E7%AE%97%E6%B3%95"><span class="toc-text">4. KMP算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="toc-text">KMP算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-1"><span class="toc-text">基本思想：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E5%AE%9E%E7%8E%B0%EF%BC%9A-3"><span class="toc-text">C++实现：</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E5%9B%9E%E9%A1%BE/" title="算法导论笔记整理回顾">算法导论笔记整理回顾</a><time datetime="2025-07-10T14:25:51.000Z" title="发表于 2025-07-10 22:25:51">2025-07-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="数据库复习笔记">数据库复习笔记</a><time datetime="2025-07-10T09:07:26.000Z" title="发表于 2025-07-10 17:07:26">2025-07-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/04/Java%20SE%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Java SE复习笔记">Java SE复习笔记</a><time datetime="2025-07-04T08:54:32.000Z" title="发表于 2025-07-04 16:54:32">2025-07-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/13/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="跨域问题及解决方案">跨域问题及解决方案</a><time datetime="2025-06-13T04:24:28.000Z" title="发表于 2025-06-13 12:24:28">2025-06-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/13/WebSocket%E4%BD%BF%E7%94%A8/" title="WebSocket使用">WebSocket使用</a><time datetime="2025-06-13T04:23:13.000Z" title="发表于 2025-06-13 12:23:13">2025-06-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By bush Wu</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>