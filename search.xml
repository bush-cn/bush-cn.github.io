<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图神经网络论文阅读</title>
      <link href="/2025/03/02/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
      <url>/2025/03/02/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Graph-Attention-Networks"><a href="#Graph-Attention-Networks" class="headerlink" title="Graph Attention Networks"></a>Graph Attention Networks</h1><h3 id="1-研究背景与动机"><a href="#1-研究背景与动机" class="headerlink" title="1. 研究背景与动机"></a>1. 研究背景与动机</h3><ul><li><strong>图数据的挑战</strong>：传统的卷积神经网络（CNNs）适用于规则网格数据（如图像），但很多实际任务（如社交网络、生物网络等）中的数据以图的形式存在，结构不规则。</li><li>现有方法的不足：<ul><li><strong>谱方法</strong>：基于图拉普拉斯特征分解，<strong>计算量大</strong>且<strong>依赖于特定图结构</strong>，难以泛化到新图。</li><li><strong>非谱方法</strong>（MoNet, GraphSAGE)：直接在图上定义卷积操作，但难以统一处理邻居数目不固定的问题。</li></ul></li><li><strong>自注意力机制启发</strong>：近年来，自注意力在序列模型（如机器翻译）中表现突出，启发作者将自注意力思想应用到图数据中，更灵活地聚合邻居信息，以完成图数据的节点分类任务。</li><li>自注意力结构的特点：<ol><li>计算高效，所有运算可以并行化</li><li>通过指定任意的邻节点权重，可以处理节点度数不同的图</li><li>模型可直接应用于归纳学习任务，可以泛化到模型从未见过的图</li></ol></li></ul><hr><h3 id="2-Graph-Attention-Networks（GAT）方法简介"><a href="#2-Graph-Attention-Networks（GAT）方法简介" class="headerlink" title="2. Graph Attention Networks（GAT）方法简介"></a>2. Graph Attention Networks（GAT）方法简介</h3><ul><li><strong>核心思想</strong>：通过自注意力机制，让每个节点在聚合自身邻居特征时，根据邻居的重要性分配不同权重，从而获得更有效的节点表示。</li><li><strong>输入与输出</strong>：输入为节点特征集合 <strong>h</strong>，输出为更新后的节点特征 <strong>h</strong>′，支持特征维度变换。</li><li><strong>Graph Attention Layer的关键步骤</strong>：<ol><li><strong>线性变换</strong>：通过权重矩阵 <strong>W</strong> 对所有节点的输入特征进行同样的线性变换，得到新的特征表示。</li><li><strong>计算注意力系数</strong>：<ul><li>对于每个节点 i 及其一阶邻居 j（含i），利用一个共享的注意力机制（单层前馈网络加上 LeakyReLU 激活）计算原始的注意力分数 $e_{ij}$。</li><li>对每个节点的所有邻居分数进行 softmax 归一化，得到归一化的注意力系数 $\alpha_{ij}$。</li></ul></li><li><strong>特征聚合</strong>：使用归一化后的注意力系数，对邻居节点的特征进行加权求和，并经过sigmoid非线性激活，生成新的节点表示。</li><li><strong>多头注意力</strong>：通过并行执行多个独立的注意力机制（即多头注意力），提升模型的稳定性与表达能力。最后在输出层可选择拼接（中间层）或平均（输出层）多头结果。</li></ol></li><li><strong>优势</strong>：<ul><li><strong>计算高效</strong>：无需矩阵分解或全局图结构信息，计算复杂度与GCN相当（O(∣V∣FF′+∣E∣F′) ，支持并行化。</li><li><strong>动态权重分配</strong>：通过注意力机制为不同邻居分配不同权重，提升模型表达能力。</li><li><strong>灵活性强</strong>：不依赖于图的全局结构，可处理有向图、不同大小的邻居集合，且适用于归纳学习（处理训练时未见过的新图）。</li><li><strong>可解释性</strong>：注意力系数反映了模型在聚合邻居信息时对各邻居的关注程度，有助于理解模型的决策过程。</li></ul></li></ul><hr><h3 id="3-实验设置与结果"><a href="#3-实验设置与结果" class="headerlink" title="3. 实验设置与结果"></a>3. 实验设置与结果</h3><ul><li><strong>数据集</strong>：<ul><li><strong>转导任务</strong>：使用 Cora、Citeseer 和 Pubmed 三个标准引文网络数据集，节点特征为文档的词袋表示，每个节点对应一个类别。</li><li><strong>归纳任务</strong>：使用蛋白质相互作用（PPI）数据集，该数据集包含多个不同的图，测试时的图完全未在训练中出现。</li></ul></li><li><strong>模型结构</strong>：<ul><li><strong>转导任务</strong>：采用两层 GAT 模型，第一层使用多头注意力（例如 8 个头）提取中间特征，第二层用于分类，配合 dropout 和 L2 正则化。</li><li><strong>归纳任务</strong>：采用三层 GAT 模型，并利用跳跃连接来缓解深层模型训练中的信息衰减问题。</li></ul></li><li><strong>实验结果</strong>：<ul><li>在转导任务上，GAT 在 Cora、Citeseer 和 Pubmed 数据集上均超过或匹配了如 GCN、Chebyshev 滤波器和 MoNet 等多种方法的表现。</li><li>在归纳任务（PPI 数据集）上，GAT 显著提升了微平均 F1 得分，验证了其在新图环境下的强泛化能力，同时也证明了赋予邻居不同权重的重要性。</li></ul></li></ul><hr><h3 id="4-结论与未来工作"><a href="#4-结论与未来工作" class="headerlink" title="4. 结论与未来工作"></a>4. 结论与未来工作</h3><ul><li><strong>主要贡献</strong>：<ul><li>提出了基于自注意力机制的图神经网络架构，能够灵活高效地处理图结构数据。</li><li>在不需要事先知道全局图结构的前提下，实现了对不同大小邻居集合的有效处理，并适用于归纳学习。</li><li>在多个标准数据集上达到了最先进的性能，验证了模型的有效性和广泛适用性。</li></ul></li><li><strong>未来研究方向</strong>：<ul><li>扩展模型到图分类任务。</li><li>探索如何更高效地处理大规模图数据和提高批处理能力。</li><li>深入利用注意力机制进行模型解释，并尝试整合边特征信息以处理更复杂的图数据。</li></ul></li></ul><h1 id="Deep-Graph-Infomax-DGI"><a href="#Deep-Graph-Infomax-DGI" class="headerlink" title="Deep Graph Infomax (DGI)"></a>Deep Graph Infomax (DGI)</h1><h3 id="1-研究背景与动机-1"><a href="#1-研究背景与动机-1" class="headerlink" title="1. 研究背景与动机"></a>1. 研究背景与动机</h3><ul><li><strong>图数据的挑战</strong>：传统的图神经网络（如GCN）多采用监督学习，而在许多实际场景下图数据往往没有标注信息。</li><li><strong>无监督学习的需求</strong>：现有方法常基于随机游走或邻近重构目标，但这类方法可能过分强调局部邻接信息，忽略了全局结构特征。</li><li><strong>核心思想</strong>：如何在不依赖标签的情况下，从图结构数据中学习到既保留局部细节又能反映全局结构的节点表示。</li></ul><hr><h3 id="2-方法概述：Deep-Graph-Infomax-DGI"><a href="#2-方法概述：Deep-Graph-Infomax-DGI" class="headerlink" title="2. 方法概述：Deep Graph Infomax (DGI)"></a>2. 方法概述：Deep Graph Infomax (DGI)</h3><ul><li><strong>局部与全局互信息最大化</strong>：DGI 的主要思想是利用互信息最大化，通过对比图中局部（即节点及其邻域）表示与图整体全局摘要之间的关系，促使模型学习到富有全局结构信息的节点表示。</li><li>方法流程：<ol><li><strong>编码器（Encoder）</strong>：采用图卷积网络（GCN）或其它图神经网络模型，从输入的节点特征和邻接矩阵中提取局部“补丁”表示。</li><li><strong>读取函数（Readout Function）</strong>：将所有节点的局部表示聚合成一个全局摘要向量，反映整个图的全局信息。</li><li><strong>判别器（Discriminator）</strong>：通过一个二分类器对比真实的局部-全局配对与负样本配对（通过对输入数据进行随机扰动或负采样获得），采用二元交叉熵损失函数进行训练，进而最大化局部表示与全局摘要之间的互信息。</li></ol></li></ul><hr><h3 id="3-理论分析"><a href="#3-理论分析" class="headerlink" title="3. 理论分析"></a>3. 理论分析</h3><ul><li><strong>理论证明</strong>：论文提供了一系列引理和定理，证明了在局部与全局表示间最小化判别器的分类错误能够上界地最大化这两者之间的互信息。</li><li><strong>互信息与最优判别器</strong>：当读取函数具备单射性（injective）时，全局摘要能够捕获输入图的所有信息，进而使得模型在理论上达到最优互信息。</li></ul><hr><h3 id="4-实验与结果"><a href="#4-实验与结果" class="headerlink" title="4. 实验与结果"></a>4. 实验与结果</h3><ul><li>任务设置：<ul><li><strong>转导式任务</strong>：在 Cora、Citeseer 和 Pubmed 等引用网络上进行节点分类实验。</li><li><strong>归纳式任务</strong>：在 Reddit 社交网络和 PPI 蛋白质相互作用网络上进行归纳式节点分类实验。</li></ul></li><li>结果表现：<ul><li>在转导式任务上，DGI 的表现超越了许多无监督方法，并在某些数据集上甚至与监督学习的 GCN 模型竞争。</li><li>在归纳式任务中，DGI 同样展示了优越的性能，证明了其在大规模和多图场景下的适用性。</li></ul></li><li><strong>鲁棒性</strong>：DGI 对负样本生成（如特征打乱或邻接矩阵扰动）的策略具有较高的鲁棒性，能够在不同负采样方式下保持良好性能。</li></ul><hr><h3 id="5-定性分析与结论"><a href="#5-定性分析与结论" class="headerlink" title="5. 定性分析与结论"></a>5. 定性分析与结论</h3><ul><li><strong>可视化分析</strong>：通过 t-SNE 等技术对节点表示进行可视化，结果显示经过 DGI 学习的表示在低维空间中形成了明显的类别聚类结构。</li><li><strong>嵌入维度分析</strong>：研究发现，部分嵌入维度在区分正负样本时起到关键作用，而其余维度则主要编码了有用的节点特征信息；即便移除部分维度，分类性能仍能保持较高水平。</li><li><strong>总结</strong>：DGI 提出了一种全新的图无监督学习方法，通过局部与全局信息的对比，有效捕捉了图数据的结构特征，并在多个标准数据集上验证了其优异的性能，为无监督图表示学习提供了新的思路和方向。</li></ul><hr><p>整体而言，DGI 的创新点在于利用互信息最大化来桥接局部节点表示与全局图信息之间的联系，从而在无监督的情形下学习到高质量的节点表示，为后续的图任务（如节点分类、社区检测等）提供了坚实的基础。</p><h1 id="Semi-Supervised-Classification-with-Graph-Convolutional-Networks"><a href="#Semi-Supervised-Classification-with-Graph-Convolutional-Networks" class="headerlink" title="Semi-Supervised Classification with Graph Convolutional Networks"></a>Semi-Supervised Classification with Graph Convolutional Networks</h1><h3 id="1-研究背景与动机-2"><a href="#1-研究背景与动机-2" class="headerlink" title="1. 研究背景与动机"></a>1. <strong>研究背景与动机</strong></h3><p> 本文针对图结构数据中的节点分类问题，提出了一种半监督学习方法。传统方法往往依赖于显式的图拉普拉斯正则化，但这在实际应用中可能会受到图中边仅表示节点相似性的限制。作者希望利用图结构和节点特征的联合信息，通过神经网络直接对图进行建模，从而提高分类效果。</p><h3 id="2-方法原理与模型构建"><a href="#2-方法原理与模型构建" class="headerlink" title="2. 方法原理与模型构建"></a>2. <strong>方法原理与模型构建</strong></h3><ul><li><p><strong>谱图卷积近似</strong>：论文首先从谱图卷积出发，利用切比雪夫多项式对卷积操作进行近似，从而实现局部化滤波。通过限制多项式的阶数，最终得到一阶近似形式。</p></li><li><p><strong>层级传播规则</strong>：进一步简化后，提出了基于重新归一化技巧的传播规则，即</p><p>H(l+1) &#x3D; σ( D̃^(–1&#x2F;2) Ã D̃^(–1&#x2F;2) H(l) W(l) )</p><p>其中 Ã &#x3D; A + Iₙ，D̃ 是 Ã 的度矩阵，这样设计既考虑了节点自连接，又解决了深层网络中可能出现的数值不稳定问题。</p></li></ul><h3 id="3-半监督节点分类框架"><a href="#3-半监督节点分类框架" class="headerlink" title="3. 半监督节点分类框架"></a>3. <strong>半监督节点分类框架</strong></h3><ul><li><strong>网络架构</strong>：以两层GCN为例，第一层将输入特征与图结构信息融合后生成隐藏表示，第二层再通过 softmax 输出各节点的分类概率。</li><li><strong>损失函数</strong>：采用交叉熵损失，仅在少量标记节点上进行监督训练，从而利用整个图结构信息进行传播和特征提取。</li><li><strong>训练方式</strong>：由于数据集（如引用网络）的规模适中，可采用全批量梯度下降，并通过 dropout 等技术防止过拟合。</li></ul><h3 id="4-实验与结果-1"><a href="#4-实验与结果-1" class="headerlink" title="4. 实验与结果"></a>4. <strong>实验与结果</strong></h3><ul><li>在 Citeseer、Cora、Pubmed 以及知识图谱 NELL 数据集上进行实验，结果显示该模型在分类准确率和计算效率上均明显优于传统方法，如标签传播、深度嵌入、Planetoid 等。</li><li>另外，实验还分析了不同层数和传播模型对性能的影响，证明了重新归一化传播规则在性能和稳定性上的优势。</li></ul><h3 id="5-讨论与未来工作"><a href="#5-讨论与未来工作" class="headerlink" title="5. 讨论与未来工作"></a>5. <strong>讨论与未来工作</strong></h3><ul><li>讨论部分分析了GCN在捕捉局部结构信息方面的优势，并指出模型在处理大规模图数据时内存消耗较大，未来可以探索基于小批量随机梯度下降的扩展方法。</li><li>论文还探讨了与 Weisfeiler-Lehman 算法的关系，说明即使是未经过训练的GCN也能作为强大的特征提取器。</li></ul><h3 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. <strong>结论</strong></h3><p>文章提出的GCN模型通过简化谱卷积操作，构建了高效且易扩展的半监督分类框架，成功地将图结构信息与节点特征结合起来，不仅提升了分类准确率，同时显著降低了计算复杂度，为后续图神经网络的发展奠定了基础。</p>]]></content>
      
      
      <categories>
          
          <category> 图神经网络研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatDev总结笔记</title>
      <link href="/2025/02/22/ChatDev%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/02/22/ChatDev%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="基于大模型智能体的虚拟化软件开发团队"><a href="#基于大模型智能体的虚拟化软件开发团队" class="headerlink" title="基于大模型智能体的虚拟化软件开发团队"></a>基于大模型智能体的虚拟化软件开发团队</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>软件开发过程涉及到需求分析、总体设计、详细设计、编码和测试等多种活动和多种角色的开发者。随着大模型技术的快速发展，很多软件开发活动都可以通过自动化和智能化方式来实现。本项目利用<strong>大模型</strong>和<strong>多智能体</strong>技术来实现智能化软件开发全过程，通过agent模拟不同角色的软件开发人员，通过agent之间的协同完成复杂的软件开发过程。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://openreview.net/pdf?id=yW0AZ5wPji">https://openreview.net/pdf?id=yW0AZ5wPji</a></p><h1 id="ChatDev论文总结"><a href="#ChatDev论文总结" class="headerlink" title="ChatDev论文总结"></a>ChatDev论文总结</h1><h2 id="What-is-ChatDev"><a href="#What-is-ChatDev" class="headerlink" title="What is ChatDev?"></a>What is ChatDev?</h2><p>ChatDev, a <em>chat</em>-powered software-<em>dev</em>elopment framework integrating multiple “software agents” for active involvement in three core phases of the software lifecycle: design, coding, and testing.</p><h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><h3 id="1-chat-chain"><a href="#1-chat-chain" class="headerlink" title="1. chat chain"></a>1. chat chain</h3><p>ChatDev introduces <em>chat chain</em> to further break down each phase into smaller and manageable subtasks</p><ul><li>waterfall model -&gt; chat chain</li><li>chat chain -&gt; sequential phases</li><li>phase -&gt; sequential subtasks<ul><li>coding phase -&gt; code writing + completion</li><li>testing phase -&gt; code review (static testing) + system testing (dynamic testing)</li></ul></li><li>subtask -&gt; extraction of solutions -&gt; dialogue of Instructor &amp; Assistant</li><li>dialogue -&gt; loop -&gt; instructor instructing while assistant responding</li></ul><hr><ul><li><strong>Agentization</strong>: inception prompting mechanism</li><li><strong>Memory</strong>: <em>short-term memory</em> &#x2F; <em>long-term memory</em></li></ul><h3 id="2-communicative-dehallucination"><a href="#2-communicative-dehallucination" class="headerlink" title="2. communicative dehallucination"></a>2. communicative dehallucination</h3><p>ChatDev devise <em>communicative dehallucination</em> to alleviate unexpected hallucinations, which <u>encourages the assistant to actively seek more detailed suggestions from the instructor before delivering a formal response.</u></p><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><ul><li>Baselines: GPT-Engineer(fundamental), MetaGPT(advanced)</li><li>Datasets: SRDD</li><li>Metrics: Completeness + Executability + Consistency &#x3D; Quality</li></ul><p>The most important: multiple agents and roles</p><h2 id="Limitations-Solutions"><a href="#Limitations-Solutions" class="headerlink" title="Limitations &amp; Solutions"></a><strong>Limitations</strong> &amp; Solutions</h2><ol><li>Firstly, the capabilities of autonomous agents in software production might be overestimated: <u>it is crucial to clearly define detailed software requirements.</u></li><li>Secondly, unlike traditional function level code generation, automating the evaluation of general-purpose software is highly complex: <u>consider additional factors such as functionalities, robustness, safety, and user-friendliness.</u></li><li>Thirdly, compared to single-agent approaches, multiple agents require more tokens and time, increasing computational demands and environmental impact: <u>enhance agent capabilities with fewer interactions</u></li></ol><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><ul><li>针对论文提到的第二点不足，利用多模态大模型添加用户这一agent，提供对应用的界面、操作、使用等的反馈，作为增加的评判软件质量的标准并加以迭代</li></ul>]]></content>
      
      
      <categories>
          
          <category> 虚拟化软件开发团队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatDev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读-Memory Management Test-Case Generation of C Programs using Bounded Model Checking</title>
      <link href="/2025/01/19/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Memory-Management-Test-Case-Generation-of-C-Programs-using-Bounded-Model-Checking/"/>
      <url>/2025/01/19/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Memory-Management-Test-Case-Generation-of-C-Programs-using-Bounded-Model-Checking/</url>
      
        <content type="html"><![CDATA[<p>论文链接：<a href="https://link.springer.com/chapter/10.1007/978-3-319-22969-0_18">Memory Management Test-Case Generation of C Programs Using Bounded Model Checking | SpringerLink</a></p><h2 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h2><ul><li>Efficient SMT-Based Bounded Model Checking（<strong>ESBMC</strong>，原文：<a href="https://ieeexplore.ieee.org/abstract/document/5928354">SMT-Based Bounded Model Checking for Embedded ANSI-C Software | IEEE Journals &amp; Magazine | IEEE Xplore</a>）：ESBMC以C语言源程序为输入，以一系列“Claim”为输出，这些Claim指明了该程序的安全属性，即可能出现内存错误的地方，包括检查与算术不足和溢出、零除法、越界索引、指针安全、死锁和数据竞争相关的属性。在ESBMC中，验证过程是完全自动化的，不需要用户使用前条件或后条件注释程序。</li><li><strong>Safety Properties</strong>：论文定义了“安全属性”的概念。如果一个系统不能满足一个安全属性，那么就存在一个有限的执行来显示这个失败，使用断言将对应的错误复现，就可以生成针对性的testcase。</li><li><strong>CUnit</strong>（<a href="https://cunit.sourceforge.net/doc/introduction.html#usage">CUnit - Introduction (sourceforge.net)</a>）：测试框架。CUnit支持更好的组织和代码重用，以更有效的方式创建单元测试。其支持完整的C语言书写，并提供了一组用于测试逻辑条件的断言。</li></ul><h2 id="方法过程"><a href="#方法过程" class="headerlink" title="方法过程"></a>方法过程</h2><p><img src="/../assets/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Memory-Management-Test-Case-Generation-of-C-Programs-using-Bounded-Model-Checking/image-20250121204757596.png" alt="image-20250121204757596"></p><ol><li>用ESBMC识别安全属性，得到Claims。</li><li>从安全属性中提取信息。即从四个方面分析Claim：identification、comments、line number、property。</li><li>翻译安全属性。即将Claims翻译成C程序中的断言代码。</li><li>内存跟踪分析。使用Pycparser（<a href="https://github.com/eliben/pycparser">eliben&#x2F;pycparser: :snake: Complete C99 parser in pure Python (github.com)</a>）生成C语言的语法树AST，再根据AST进行分析，目的是确保指针安全性。分为两个阶段：<ol><li>识别和跟踪所分析的源代码中的变量，以及变量的操作和分配。对于非指针，直接进行变量映射；对于指针，执行对象映射，跟踪指针的运算、分配、回收。</li><li>对源代码的特定功能，用于根据程序执行监视内存地址和这些变量指向的地址。插入函数<code>mark_map_MF</code>，改函数以前阶段映射的数据为输入，维护一个包含内存地址、指向的地址、作用域范围、标识符、行数的列表，最后生成Map2Check提供的断言函数。</li></ol></li><li>根据ESBMC和Map2Check生成的断言生成testcase，包括原生C语言的断言和测试框架的断言函数。</li><li>测试实施，包括两个测试模型。</li><li>执行测试。</li></ol><h2 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h2><ul><li>论文里变量的<code>dynamic</code>是什么意思？</li><li>两个测试模型没看懂🤯</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++单元测试生成 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++单测生成调研</title>
      <link href="/2025/01/12/C-%E5%8D%95%E6%B5%8B%E7%94%9F%E6%88%90%E8%B0%83%E7%A0%94/"/>
      <url>/2025/01/12/C-%E5%8D%95%E6%B5%8B%E7%94%9F%E6%88%90%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="C-单测生成调研"><a href="#C-单测生成调研" class="headerlink" title="C++单测生成调研"></a>C++单测生成调研</h1><p>调研C++单元测试生成在Undefined Behavior、内存、指针、Error Handling四个方面的特点、挑战及现状，据此考虑主要根据哪些特点来迁移已有模型。</p><h2 id="1-Undefined-Behavior"><a href="#1-Undefined-Behavior" class="headerlink" title="1. Undefined Behavior"></a>1. Undefined Behavior</h2><p>未定义行为（<strong>Undefined Behavior</strong>, UB）是编程语言规范中未对某些构造强制规定行为的部分。它为编译器优化提供了自由，但可能导致程序在不同平台上的行为不一致。<u>C&#x2F;C++比Java具有更多UB</u>。</p><blockquote><p>A difficult trade-off in the design of a systems programming language is how much freedom to grant the compiler to generate efficient code for a target instruction set. On one hand, programmers prefer that a program behaves identically on all hardware platforms. On the other hand, programmers want to get high performance by allowing the compiler to exploit specific properties of the instruction set of their hardware platform. A technique that languages use to make this trade-off is labeling certain program constructs as <strong>undefined behavior</strong>, for which the language imposes no requirements on <u>compiler</u> writers.</p><p>From: [Kaashoek_Undefined behavior.pdf (mit.edu)](<a href="https://dspace.mit.edu/bitstream/handle/1721.1/86949/Kaashoek_Undefined">https://dspace.mit.edu/bitstream/handle/1721.1/86949/Kaashoek_Undefined</a> behavior.pdf)</p></blockquote><p>Example:</p><ul><li>division by zero</li><li>oversized shift</li><li>signed integer overflow</li><li>out-of-bounds pointer</li><li>null pointer dereference</li><li>type-punned pointer dereference（类型转换指针解引用）</li><li>uninitialized read</li></ul><hr><p>未找到针对性的测试用例生成的论文。</p><h2 id="2-内存"><a href="#2-内存" class="headerlink" title="2. 内存"></a>2. 内存</h2><p><a href="https://arxiv.org/pdf/1710.06125">EffectiveSan: Type and Memory Error Detection using Dynamically Typed C&#x2F;C++ (arxiv.org)</a></p><p>C&#x2F;C++类型系统是静态且弱的，会出现<strong>类型错误</strong>（例如错误的类型转换）和<strong>内存错误</strong>（例如数组越界、使用释放后的内存等）。</p><p>提出了<strong>动态类型</strong> C&#x2F;C++ 的概念。要点如下：</p><ol><li>每个分配的对象都会绑定<strong>动态类型信息</strong>（称为“有效类型”），用于描述其类型、边界和子对象布局。</li><li>在运行时检查指针使用是否合法，包括指针的类型正确性和边界正确性。</li><li>EffectiveSan 支持复杂对象的子对象布局：涵盖嵌套结构体、类的继承、联合等。</li></ol><hr><p><a href="https://d1wqtxts1xzle7.cloudfront.net/76763038/sefm2015-libre.pdf?1639840124=&response-content-disposition=inline;+filename=Memory_Management_Test_Case_Generation_o.pdf&Expires=1736853826&Signature=VM6--U4EKTgiW1nLN-1mQXQkfkmonBSz5V5MVphAvpKUSmYedrxd6oAj54WBdfZdr~XLyU9oMYH6zq6MHsGnN1LpFcS7aiVs9RMDuC00b8UmBZJtydQXjWVUpW2pnJKtCtL5Fwj0TptHUrzgVudnBaUGAdPuEg7y1GAMPcR1q~OZy0mcSXYNSW2-S21MESUWGVWSmkohHiUEjYmrYYzxxUgNmR2FuzZIm9ktaiin~ZMqWX1R3ZyrhyOYivnoLmV542tU0odxKT3VyI5ITzZ9IJ-RqT8M1bvAtXuf6x2YMjP3CY~RBgJpmfqlwWGKRhje266VLoYnrpj3AXA4Vb10gQ__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA">sefm2015-libre.pdf (d1wqtxts1xzle7.cloudfront.net)</a></p><p>名为Map2Check的工具。提供了一种改进的<strong>单元测试生成</strong>方法，结合<strong>ESBMC模型检查器</strong>和动态分析技术，显著提高了<strong>内存管理</strong>缺陷检测的精度。</p><ol><li>识别安全属性，利用ESBMC提取潜在的程序缺陷。</li><li>从安全属性中提取信息，如位置和潜在缺陷。</li><li>将安全属性翻译为C代码中的<strong>断言</strong>。</li><li>内存跟踪，记录程序执行期间内存地址的使用情况。</li><li>在源代码中添加<strong>断言</strong>以验证安全属性。</li><li>实现测试用例，通过CUnit或原生C断言执行测试。</li><li>执行测试并分析结果。</li></ol><h2 id="3-指针"><a href="#3-指针" class="headerlink" title="3. 指针"></a>3. 指针</h2><p><a href="https://www.sciencedirect.com/science/article/pii/S0950584922000027">An automated test data generation method for void pointers and function pointers in C&#x2F;C++ libraries and embedded projects - ScienceDirect</a></p><p>介绍了一种名为VFP（Void and Function Pointers test data generation）的自动化测试数据生成方法，旨在提高C&#x2F;C++库和嵌入式项目中void指针和函数指针的测试覆盖率。</p><ul><li><p><strong>背景</strong>：在C&#x2F;C++项目中，指针的使用非常普遍，尤其是void指针和函数指针。这些指针在实际项目中频繁出现，但目前对于这类指针的测试数据生成研究较少。</p></li><li><p><strong>方法</strong>：VFP方法基于Concolic测试方法（结合了静态和动态测试的方法），通过预处理源代码来找出所有可能的void指针类型和函数指针的引用。VFP方法的关键在于分析源代码，找出void指针的所有可能类型和函数指针的引用，并利用这些信息生成初始测试数据。</p><ol><li><strong>参数预处理</strong>：分析被测单元内部和外部的源代码，找出所有可能的void指针类型和函数指针引用。</li><li><strong>随机测试数据生成</strong>：使用类型映射和引用映射，结合随机值生成，为其他数据类型生成初始测试数据。</li><li><strong>测试数据执行和测试路径分析</strong>：执行生成的测试数据，收集覆盖的测试路径，并尝试找出未覆盖的节点和最短未覆盖测试路径。</li><li><strong>定向测试数据生成</strong>：基于未覆盖的测试路径，生成路径约束，并转换为SMT-Lib表达式，由SMT求解器求解，生成新的测试数据。</li></ol></li></ul><h2 id="4-Error-Handling"><a href="#4-Error-Handling" class="headerlink" title="4. Error Handling"></a>4. Error Handling</h2><p>C语言的错误处理方式是通过函数返回值指示错误状态（通常还有宏定义的errno），通过条件语句处理错误。C++在保留C风格的错误处理方式时，新增了异常处理。</p><p><a href="https://dl.acm.org/doi/abs/10.1145/3106237.3106300">Automatically diagnosing and repairing error handling bugs in C | Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering (acm.org)</a></p><p>研究结果表明，错误处理漏洞通常由四个原因引起：错误&#x2F;缺失的错误检查（EC）、错误&#x2F;缺失的错误传播（EP）、错误&#x2F;缺失的错误输出（EO）和错误&#x2F;缺失的资源释放（RR）。作者利用这些发现设计并实现了一个名为ErrDoc的工具，该工具使用受限符号执行来探索所有可能的错误路径，并使用静态分析技术验证错误值是否被检查、向上游传播或记录。</p><ol><li><strong>探索错误路径</strong>：ErrDoc通过符号执行来识别所有可能的错误路径，并标记CFG中的相应节点和边。</li><li><strong>检测和分类错误处理漏洞</strong>：ErrDoc利用前一步收集的信息，输出有漏洞的程序位置和相应的漏洞类别。</li><li><strong>修复错误处理漏洞</strong>：ErrDoc自动修复四种类型的错误处理漏洞，通过修改AST来引入修复</li></ol><p>（自动修复&#x3D;&gt;生成对应处的用例？）</p>]]></content>
      
      
      <categories>
          
          <category> C++单元测试生成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++单yuan生成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记</title>
      <link href="/2025/01/11/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/01/11/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="C-学习笔记"><a href="#C-学习笔记" class="headerlink" title="C++学习笔记"></a>C++学习笔记</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>必修课系统教学的只有C语言和Java，而Python比较简单虽没有系统教学但也在许多课程中经常使用。本来培养方案上是有C++的选修课的，但是不知道为什么不开了，上学期的编译也有用C++编程的选择。笔者这个篇笔记只记录学习其与C&#x2F;Java的不同点。</p><p>参考：[菜鸟教程](<a href="https://www.runoob.com/cplusplus/cpp-tutorial.html">C++ 教程 | 菜鸟教程 (runoob.com)</a>)</p><h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p><p>C++ 被认为是一种<strong>中级</strong>语言，它综合了高级语言和低级语言的特点。</p><h2 id="1-1、特点"><a href="#1-1、特点" class="headerlink" title="1.1、特点"></a>1.1、特点</h2><ul><li>C++有类似Java的面向对象的特点，即封装、继承、多态、抽象（在学Java的时候就已经知道，Java只能单继承而C++可以多继承）。</li><li>标准的 C++ 由三个重要部分组成：核心语言、C++标准库、标准模板库STL（这个在算法课上用过）</li></ul><h2 id="1-2、使用"><a href="#1-2、使用" class="headerlink" title="1.2、使用"></a>1.2、使用</h2><p>C++的使用场景（后续若参加冯如杯，需要结合产业实际，如老师说的汽车C++软件）：</p><ul><li><p><strong>游戏开发</strong>：C++ 是游戏开发领域中最常用的编程语言之一，因为它具有高效的性能和直接控制硬件的能力。许多主要的游戏引擎，如 Unreal Engine 和 Unity，都使用 C++ 编写。</p><blockquote><p>我高中&#x2F;大一的时候还很想从事游戏开发呢……</p></blockquote></li><li><p><strong>嵌入式系统开发</strong>：C++ 可以在嵌入式系统中发挥重要作用，如智能手机、汽车、机器人和家电等领域。由于嵌入式系统通常具有严格的资源限制和实时要求，因此 C++ 的高效性能和内存控制功能非常有用。</p></li><li><p>金融领域：C++ 在金融领域中被广泛应用，如高频交易、算法交易和风险管理等领域。由于这些应用程序需要高效的性能和对硬件的直接控制，C++ 语言是一个合适的选择。</p></li><li><p>图形图像处理：C++ 可以用于开发图形和图像处理应用程序，如计算机视觉、计算机图形学和人工智能领域。由于这些应用程序需要高效的计算能力和对硬件的控制，因此 C++ 是一个很好的选择。</p><blockquote><p>智能计算系统的C++算子？</p></blockquote></li><li><p>科学计算和数值分析：C++ 可以用于开发科学计算和数值分析应用程序，如数值模拟和高性能计算等领域。由于这些应用程序需要高效的计算能力和对硬件的直接控制，C++ 语言是一个很好的选择。</p></li></ul><h1 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a>2、基本语法</h1><p>过程性语言部分，与C&#x2F;Java类似。</p><h1 id="3、数据类型"><a href="#3、数据类型" class="headerlink" title="3、数据类型"></a>3、数据类型</h1><ul><li><p>基本类型：相较于C语言多了bool类</p></li><li><p>枚举类型：类似Java的枚举类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名&#123; </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[=整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure></li><li><p>类型转换：</p><ul><li><p><strong>静态转换（static_cast）</strong>：将一种数据类型的值强制转换为另一种数据类型的值。不进行任何运行时类型检查，因此可能会导致运行时错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i); <span class="comment">// 静态将int类型转换为float类型</span></span><br></pre></td></tr></table></figure></li><li><p><strong>动态转换（dynamic_cast）</strong>：通常用于将一个基类指针或引用转换为派生类指针或引用。运行时进行类型检查，如果不能进行转换则返回空指针或引发异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">Base* ptr_base = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* ptr_derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(ptr_base); <span class="comment">// 将基类指针转换为派生类指针</span></span><br></pre></td></tr></table></figure></li><li><p><strong>常量转换（const_cast）</strong>：用于将 const 类型的对象转换为非 const 类型的对象。只能用于转换掉 const 属性，不能改变对象的类型。</p></li><li><p><strong>重新解释转换（reinterpret_cast）</strong>：重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。不进行任何类型检查。</p></li></ul></li></ul><h1 id="4、修饰符类型"><a href="#4、修饰符类型" class="headerlink" title="4、修饰符类型"></a>4、修饰符类型</h1><p>类型限定符提供了变量的额外信息，用于在定义变量或函数时改变它们的默认行为的关键字。</p><table><thead><tr><th align="left">限定符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">const</td><td align="left"><strong>const</strong> 定义常量，表示该变量的值不能被修改。</td></tr><tr><td align="left">volatile</td><td align="left">修饰符 <strong>volatile</strong> 告诉该变量的值可能会被程序以外的因素改变，如硬件或其他线程。。</td></tr><tr><td align="left">restrict</td><td align="left">由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td></tr><tr><td align="left">mutable</td><td align="left">mutable 用于修饰类的成员变量。被 mutable 修饰的成员变量可以被修改，即使它们所在的对象是 const 的。</td></tr><tr><td align="left">static</td><td align="left">用于定义静态变量，表示该变量的作用域仅限于当前文件或当前函数内，不会被其他文件或函数访问。</td></tr><tr><td align="left">register</td><td align="left">用于定义寄存器变量，表示该变量被频繁使用，可以存储在CPU的寄存器中，以提高程序的运行效率。</td></tr></tbody></table><ul><li><p>mutable实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_; <span class="comment">// const 关键字表示该成员函数不会修改对象中的数据成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(<span class="type">int</span> value)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        value_ = value; <span class="comment">// mutable 关键字允许在 const 成员函数中修改成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="5、存储类"><a href="#5、存储类" class="headerlink" title="5、存储类"></a>5、存储类</h1><p>存储类定义 C++ 程序中变量&#x2F;函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。包括auto、register（弃用）、static、extern、mutable、thread_local。</p><p><strong>auto</strong> 关键字用于两种情况：<u>声明变量时根据初始化表达式自动推断该变量的类型</u>、声明函数时函数返回值的占位符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=<span class="number">3.14</span>;      <span class="comment">//double</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;  <span class="comment">//const char*</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="built_in">auto</span>(<span class="number">9</span>); <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">5</span>, x2 = <span class="number">5.0</span>, x3=<span class="string">&#x27;r&#x27;</span>;<span class="comment">//错误，必须是初始化为同一类型</span></span><br></pre></td></tr></table></figure><h1 id="6、函数"><a href="#6、函数" class="headerlink" title="6、函数"></a>6、函数</h1><h2 id="6-1、参数默认值"><a href="#6-1、参数默认值" class="headerlink" title="6.1、参数默认值"></a>6.1、参数默认值</h2><p>与C&#x2F;Java不同而与Python类似：定义一个函数时，可以为参数列表中后边的每一个参数指定默认值；当调用函数时，如果实际参数的值留空，则使用这个默认值。</p><h2 id="6-2、Lambda函数-表达式"><a href="#6-2、Lambda函数-表达式" class="headerlink" title="6.2、Lambda函数&#x2F;表达式"></a>6.2、Lambda函数&#x2F;表达式</h2><p>表达式及例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)-&gt;<span class="keyword">return</span>-type&#123;body&#125;<span class="comment">// 有返回值</span></span><br><span class="line">[capture](parameters)&#123;body&#125;<span class="comment">// 无返回值</span></span><br><span class="line"></span><br><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y)&#123; <span class="keyword">return</span> x &lt; y ; &#125;</span><br><span class="line">[]&#123; ++global_x; &#125; </span><br><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123; <span class="type">int</span> z = x + y; <span class="keyword">return</span> z + x; &#125;</span><br></pre></td></tr></table></figure><p><code>[]</code>指定了该表达式可以访问的当前作用域的变量（包括引用和传值传递两种形式）。</p><h1 id="7、字符串"><a href="#7、字符串" class="headerlink" title="7、字符串"></a>7、字符串</h1><p>C++ 提供了以下两种类型的字符串表示形式：</p><ul><li>C 风格字符串（与C语言用法一致）</li><li>C++ 引入的 string 类类型（相当于Java中一个String类的对象）</li></ul><h1 id="8、引用"><a href="#8、引用" class="headerlink" title="8、引用"></a>8、引用</h1><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p><h2 id="8-1、引用-VS-指针"><a href="#8-1、引用-VS-指针" class="headerlink" title="8.1、引用 VS 指针"></a>8.1、引用 VS 指针</h2><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><h2 id="8-2、创建引用"><a href="#8-2、创建引用" class="headerlink" title="8.2、创建引用"></a>8.2、创建引用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i = 17;</span><br></pre></td></tr></table></figure><p>为 i 声明引用变量如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int&amp;  r = i;</span><br><span class="line">double&amp; s = d;</span><br></pre></td></tr></table></figure><p>在这些声明中，&amp; 读作<strong>引用</strong>。</p><blockquote><p>至于C++的输入输出、vector、数据结构等在算法课已经熟悉，就不记了。</p></blockquote><h1 id="9、类-对象"><a href="#9、类-对象" class="headerlink" title="9、类&amp;对象"></a>9、类&amp;对象</h1><p>与C&#x2F;Java区别最大的特点之一。</p><ul><li>定义方法：</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/05/cpp-classes-objects-2020-12-10-11.png" alt="img"></p><ul><li><p>类成员函数定义：可在类中定义，也可在类的外部使用<strong>范围解析运算符 ::</strong> 定义。</p></li><li><p>类访问修饰符：由于不分包，没有Java的默认（包访问权限），默认情况下是定义为 private。</p></li><li><p>构造函数：与Java类似，函数名为类名且无返回值类型，但可以使用初始化列表来初始化字段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C::<span class="built_in">C</span>( <span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c): <span class="built_in">X</span>(a), <span class="built_in">Y</span>(b), <span class="built_in">Z</span>(c) <span class="comment">// 对成员X, Y, Z分别赋值a, b, c</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类的<strong>析构函数</strong>：是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p></li><li><p><strong>拷贝构造函数</strong>：是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数（实现深拷贝）。形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">classname</span> (<span class="type">const</span> classname &amp;obj) &#123;</span><br><span class="line">   <span class="comment">// 拷贝构造函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类的<strong>友元函数&#x2F;友元类</strong>：定义在类<strong>外部</strong>，但有权访问类的所有私有（private）成员和保护（protected）成员。</p></li><li><p>其他与C&#x2F;Java类似的：内联函数、this指针、静态成员变量及函数</p></li></ul><h1 id="10、继承"><a href="#10、继承" class="headerlink" title="10、继承"></a>10、继承</h1><ul><li><p>与Java不同，C++中一个类可以派生自多个类，可以从多个基类继承数据和函数。多继承使用逗号隔开。</p></li><li><p>定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>-<span class="keyword">class</span>: access-specifier base-<span class="keyword">class</span></span><br></pre></td></tr></table></figure><p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p><ul><li><strong>公有继承（public）：<strong>当一个类派生自</strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li><li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li><li><strong>私有继承（private）：<strong>当一个类派生自</strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li></ul><blockquote><p>与Java不同，Java子类不能缩小父类成员的可见性。</p></blockquote></li></ul><h2 id="11、重载运算符和重载函数"><a href="#11、重载运算符和重载函数" class="headerlink" title="11、重载运算符和重载函数"></a>11、重载运算符和重载函数</h2><p>函数重载与Java类似，这里着重记录运算符重载。</p><p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box operator+(const Box&amp;);</span><br></pre></td></tr></table></figure><p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box operator+(const Box&amp;, const Box&amp;);</span><br></pre></td></tr></table></figure><h1 id="12、多态"><a href="#12、多态" class="headerlink" title="12、多态"></a>12、多态</h1><p>与Java的多态类似。</p><ul><li>虚函数：使用关键字<code>virtual</code>，子类重写要加<code>override</code>。（可以在基类中提供默认实现）</li><li>纯虚函数（Pure Virtual Functions）：<ul><li>一个包含纯虚函数的类被称为<strong>抽象类</strong>（Abstract Class），它不能被直接实例化。（与Java中的抽象类类似，是C++中的接口）</li><li>纯虚函数没有函数体，声明时使用<code>= 0</code>。（与Java的抽象方法类似）</li></ul></li></ul><h1 id="13、其他特性"><a href="#13、其他特性" class="headerlink" title="13、其他特性"></a>13、其他特性</h1><ul><li><p>动态内存：使用new分配堆空间（与Java类似），<u>使用delete释放内存（Java自动垃圾回收机制）</u></p><blockquote><p><strong>对于分配对象空间，C++支持栈分配内存和堆分配内存（需要显示释放），而Java是完全基于堆的。</strong></p></blockquote></li><li><p>命名空间：作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。可以嵌套。使用**范围解析运算符 ::**调用带有命名空间的函数或变量。</p></li><li><p>模板：类似Java的泛型。</p><ul><li><p>函数模板：（与Java泛型不同，使用时不指定的类型，直接使用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt; ret-type func-<span class="built_in">name</span>(parameter list)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类模板：（需要指定类型）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt; <span class="keyword">class</span> <span class="title class_">class</span>-name &#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p>导入标准库、预处理器：与C语言相同。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++单元测试生成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译技术实验总结感想</title>
      <link href="/2025/01/10/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93%E6%84%9F%E6%83%B3/"/>
      <url>/2025/01/10/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="《编译技术》实验总结感想"><a href="#《编译技术》实验总结感想" class="headerlink" title="《编译技术》实验总结感想"></a>《编译技术》实验总结感想</h1><h2 id="1-实验总结"><a href="#1-实验总结" class="headerlink" title="1. 实验总结"></a>1. 实验总结</h2><p>这个学期的编译实验一共分为文法解读、词法分析、语法分析、语义分析、代码生成、代码优化几个部分。总体来说，难度依次递增。</p><p>我选择的编程语言是Java，这也是我最喜欢的一种语言。在实验开始前，我还在庆幸不用像上学期的OS一样整天跟C语言打交道，又能愉快地编写最喜欢的Java了。</p><p>在最初的词法分析和语法分析中，我还体验着迭代开发Java、欣赏自己的设计模式的乐趣中。虽然语法分析的工作量相比于词法分析陡增，但是我个人觉得我的类设计还是比较清晰的，因此写完之后也算是非常有成就感了。</p><p>之后的语义分析其实就是建立符号表并处理语义错误，因此比较简单。但完成这里的时候，我深感对于类设计等的欠缺，几乎把面向对象的语言写成了面向过程的语言。而后面的中端代码生成是在语义分析的基础上做的，因此我总体的设计在此后也变得不忍直视。</p><p>代码生成我选择的是LLVM IR+MIPS。此时能给予我帮助的只有指导书了，然而我觉得指导书并不全面，只提供了最基本的介绍，具体实现大部分都是我自己摸索出来的。比如在LLVM IR生成中，指导书并没有说符号表到底存什么东西，我最后想的是存地址对应的虚拟寄存器，如果存值的话，还需要考虑分支合并时的phi指令等，如果指导书直接说明phi指令建议在后面优化时实现，可能我会花更少的时间了。</p><p>在MIPS的生成时，也有类似情况。我一开始理解错了LLVM IR中”虚拟寄存器“的概念，以为虚拟寄存器就必须得分配一个物理寄存器，所以我直接将后面优化部分的寄存器分配在生成MIPS时就写了，这耗费了我大量的时间。而后来我几乎快完成的时候经同学的提醒，才意识到虚拟寄存器也就是一个变量而已了，完全可以全部放在栈上。</p><p>在代码生成的那段时间，特别是MIPS生成，是整个过程最难、耗费时间最长的、最觉得无助的。中间代码和目标代码生成都花费了我快2周时间。一开始我以为MIPS生成就是简单的逐条指令翻译，但是我直接将寄存器分配纳入，使得整个过程非常坎坷，各种bug、各种问题……那时真的是最想放弃的一瞬。</p><p>好在直接实现了寄存器分配，使我竞速排序的排名不算太靠后。同时由于耗费了太多时间，我也无力做工作量巨大的复杂优化了（比如LLVM IR mem2reg）。但是我本身也无意去卷竞速排名，我感觉我能做出MIPS并在排名里有一席之地就足够了。最后的最后，我尽我所能地实现了一些比较简单的优化，也算是给整个编译实验画上了一个圆满的句号吧。</p><h2 id="2-感想"><a href="#2-感想" class="headerlink" title="2. 感想"></a>2. 感想</h2><p>完成整个编译实验是我个人第一次独立完成工作量和复杂度这么庞大的项目了，最后看了一下总共有9216行代码。但肯定不是代码行数越多就越好，我在中后期里类和方法设计方面比较欠缺，代码的质量也不算太高。虽然每次作业都是”万事开头难“，但是每次点击IDEA的”新建类“按钮都满怀着期待，期待着这个类的设计能够足够完美，而足够完美的设计在方便使用的同时真的能给人自豪感；虽然每次编码、debug过程都非常艰辛，但是每次看到AC通过的赏心悦目的绿色时，会感觉一切都值了。</p><h2 id="3-一点建议"><a href="#3-一点建议" class="headerlink" title="3. 一点建议"></a>3. 一点建议</h2><p>希望指导书可以给一些总体的编码实现思路（但是太具体也不行，否则大家都写成一样的了），毕竟从无到有的开发如果没有参考还是很有难度的，而且容易走弯路。</p>]]></content>
      
      
      <categories>
          
          <category> 编译技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译技术开发文档</title>
      <link href="/2025/01/10/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/"/>
      <url>/2025/01/10/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>《编译技术》实验开发文档</p><p>Author：bush</p></blockquote><h1 id="1-参考编译器介绍"><a href="#1-参考编译器介绍" class="headerlink" title="1 参考编译器介绍"></a>1 参考编译器介绍</h1><p>主要参考了教材上PL&#x2F;0以及tolang</p><h2 id="1-1-总体结构"><a href="#1-1-总体结构" class="headerlink" title="1.1 总体结构"></a>1.1 总体结构</h2><p>PL&#x2F;0是一个编译-解释执行程序，总体结构分为两个部分：</p><ol><li>先把PL&#x2F;0编译成目标程序（P-code指令）</li><li>再对目标程序进行解释执行，得到运行结果</li></ol><h2 id="1-2-接口设计"><a href="#1-2-接口设计" class="headerlink" title="1.2 接口设计"></a>1.2 接口设计</h2><p>PL&#x2F;0编译程序采用一遍扫描，以语法分析为核心，由它调用词法分析程序取单词，在语法分析过程中同时进行语义分析处理，并生成目标指令。</p><p>如遇有语法、语义错误，则随时调用出错处理程序，打印出错信息。</p><h2 id="1-3-文件组织"><a href="#1-3-文件组织" class="headerlink" title="1.3 文件组织"></a>1.3 文件组织</h2><p>前端和后端分包等。</p><h1 id="2-编译器总体设计"><a href="#2-编译器总体设计" class="headerlink" title="2 编译器总体设计"></a>2 编译器总体设计</h1><h2 id="2-1-总体结构"><a href="#2-1-总体结构" class="headerlink" title="2.1 总体结构"></a>2.1 总体结构</h2><p>总体结构与PL&#x2F;0不同，是编译程序。</p><ol><li>先编译成LLVM IR</li><li>由LLVM IR生成MIPS汇编代码</li><li>直接运行MIPS汇编代码</li></ol><hr><p>编译器总体采用多遍扫描，即先通过一次完整的词法分析得到token序列，再进行语法分析得到语法树。</p><h2 id="2-2-接口设计"><a href="#2-2-接口设计" class="headerlink" title="2.2 接口设计"></a>2.2 接口设计</h2><h3 id="2-2-1-词法分析器Lexer"><a href="#2-2-1-词法分析器Lexer" class="headerlink" title="2.2.1 词法分析器Lexer"></a>2.2.1 词法分析器Lexer</h3><p><code>Lexer.java</code>主要提供一个接口<code>getToken()</code></p><ul><li><strong>调用形式</strong>：<code>token = lexer.getToken()</code></li><li><strong>作用</strong>：根据设置的读取器<code>BufferedReader</code>，每次调用返回下一个解析到的<code>Token</code>类符号</li><li><strong>备注</strong>：当且仅当读到文件流末尾时返回<code>null</code></li></ul><h3 id="2-2-2-语法分析器Parser"><a href="#2-2-2-语法分析器Parser" class="headerlink" title="2.2.2 语法分析器Parser"></a>2.2.2 语法分析器Parser</h3><p><code>Parser.java</code>主要提供一个接口<code>parse()</code></p><ul><li><strong>调用形式</strong>：<code>compUnit = parser.parse()</code></li><li><strong>作用</strong>：首先调用词法分析器的接口解析得到token序列，然后递归解析以一个<code>CompUnit</code>类实例表示的语法树</li></ul><h2 id="2-3-文件组织"><a href="#2-3-文件组织" class="headerlink" title="2.3 文件组织"></a>2.3 文件组织</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 主要文件结构如下</span><br><span class="line">├─error</span><br><span class="line">│  └─CompilerError.java</span><br><span class="line">├─frontend</span><br><span class="line">│  ├─lexer</span><br><span class="line">│  │   └─Lexer.java</span><br><span class="line">│  └─parser</span><br><span class="line">│      ├─declaration</span><br><span class="line">│      ├─expression</span><br><span class="line">│      ├─function</span><br><span class="line">│      ├─statement</span><br><span class="line">│      └─terminal</span><br><span class="line">│      └─Parser.java</span><br><span class="line">├─Compiler.java</span><br><span class="line">├─config.json</span><br><span class="line">└─README.md</span><br></pre></td></tr></table></figure><h1 id="3-词法分析设计"><a href="#3-词法分析设计" class="headerlink" title="3 词法分析设计"></a>3 词法分析设计</h1><h2 id="3-1-编码前的设计"><a href="#3-1-编码前的设计" class="headerlink" title="3.1 编码前的设计"></a>3.1 编码前的设计</h2><p>主要参考的是教材上的PL&#x2F;0，以及第三章的词法分析示例。</p><p><img src="/../assets/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20241014104848084.png" alt="image-20241014104848084"></p><p>代码大致流程图如上，编码时，主要依靠这张图，其他细节在编码时实现。</p><p><code>Compiler.java</code>这一主程序调用<code>frontedn/Lexer.java</code>中的<code>getSymbol</code>方法。在此次作业中主逻辑还未实现，因此可以在<code>Compiler.java</code>中暂时编写满足本次作业的测试逻辑。</p><h2 id="3-2-编码完成后的修改"><a href="#3-2-编码完成后的修改" class="headerlink" title="3.2 编码完成后的修改"></a>3.2 编码完成后的修改</h2><h3 id="3-2-1-设计模式的选择、类的设计"><a href="#3-2-1-设计模式的选择、类的设计" class="headerlink" title="3.2.1 设计模式的选择、类的设计"></a>3.2.1 设计模式的选择、类的设计</h3><ul><li>词法分析器<code>Lexer.java</code>采用单例模式（饿汉式）的设计模式，作为一个静态类存放到主类<code>Compiler.java</code>中，其方法也多是静态方法，最主要的是<code>getToken</code>方法；<br><img src="/../assets/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20241014104957471.png" alt="image-20241014104957471"></li><li>单词token作为一个类<code>Token</code>，类型作为其内部枚举类<code>TokenType</code>；</li><li>编译错误的处理：<code>CompilerError</code>是一个<code>Exception</code>的子类，在<code>Lexer</code>等各个组件的方法可以被抛出，在主类<code>Compiler</code>中被<code>try-catch</code>处理。</li></ul><h3 id="3-2-2-其他更改或BUG"><a href="#3-2-2-其他更改或BUG" class="headerlink" title="3.2.2 其他更改或BUG"></a>3.2.2 其他更改或BUG</h3><ol><li>最大的疏忽是忘记添加处理注释的代码了，应该把读入<code>/</code>符号后的逻辑单列出来。</li><li>另外，只考虑到字符常量中只有一个字符的情况了，没有考虑到转义字符</li></ol><h3 id="3-2-3-语法分析完成后的改动"><a href="#3-2-3-语法分析完成后的改动" class="headerlink" title="3.2.3 语法分析完成后的改动"></a>3.2.3 语法分析完成后的改动</h3><ul><li>最大的改动是，由设计之初的一遍扫描改为多遍扫描<ul><li>在词法分析时，设计采用一遍扫描，即语法分析中每次调用词法分析的接口<code>getToken()</code>即返回下一个token。<br>在词法分析程序内部中使用<code>BufferedReader</code>的<code>mark()</code>和<code>reset()</code>两个方法组实现字符读取的回退，在语法分析开始时计划在调用<code>getToken()</code>接口的外层也使用这两个方法实现token的回退和预读。</li><li>但是这样会使得在接口内部再次调用<code>mark()</code>覆盖外层的<code>mark()</code>使得无法回退token等问题，因此改为多遍扫描，即在语法分析前先完成整个程序的词法分析得到token序列，接下来的语法分析便不用通过操作读取器回退token，功能完成解耦。</li></ul></li><li>修改了词法分析解析多行注释的部分：在de完语法分析的bug后，公共测试库全过但测试点16RE，最后发现是词法分析中对多行注释的读取有误</li></ul><h1 id="4-语法分析设计"><a href="#4-语法分析设计" class="headerlink" title="4 语法分析设计"></a>4 语法分析设计</h1><h2 id="4-1-编码前的设计"><a href="#4-1-编码前的设计" class="headerlink" title="4.1 编码前的设计"></a>4.1 编码前的设计</h2><ul><li>与词法分析类似，使用单例模式实现<code>Parser.java</code></li><li>主要采用递归下降程序实现</li><li>此外通过预读解决多个规则匹配问题</li></ul><p>以下是编写递归程序时的辅助表格，部分非终结符的FIRST略</p><table><thead><tr><th>非终结符</th><th>FIRST集</th><th>完成</th></tr></thead><tbody><tr><td>CompUnit</td><td>CONSTTK, INTTK, CHARTK, VOIDTK</td><td>V</td></tr><tr><td>Decl</td><td>CONSTTK, INTTK, CHARTK</td><td>V</td></tr><tr><td>FuncDef</td><td>VOIDTK, INTTK, CHARTK</td><td>V</td></tr><tr><td>MainFuncDef</td><td>INTTK</td><td>V</td></tr><tr><td>ConstDecl</td><td>CONSTTK</td><td>V</td></tr><tr><td>VarDecl</td><td>INT, CHAR</td><td>V</td></tr><tr><td>FuncType</td><td>‘VOIDTK, INTTK, CHARTK</td><td>V</td></tr><tr><td>BType</td><td>INTTK, CHARTK</td><td>V</td></tr><tr><td>ConstDef</td><td></td><td>V</td></tr><tr><td>Ident</td><td>Vt</td><td>V</td></tr><tr><td>ConstInitVal</td><td></td><td>V</td></tr><tr><td>ConstExp</td><td></td><td>V</td></tr><tr><td>StringConst</td><td>Vt</td><td>V</td></tr><tr><td>AddExp</td><td></td><td>V</td></tr><tr><td>MulExp</td><td></td><td>V</td></tr><tr><td>UnaryExp</td><td>LPARENT, IDENFR, INTCON, CHRCON, PLUS, MINU, NOT</td><td>V</td></tr><tr><td>PrimaryExp</td><td>LPARENT, IDENFR, INTCON, CHRCON</td><td>V</td></tr><tr><td>FuncRParams</td><td></td><td>V</td></tr><tr><td>UnaryOp</td><td>PLUS, MINU, NOT</td><td>V</td></tr><tr><td>LVal</td><td>IDENFR</td><td>V</td></tr><tr><td>Number</td><td>INTCON</td><td>V</td></tr><tr><td>Character</td><td>CHRCON</td><td>V</td></tr><tr><td>IntConst</td><td>Vt</td><td>V</td></tr><tr><td>CharConst</td><td>Vt</td><td>V</td></tr><tr><td>VarDef</td><td></td><td>V</td></tr><tr><td>InitVal</td><td></td><td>V</td></tr><tr><td>Exp</td><td>LPARENT, IDENFR, INTCON, CHRCON, PLUS, MINU, NOT</td><td>V</td></tr><tr><td>FuncFParams</td><td>INTTK, CHARTK</td><td>V</td></tr><tr><td>FuncFParam</td><td>INTTK, CHARTK</td><td>V</td></tr><tr><td>Block</td><td>LPARENT</td><td>V</td></tr><tr><td>BlockItem</td><td></td><td>V</td></tr><tr><td>Stmt</td><td></td><td>V</td></tr><tr><td>ForStmt</td><td></td><td>V</td></tr><tr><td>Cond</td><td></td><td>V</td></tr><tr><td>LOrExp</td><td></td><td>V</td></tr><tr><td>LAndExp</td><td></td><td>V</td></tr><tr><td>EqExp</td><td></td><td>V</td></tr><tr><td>RelExp</td><td></td><td>V</td></tr></tbody></table><h2 id="4-2-编码后的设计"><a href="#4-2-编码后的设计" class="headerlink" title="4.2 编码后的设计"></a>4.2 编码后的设计</h2><h3 id="4-2-1-设计模式"><a href="#4-2-1-设计模式" class="headerlink" title="4.2.1 设计模式"></a>4.2.1 设计模式</h3><ul><li>语法分析器<code>Parser.java</code>与词法分析器类似，采用饿汉式单例模式；</li><li>单例模式的静态方法与非静态方法的实现效果类似，但为了简便，在语法成分类中要频繁调用的<code>getSymbol() currentSymbol()</code>等方法设置为静态方法。</li></ul><h3 id="4-2-2-递归下降读取逻辑"><a href="#4-2-2-递归下降读取逻辑" class="headerlink" title="4.2.2 递归下降读取逻辑"></a>4.2.2 递归下降读取逻辑</h3><ul><li>在一个程序要调用一个分析子程序前，需要使用<code>Parser.getSymbol()</code>读取一个token</li><li>在分析子程序里，分析子程序会递归匹配所有token，但并不会超前读取（例如分析子程序只匹配一个终结符即结束，则不会调用<code>Parser.getSymbol()</code>），因此一个子成分分析完后，<code>symbol</code>停留在最后匹配到的那个token处</li><li>接着继续使用<code>Parser.getSymbol()</code>读取一个token并调用剩下的分析子程序</li><li>在遇到终结符时，匹配后不需要使用<code>Parser.getSymbol()</code>，因为递归过程相当于在匹配之前已经执行一次</li></ul><h3 id="4-2-3-类设计"><a href="#4-2-3-类设计" class="headerlink" title="4.2.3 类设计"></a>4.2.3 类设计</h3><ul><li><p>对于语法树的构建，首先设计了一个语法树节点的接口<code>SyntaxNode.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SyntaxNode</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">parse</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">outputString</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于每个语法成分，均设计同名的一个类并实现以上接口；</p><ul><li>对于该语法成分的一条规则，规则右部语法成分作为该类的一个属性存储<ul><li>若有多条规则，则根据FIRST集的不同划分成不同的子类，超类属性类型为超类，但在<code>parse()</code>方法中根据当前符号选择实例化不同的子类（方法重写和多态）</li><li>若右部语法成分可重复多次，则存储对应的列表</li><li>若右部语法成分可选，则值非<code>null</code>时表示存在，否则不存在</li></ul></li><li>类的<code>parse()</code>方法会根据语法分析器当前解析到的符号<code>Parser.currentSymbol()</code>向前解析，并返回自身（<code>return this</code>）</li><li>顶层语法成分调用<code>parse()</code>方法解析时，为下层语法成分属性赋值一个调用过自身<code>parse()</code>方法的<code>new</code>对象，这样就实现了递归</li><li>每个语法成分的<code>outputString()</code>方法按照同样的递归逻辑返回需要输出的内容和格式</li></ul></li><li><p>为了使得结构清晰，按功能将语法成分包为<code>declaration</code>, <code>expression</code>, <code>function</code>, <code>statement</code>, <code>terminal</code>五个包</p></li><li><p>对于有多条规则的语法成分的子类也分包管理，如<code>stmts</code>, <code>unaryexps</code>, <code>primaryexps</code></p></li></ul><h3 id="4-2-4-FIRST集冲突解决方案"><a href="#4-2-4-FIRST集冲突解决方案" class="headerlink" title="4.2.4 FIRST集冲突解决方案"></a>4.2.4 FIRST集冲突解决方案</h3><ul><li>若FIRST集冲突，可以类似的查看规则的SECOND集，并使用<code>preReadNext()</code>预读一个token的方法区分（大部分可以解决）</li><li>仅在<code>CompUnit-&gt;Decl|FuncDef</code>，SECOND集仍冲突，则<code>preReadNextNext()</code>预读下下个token可以区分</li><li>仅在<code>Stmt</code>的推导时，使用SECOND集仍然难以区分，此处采用回溯token的方法解决<ul><li>在回溯时需要同时回溯抛出的错误！不然会出现多输出错误的情况</li></ul></li></ul><h3 id="4-2-5-左递归文法解决方案"><a href="#4-2-5-左递归文法解决方案" class="headerlink" title="4.2.5 左递归文法解决方案"></a>4.2.5 左递归文法解决方案</h3><ul><li><p>对于左递归文法，将规则改写为扩充的BNF范式。<br>以<code>MulExp → UnaryExp | MulExp (&#39;*&#39; | &#39;/&#39; | &#39;%&#39;) UnaryExp</code>这条规则为例，消除左递归后得到<br><code>MulExp → UnaryExp &#123; (&#39;*&#39; | &#39;/&#39; | &#39;%&#39;) UnaryExp &#125;</code></p></li><li><p>以这条规则为例，这些具有递归文法的类属性设置为一个<code>UnaryExp</code>类和一个元素为<code>OpUnaryExp</code>类的列表分别表示EBNF范式的两部分</p></li><li><p>其中<code>OpUnaryExp</code>为静态内部类，相当于一个二元组，包含每个重复的符号<code>op</code>和<code>unaryExp</code></p></li><li><p>至此便消除左递归文法，在分析方法中不会递归调用自己，而是不断调用下一层的语法成分分析方法；并且在输出方法<code>outputString()</code>中，也可以通过类似逻辑输出正确的语法树结构</p></li><li><p>从<code>UnaryExp-&gt;MulExp-&gt;AddExp-&gt;RelExp-&gt;EqExp-&gt;LAndExp-&gt;LorExp</code>各层次间关系是一模一样的，因此编写完<code>UnaryExp-&gt;MulExp</code>后，可通过代码查找替换迁移得到后面的层间关系；手稿如下：</p><p><img src="/../assets/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/07fae8c98c7d24c7990122f1fc798d0.jpg" alt="07fae8c98c7d24c7990122f1fc798d0"></p></li></ul><h3 id="4-2-6-关于错误处理的修改"><a href="#4-2-6-关于错误处理的修改" class="headerlink" title="4.2.6 关于错误处理的修改"></a>4.2.6 关于错误处理的修改</h3><ul><li><p>在之前的词法分析设计时，设计了一个自定义的<code>CompileError</code>并继承<code>Exception</code>类，错误通过throw抛出自<code>CompileError</code>报错并在上层处理，但在此次编码时发现：</p><ul><li>语法分析与词法分析不同，词法分析是顺序执行，可以使用throw抛出异常，在顶层记录错误并继续执行 </li><li>而语法分析是递归调用的，不能够被中断，因此把错误暂存而不是抛出</li></ul></li><li><p>并且由一遍扫描改为多遍扫描也不能顺序地依次处理错误。因此，修改处理逻辑，将所有错误先暂存并直接处理，最后一起输出。</p></li><li><p>需要注意的是一遍扫描错误抛出的顺序是按行数升序的，但多遍扫描的顺序一次是词法分析错误、语法分析错误、语义分析错误等，需要在输出前按行数排序再输出</p></li></ul><h1 id="5-语义分析设计"><a href="#5-语义分析设计" class="headerlink" title="5 语义分析设计"></a>5 语义分析设计</h1><h2 id="5-1-编码前的设计"><a href="#5-1-编码前的设计" class="headerlink" title="5.1 编码前的设计"></a>5.1 编码前的设计</h2><p>在这一阶段，不需要进行中间代码生成，只需要输出符号表内容。且指导书在中间代码生成这一章写道：</p><blockquote><p>对于符号表的生命周期，可以是遍历 AST 后，生成一张<strong>完整的符号表</strong>，然后再进行代码生成；也可以是在遍历过程中创建<strong>栈式符号表</strong>，随着遍历过程创建和销毁，同时进行代码生成。</p></blockquote><p>因此，暂时设计为先遍历AST生成树形符号表，再在后面的中间代码生成时做增量式开发。</p><hr><p>采用访问者模式：</p><ul><li>设计一个单例<code>Visitor</code>类，其包含不同语法成分的<code>visit()</code>方法，解析语法树并调用下层的<code>visit()</code>方法。</li><li>仅<code>visit(CompUnit compUnit)</code>方法为<code>public</code>以便外层调用，其余语法成分的<code>visit()</code>方法设置为<code>private</code>被其调用。</li></ul><h2 id="5-2-编码后的设计"><a href="#5-2-编码后的设计" class="headerlink" title="5.2 编码后的设计"></a>5.2 编码后的设计</h2><h3 id="5-2-1-符号和符号表的类设计"><a href="#5-2-1-符号和符号表的类设计" class="headerlink" title="5.2.1 符号和符号表的类设计"></a>5.2.1 符号和符号表的类设计</h3><ul><li><p>符号类<code>Symbol</code>设置为抽象类：<code>ConstInt, ConstChar, ConstIntArray, ConstCharArray, ConstInt, ConstChar, ConstIntArray, ConstCharArray</code>这8种符号每种各设置一个子类<code>xxxSymbol</code>继承<code>Symbol</code>；<code>IntFunc, CharFunc, VoidFunc</code>这3种符号设计一个子类<code>FuncSymbol</code>；共9个继承。</p></li><li><p>符号表需要维持树状结构，因此添加<code>fatherTable</code>这一属性。构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SymbolTable</span><span class="params">(SymbolTable fatherTable)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.fatherTable = fatherTable;</span><br><span class="line">    <span class="built_in">this</span>.scopeId = scopeIdCounter++;</span><br><span class="line">    fatherTable.childrenTables.add(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">SymbolTable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.fatherTable = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.scopeId = scopeIdCounter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中根符号表作为静态属性存储以便输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SymbolTable</span> <span class="variable">ROOT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SymbolTable</span>(); <span class="comment">// 根符号表，即全局符号表</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-2-2-访问者设计"><a href="#5-2-2-访问者设计" class="headerlink" title="5.2.2 访问者设计"></a>5.2.2 访问者设计</h3><ul><li>访问者总体结构与 #5.1 编码前的设计相同；</li><li>在访问者中维护一个<code>curSymbolTab</code>属性保存当前的符号表；</li><li>另有其他属性用来辅助语义分析（直接作为Visitor属性就不用在方法中传递参数了）。</li></ul><h3 id="5-2-3-语义分析后的改动"><a href="#5-2-3-语义分析后的改动" class="headerlink" title="5.2.3 语义分析后的改动"></a>5.2.3 语义分析后的改动</h3><ul><li>解耦词法分析器和语法分析器，优化了对外接口</li><li>为语法成分属性添加Getter</li><li>UnaryExp → UnaryOp UnaryExp这条规则不应拆分子类而应把UnaryOp作为UnaryExp的属性</li><li>重构多条规则语法成分：将Stmt、BlockItem、PrimaryExp中的自反属性删去；将UnaryExp中的属性更名为UnaryExpWithoutOp。这样避免了在语义分析时，使用<code>unaryExp.getUnaryExp(), primaryExp.getPrimaryExp(), stmt.getStmt() instanceof ReturnStmt</code>等等冗余且易出错的调用。</li></ul><h3 id="5-2-4-完成后的思考"><a href="#5-2-4-完成后的思考" class="headerlink" title="5.2.4 完成后的思考"></a>5.2.4 完成后的思考</h3><p>相比于语法分析，这次的主要代码均在一个文件下（<code>Visitor.java</code>），耦合度高、模块化差、难以阅读和调试。但由于这次只是部分的语义分析，不涉及中间代码生成，因此期待在后面的迭代中优化结构、解耦合。</p><h1 id="6-代码生成设计"><a href="#6-代码生成设计" class="headerlink" title="6 代码生成设计"></a>6 代码生成设计</h1><h2 id="6-1-编码前的设计"><a href="#6-1-编码前的设计" class="headerlink" title="6.1 编码前的设计"></a>6.1 编码前的设计</h2><h3 id="6-1-1-中间代码生成设计"><a href="#6-1-1-中间代码生成设计" class="headerlink" title="6.1.1 中间代码生成设计"></a>6.1.1 中间代码生成设计</h3><p>按照教程的构建单元设置相关类：</p><img src="https://judge.buaa.edu.cn/cguserImages?_img=30639449344bc202b2e4ac7ba5b5ab1a.png" alt="图片#50% #center" style="zoom: 50%;" /><p>类里均存放初始化的值，仅仅用于转成LLVM IR文本。实际要输出常量的值应差符号表。</p><p>指令：</p><table><thead><tr><th>LLVM IR</th><th>使用方法</th><th>简介</th></tr></thead><tbody><tr><td><code>add</code></td><td><code>&lt;result&gt; = add &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>&#x2F;</td></tr><tr><td><code>sub</code></td><td><code>&lt;result&gt; = sub &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>&#x2F;</td></tr><tr><td><code>mul</code></td><td><code>&lt;result&gt; = mul &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>&#x2F;</td></tr><tr><td><code>sdiv</code></td><td><code>&lt;result&gt; = sdiv &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>有符号除法</td></tr><tr><td><code>srem</code></td><td><code>&lt;result&gt; = srem &lt;baseType&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>有符号取余</td></tr><tr><td><code>icmp</code></td><td><code>&lt;result&gt; = icmp &lt;cond&gt; &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>比较指令</td></tr><tr><td><code>and</code></td><td><code>&lt;result&gt; = and &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>按位与</td></tr><tr><td><code>or</code></td><td><code>&lt;result&gt; = or &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>按位或</td></tr><tr><td><code>call</code></td><td><code>&lt;result&gt; = call [ret attrs] &lt;ty&gt; &lt;name&gt;(&lt;...args&gt;)</code></td><td>函数调用</td></tr><tr><td><code>alloca</code></td><td><code>&lt;result&gt; = alloca &lt;baseType&gt;</code></td><td>分配内存</td></tr><tr><td><code>load</code></td><td><code>&lt;result&gt; = load &lt;ty&gt;, ptr &lt;pointer&gt;</code></td><td>读取内存</td></tr><tr><td><code>store</code></td><td><code>store &lt;ty&gt; &lt;initValue&gt;, ptr &lt;pointer&gt;</code></td><td>写内存</td></tr><tr><td><code>getelementptr</code></td><td><code>&lt;result&gt; = getelementptr &lt;ty&gt;, ptr &lt;ptrval&gt;&#123;, &lt;ty&gt; &lt;idx&gt;&#125;*</code></td><td>计算目标元素的位置（数组部分会单独详细说明）</td></tr><tr><td><code>phi</code></td><td><code>&lt;result&gt; = phi [fast-math-flags] &lt;ty&gt; [&lt;val0&gt;, &lt;label0&gt;], ...</code></td><td>&#x2F;</td></tr><tr><td><code>zext..to</code></td><td><code>&lt;result&gt; = zext &lt;ty&gt; &lt;initValue&gt; to &lt;ty2&gt;</code></td><td>将 <code>ty</code> 的 <code>initValue</code> 的 baseType 扩充为 <code>ty2</code>（zero extend）</td></tr><tr><td><code>trunc..to</code></td><td><code>&lt;result&gt; = trunc &lt;ty&gt; &lt;initValue&gt; to &lt;ty2&gt;</code></td><td>将 <code>ty</code> 的 <code>initValue</code> 的 baseType 缩减为 <code>ty2</code>（truncate）</td></tr><tr><td><code>br</code></td><td><code>br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt;</code> <code>br label &lt;dest&gt;</code></td><td>改变控制流</td></tr><tr><td><code>ret</code></td><td><code>ret &lt;baseType&gt; &lt;initValue&gt; </code>, <code>ret void</code></td><td>退出当前函数，并返回值</td></tr></tbody></table><ul><li>在生成对应指令时，将slot加入函数域。例如在<code>visitAddExp</code>中，仅在在生成add指令时将result作为新slot加入函数域，其他slot均在调用的<code>visitMulExp</code>中已加入函数域。</li><li>符号类中新增address字段，存放符号分配到的地址空间</li><li>我们规定数组名只用来（1）函数传参（此时应由FuncRParam一路推导至Ident，不存在任何其他符号），（2）通过索引取数组里面的值。</li></ul><table><thead><tr><th></th><th>全局作用域</th><th>局部作用域</th><th>共性</th></tr></thead><tbody><tr><td><strong>常量</strong></td><td></td><td></td><td>单个常量和常量数组均需给定<code>ConstExp</code>（即可在编译时计算的）初始值</td></tr><tr><td><strong>变量</strong></td><td>若有初始值，则必须是可计算的<code>ConstExp</code>；若无初始值，置零</td><td>可以是不可计算的<code>Exp</code></td><td>可以不带初始值</td></tr><tr><td>共性</td><td>@声明，在顶层，属于<code>GlobalValue</code>；需要保存初始值</td><td>常量和变量jun<code>alloca</code>指令声明，仅保存对应的虚拟寄存器</td><td></td></tr></tbody></table><ul><li><p>一个if语句将当前基本块分为4个基本块（有else）或3个基本块（无else）</p></li><li><p>一个for语句将当前基本块分为5块</p><table><thead><tr><th>B1</th><th>preForStmt（若无preForStmt，则无B1）</th></tr></thead><tbody><tr><td>B2</td><td>Cond，条件跳转指令B3、B5（若无Cond，则是无条件跳转B3）</td></tr><tr><td>B3</td><td>Stmt，无条件跳转B4</td></tr><tr><td>B4</td><td>postStmt，无条件跳转B2 （<strong>continue语句跳点</strong>）</td></tr><tr><td>B5</td><td>（end）（<strong>break语句跳点</strong>）</td></tr></tbody></table></li><li><p>暂时不考虑SSA形式和phi指令，符号表存储地址，每次引用变量使用load，赋值变量使用store。</p></li><li><p>函数传递的非指针参数不能修改，因此<strong>在进入函数时</strong>，需要为其alloca一个地址空间，并将传进的参数赋给它（相当于变量定义）。<strong>不能在第一次使用时再分配并赋值</strong>，因为如果在循环体内使用该变量，则会导致死循环：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun2</span><span class="params">(<span class="type">int</span> a)</span>  <span class="comment">// a=6</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;a &gt;= <span class="number">1</span>;) <span class="comment">// 第一次使用时</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = b * a;</span><br><span class="line">        a = a - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num = num + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a! = %d, num = %d\n&quot;</span>, b, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define dso_local i32 @fun2(i32 %0) &#123;</span><br><span class="line">1:</span><br><span class="line">%2 = alloca i32</span><br><span class="line">store i32 1, i32* %2</span><br><span class="line">%3 = alloca i32</span><br><span class="line">store i32 1, i32* %3</span><br><span class="line">br label %4</span><br><span class="line">4:</span><br><span class="line">%5 = icmp sge i32 %0, 1; for循环的cond块。若不分配，这里会始终会用a的旧值；而如果在此分配并赋值，则会一直赋相同的值给a</span><br><span class="line">%6 = zext i1 %5 to i32</span><br><span class="line">%7 = icmp ne i32 %6, 0</span><br><span class="line">br i1 %7, label %8, label %26</span><br></pre></td></tr></table></figure><h3 id="6-1-2-后端代码生成设计"><a href="#6-1-2-后端代码生成设计" class="headerlink" title="6.1.2 后端代码生成设计"></a>6.1.2 后端代码生成设计</h3><ul><li><p>以函数为单位管理栈帧、分配全局寄存器，以基本块为单位分配临时寄存器（寄存器分配实现在文档的优化部分）</p></li><li><p>在LLVM IR中，存在i32和i8两种类型，但是在MIPS中，均使用32位字存储。</p></li><li><p>栈帧结构（简化了部分结构）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 栈帧结构（从高到低增长）：</span><br><span class="line"> * sp+size-&gt;|- - - - - - - |   以下为栈帧内容：</span><br><span class="line"> *          |  局部变量      |</span><br><span class="line"> *          |- - - - - - - |   以下调用函数后需生成的：</span><br><span class="line"> *          |  返回地址      |</span><br><span class="line"> *          |- - - - - - - |</span><br><span class="line"> *          |  （保留寄存器） |   （即全局寄存器s0-s7）</span><br><span class="line"> *          |- - - - - - - |</span><br><span class="line"> *          |  被调用者参数  |   （包括a0-a3。从高到低，先压最后一个参数）</span><br><span class="line"> *  sp-&gt;    |- - - - - - - |</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p><img src="/../assets/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/mips-stackframe.png" alt="mips-stackframe"></p></li><li><p>函数调用设计：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* 【调用者动作】：</span><br><span class="line">*          1. 保存ra寄存器</span><br><span class="line">*          2. 将后续需要用到的保留寄存器值存入栈中</span><br><span class="line">*          3. 将参数压栈、[如果a0-a3有冲突（需要传递且后续要用到），则需要保存并恢复]</span><br><span class="line">*          4. 更改sp寄存器的值</span><br><span class="line">*          5. 使用jal指令</span><br><span class="line">*          6. 取v0返回值并填入相应寄存器（若有返回值）</span><br><span class="line">*          7. 将sp寄存器的值恢复</span><br><span class="line">*          8. 恢复ra寄存器值、保存的寄存器值、恢复冲突的a0-a3寄存器值</span><br><span class="line">*          9. 继续其他指令……</span><br><span class="line">*  【被调用者动作】：</span><br><span class="line">*          1. 执行函数逻辑，若使用参数则取寄存器值或栈上值</span><br><span class="line">*          2. 执行到ret指令，返回值存入v0（若有）</span><br><span class="line">*          3. 使用jr ra返回</span><br></pre></td></tr></table></figure><ul><li>需要注意的是，由于被调用者需要靠偏移取参数，所以在将参数压栈时，应该保证不会出现寄存器溢出的情况，否则会导致偏移与参数不对应。</li></ul></li></ul><h2 id="6-2-编码后的设计"><a href="#6-2-编码后的设计" class="headerlink" title="6.2 编码后的设计"></a>6.2 编码后的设计</h2><ul><li>遵循<strong>里氏替换原则</strong>和<strong>开放封闭原则</strong>，将LLVM IR和MIPS的指令都设置为一个接口或抽象类，并在具体的每条指令中重写对应的输出方法，调用者使用指令类的多态属性完成每条指令的输出。且当需要新增指令时，不需要修改原来的代码，只需要新增类并继承抽象父类或实现接口即可。</li></ul><h1 id="7-代码优化设计"><a href="#7-代码优化设计" class="headerlink" title="7. 代码优化设计"></a>7. 代码优化设计</h1><h2 id="7-1-寄存器分配"><a href="#7-1-寄存器分配" class="headerlink" title="7.1. 寄存器分配"></a>7.1. 寄存器分配</h2><p>在目标代码生成的指导书中：</p><blockquote><p>在 MIPS 这种<strong>寄存器到寄存器</strong>模型中，每个参与运算的值都必须被加载到寄存器中，因此在我们的 IR 中，参与运算的变量都应该对应一个寄存器，在 IR 中，我们将其称为<strong>虚拟寄存器</strong>。虚拟寄存器数目是无限的，但是当翻译为目标平台的汇编代码时，就需要将其映射到一组有限的寄存器中，这个过程就是<strong>寄存器分配</strong>。</p><p>对于规范的寄存器分配，则需要考虑<strong>全局寄存器</strong>和<strong>局部寄存器</strong>的分配，分别对应 MIPS 中的 <code>s</code> 和 <code>t</code> 寄存器。……</p></blockquote><p>因此，<strong>我在生成目标代码时就已经分配了寄存器</strong>（因此优化前和优化后finalCycle差距可能不大）。以下是具体实现思路。</p><h3 id="7-1-1-跨块活跃变量：采用图着色法分配全局寄存器"><a href="#7-1-1-跨块活跃变量：采用图着色法分配全局寄存器" class="headerlink" title="7.1.1 跨块活跃变量：采用图着色法分配全局寄存器"></a>7.1.1 跨块活跃变量：采用图着色法分配全局寄存器</h3><h4 id="7-1-1-1-数据流分析"><a href="#7-1-1-1-数据流分析" class="headerlink" title="7.1.1.1 数据流分析"></a>7.1.1.1 数据流分析</h4><p>在LLVM IR每条具体指令类中添加<code>def</code>和<code>use</code>集，并在构造方法中将对应变量加入这两个集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当有集合的in集发生变化时，继续迭代</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(changed) &#123;</span><br><span class="line">    changed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> basicBlocks.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">BasicBlock</span> <span class="variable">basicBlock</span> <span class="operator">=</span> basicBlocks.get(i);</span><br><span class="line">        <span class="comment">// BasicBlock的liveOut集合为其所有后继的liveIn集合的并集</span></span><br><span class="line">        <span class="keyword">for</span> (BasicBlock succ: basicBlock.succs) &#123;</span><br><span class="line">            basicBlock.liveOut.addAll(succ.liveIn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算每条指令的in集和out集</span></span><br><span class="line">        List&lt;Instruction&gt; instructions = basicBlock.instructions;</span><br><span class="line">        <span class="comment">// BasicBlock的最后一条指令的liveOut集合即为liveOut集合</span></span><br><span class="line">        Set&lt;Slot&gt; succsLiveIn = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(basicBlock.liveOut);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> instructions.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">Instruction</span> <span class="variable">instruction</span> <span class="operator">=</span> instructions.get(j);</span><br><span class="line">            instruction.liveOut = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(succsLiveIn);   <span class="comment">// 每条指令的liveOut集合为其后继的liveIn集合</span></span><br><span class="line">            instruction.liveIn = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(instruction.liveOut);</span><br><span class="line">            instruction.liveIn.removeAll(instruction.def);</span><br><span class="line">            instruction.liveIn.addAll(instruction.use);</span><br><span class="line">            succsLiveIn = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(instruction.liveIn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一条指令的liveIn集合即为BasicBlock的liveIn集合</span></span><br><span class="line">        <span class="keyword">if</span> (!basicBlock.liveIn.equals(succsLiveIn)) &#123;</span><br><span class="line">            changed = <span class="literal">true</span>;</span><br><span class="line">            basicBlock.liveIn = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(succsLiveIn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在对每条指令的<code>liveIn</code>和<code>liveOut</code>集计算的基础上，计算基本块的<code>liveIn</code>和<code>liveOut</code>集。</p><p>需要注意在计算函数的跨块活跃变量时，将所有的<code>liveIn</code>和<code>liveOut</code>集变量加入后，需要删除所有作为函数参数的变量（包括指针型）。<br>这是因为函数参数一概不分配寄存器，因此尽管在参数中出现，也不加入跨块活跃变量集合。</p><h4 id="7-1-1-2-图着色算法"><a href="#7-1-1-2-图着色算法" class="headerlink" title="7.1.1.2 图着色算法"></a>7.1.1.2 图着色算法</h4><p>为了简便，我在实现中对冲突的定义是：活跃范围重合。因此，在数据流分析后，同时出现在<code>liveIn</code>或<code>liveOut</code>集合的、以及在块内活跃范围冲突的变量视为冲突。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造冲突图</span></span><br><span class="line"><span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(); <span class="comment">// 用于移除节点得到队列</span></span><br><span class="line"><span class="type">Graph</span> <span class="variable">conflict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(); <span class="comment">// 副本，用于保存冲突图</span></span><br><span class="line"><span class="keyword">for</span> (Slot node: function.interBlockLive) &#123;</span><br><span class="line">    graph.addNode(node);</span><br><span class="line">    conflict.addNode(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在liveIn和liveOut中同时出现的变量，即为冲突变量，添加边</span></span><br><span class="line"><span class="keyword">for</span> (BasicBlock block: function.basicBlocks) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Slot slot1: block.liveIn) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Slot slot2: block.liveIn) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slot1 != slot2 &amp;&amp;</span><br><span class="line">                function.interBlockLive.contains(slot1) &amp;&amp;</span><br><span class="line">                function.interBlockLive.contains(slot2)) &#123;</span><br><span class="line">                graph.addEdge(slot1, slot2);</span><br><span class="line">                conflict.addEdge(slot1, slot2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Slot slot1: block.liveOut) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Slot slot2: block.liveOut) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slot1 != slot2 &amp;&amp;</span><br><span class="line">                function.interBlockLive.contains(slot1) &amp;&amp;</span><br><span class="line">                function.interBlockLive.contains(slot2)) &#123;</span><br><span class="line">                graph.addEdge(slot1, slot2);</span><br><span class="line">                conflict.addEdge(slot1, slot2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对每个基本块，检查只出现在 in 或 out 中的变量，若活性范围冲突则也添加冲突边</span></span><br><span class="line"><span class="keyword">for</span> (BasicBlock block: function.basicBlocks) &#123;</span><br><span class="line">    Set&lt;Slot&gt; intersection = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(block.liveIn);   <span class="comment">// 交集</span></span><br><span class="line">    intersection.retainAll(block.liveOut);</span><br><span class="line"></span><br><span class="line">    Set&lt;Slot&gt; liveInRemoveInter = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(block.liveIn);</span><br><span class="line">    liveInRemoveInter.removeAll(intersection);</span><br><span class="line">    Set&lt;Slot&gt; liveOutRemoveInter = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(block.liveOut);</span><br><span class="line">    liveOutRemoveInter.removeAll(intersection);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Slot slot1: liveInRemoveInter) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Slot slot2: liveOutRemoveInter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (function.interBlockLive.contains(slot1) &amp;&amp;</span><br><span class="line">                    function.interBlockLive.contains(slot2)) &#123;</span><br><span class="line">                <span class="comment">// 滤去函数参数等不跨块活跃的变量</span></span><br><span class="line">                <span class="type">Instruction</span> <span class="variable">defInst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (Instruction inst: block.instructions) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (inst.def.contains(slot2)) &#123;</span><br><span class="line">                        <span class="comment">// slot2只出现在liveOut中，则有一条定义它的指令</span></span><br><span class="line">                        defInst = inst;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 定义后，slot1仍活跃，即为冲突</span></span><br><span class="line">                <span class="keyword">if</span> (defInst.liveOut.contains(slot1)) &#123;</span><br><span class="line">                    graph.addEdge(slot1, slot2);</span><br><span class="line">                    conflict.addEdge(slot1, slot2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中保存冲突图的副本是为了在后续移走节点也能查询到每个变量的冲突情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Slot&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 执行图着色算法</span></span><br><span class="line"><span class="keyword">while</span> (graph.getNodesNum() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">canRemove</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 【为保证移出顺序，先对邻接表排序】</span></span><br><span class="line">    List&lt;Map.Entry&lt;Slot, Set&lt;Slot&gt;&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(graph.adjacencyList.entrySet());</span><br><span class="line">    list.sort(Comparator.comparingInt(o -&gt; o.getKey().slotId));</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Slot, Set&lt;Slot&gt;&gt; entry : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph.getDegree(entry.getKey()) &lt; RegisterPool.savedRegisters.size()) &#123;</span><br><span class="line">            queue.addLast(entry.getKey());</span><br><span class="line">            graph.removeNode(entry.getKey());</span><br><span class="line">            canRemove = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;remove &quot;</span> + entry.getKey().toText());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!canRemove) &#123;</span><br><span class="line">        <span class="comment">// 若无法删除节点，即图中存在度数大于等于寄存器数量的节点，保存在栈上</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 优化时，选择引用次数最少的节点进行合并</span></span><br><span class="line">        <span class="type">Slot</span> <span class="variable">remove</span> <span class="operator">=</span> list.get(<span class="number">0</span>).getKey();</span><br><span class="line">        graph.removeNode(remove);</span><br><span class="line">        conflict.removeNode(remove);    <span class="comment">// 【不分配，移出冲突图】</span></span><br><span class="line">        System.out.println(<span class="string">&quot;spill &quot;</span> + remove.toText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照结点移走的反向顺序将点和边添加回去，并分配颜色</span></span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="type">Slot</span> <span class="variable">slot</span> <span class="operator">=</span> queue.removeLast();</span><br><span class="line">    graph.addNode(slot);</span><br><span class="line">    List&lt;Register&gt; available = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(RegisterPool.savedRegisters);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Slot, Set&lt;Slot&gt;&gt; entry: graph.adjacencyList.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (conflict.adjacencyList.get(slot).contains(entry.getKey())) &#123;</span><br><span class="line">            <span class="comment">// 若已在图中的节点与此节点存在冲突</span></span><br><span class="line">            available.remove(registerPool.globalAllocation.get(entry.getKey()));</span><br><span class="line">            graph.addEdge(slot, entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 挑选一个可用的寄存器着色</span></span><br><span class="line">    <span class="keyword">assert</span> !available.isEmpty();</span><br><span class="line">    registerPool.globalAllocation.put(slot, available.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对于选择哪个节点移除暂时没有实现选择算法，后续可能优化为引用次数最少的不分配全局寄存器。</p><p>需要注意由于<code>HashMap</code>遍历顺序的不确定性，需要先将其排序再进行后续操作。</p><h3 id="7-1-2-不跨块活跃的变量：采用寄存器池分配临时寄存器"><a href="#7-1-2-不跨块活跃的变量：采用寄存器池分配临时寄存器" class="headerlink" title="7.1.2 不跨块活跃的变量：采用寄存器池分配临时寄存器"></a>7.1.2 不跨块活跃的变量：采用寄存器池分配临时寄存器</h3><p>在后端实现了一个<code>RegisterPool.java</code>类，虽然全局寄存器不使用寄存器池分配，但是实现这个类可以便于对变量对应的寄存器统一管理。生成目标代码时，可以统一使用提供的接口找到对应的寄存器。</p><p>总的来说，我实现的临时寄存器池使用<strong>FIFO算法</strong>，维护一个<code>allocated</code>表和<code>tempQueue</code>，前者存储变量对应的寄存器，后者是一个记录分配顺序的队列。当新增变量时，从寄存器池中分配一个变量，并添加<code>allocated</code>表项、加入<code>tempQueue</code>队尾；当释放寄存器时，移除<code>allocated</code>表项以及<code>tempQueue</code>对应寄存器；当寄存器不够需要溢出时，取<code>tempQueue</code>的队首溢出到内存并分配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配临时寄存器并与Slot【绑定】</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> slot 需要分配的slot</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> curStackFrame 当前的栈帧</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 分配的寄存器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Register <span class="title function_">bindAllocTemp</span><span class="params">(Slot slot, StackFrame curStackFrame)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是跨块活跃变量，分配保留寄存器，否则分配临时寄存器</span></span><br><span class="line">    <span class="keyword">for</span> (Register r: tempRegisters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!allocated.containsValue(r)) &#123;</span><br><span class="line">            <span class="comment">// 若空闲，即找到</span></span><br><span class="line">            tempQueue.addLast(r);</span><br><span class="line">            allocated.put(slot, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 溢出处理</span></span><br><span class="line">    <span class="keyword">return</span> spill(slot, curStackFrame);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 溢出处理，将溢出寄存器的值存到栈上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> curStackFrame 当前的栈帧</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> slot 需要分配的slot，可为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Register <span class="title function_">spill</span><span class="params">(Slot slot, StackFrame curStackFrame)</span> &#123;</span><br><span class="line">    <span class="comment">// FIFO算法，取出最早分配的寄存器</span></span><br><span class="line">    <span class="type">Register</span> <span class="variable">spillRegister</span> <span class="operator">=</span> tempQueue.removeFirst();</span><br><span class="line">    <span class="type">Slot</span> <span class="variable">spillSlot</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Slot, Register&gt; entry: allocated.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == spillRegister) &#123;</span><br><span class="line">            spillSlot = entry.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将寄存器的值存到栈上</span></span><br><span class="line">    curStackFrame.recordLocal(spillSlot, <span class="number">4</span>);</span><br><span class="line">    mipsCode.addMIPSInst(<span class="keyword">new</span> <span class="title class_">SW</span>(spillRegister, Register.SP, -curStackFrame.getSize()).setComment(<span class="string">&quot;\tspill reg of &quot;</span> + spillSlot.toText()));</span><br><span class="line">    <span class="comment">// 移除allocated中的记录</span></span><br><span class="line">    allocated.remove(spillSlot);</span><br><span class="line">    <span class="keyword">if</span> (slot != <span class="literal">null</span>) &#123;</span><br><span class="line">        tempQueue.addLast(spillRegister);</span><br><span class="line">        allocated.put(slot, spillRegister);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> spillRegister;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，每条指令的翻译步骤即：</p><blockquote><ol><li>使用 find 获取 use 的寄存器</li><li>使用 deallocUse 回收 use 中不活跃变量的寄存器</li><li>使用 allocDef 分配 def 使用的寄存器【allocDef可能返回null，此时需要保存到栈上】</li><li>使用 allocTemp 分配不绑定slot的寄存器</li><li>生成MIPS指令</li></ol></blockquote><p>这些步骤不能随意调换顺序。具体来说：</p><ul><li>先<code>find</code>再<code>deallocUse</code>（否则找不到就释放了）</li><li>先<code>deallocUse</code>再<code>allocDef</code>（这样可以立即使用use不再使用的寄存器，例如addiu $t0, $t0, -4这种指令）</li><li>先<code>allocDef</code>再<code>allocTemp</code>。（否则，因为后者不绑定Slot，会分配到一样的寄存器而出错）</li></ul><blockquote><p>此优化与MIPS生成一起完成，因此提交的优化前目标代码与此一致。</p></blockquote><h2 id="7-2-基本块合并"><a href="#7-2-基本块合并" class="headerlink" title="7.2. 基本块合并"></a>7.2. 基本块合并</h2><p>例如，在公开testcase7中，生成了如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">101:                          ; preds = 96</span><br><span class="line">    %102 = load i32, i32* %1      ;load value of i</span><br><span class="line">    %103 = getelementptr [10 x i32], [10 x i32]* @a, i32 0, i32 %102      ;get &amp;a[%102]</span><br><span class="line">    %104 = load i32, i32* %103    ;load value of a[%102]</span><br><span class="line">    call void @putint(i32 %104)</span><br><span class="line">    call void @putstr(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.0, i64 0, i64 0))</span><br><span class="line">    %105 = load i32, i32* %1      ;load value of i</span><br><span class="line">    %106 = add i32 %105, 1</span><br><span class="line">    store i32 %106, i32* %1</span><br><span class="line">    br label %107</span><br><span class="line">107:                          ; preds = 101</span><br><span class="line">    br label %96</span><br><span class="line">108: ; preds = 96</span><br></pre></td></tr></table></figure><p>经过基本块合并优化后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">101:                          ; preds = 96</span><br><span class="line">    %102 = load i32, i32* %1      ;load value of i</span><br><span class="line">    %103 = getelementptr [10 x i32], [10 x i32]* @a, i32 0, i32 %102      ;get &amp;a[%102]</span><br><span class="line">    %104 = load i32, i32* %103    ;load value of a[%102]</span><br><span class="line">    call void @putint(i32 %104)</span><br><span class="line">    call void @putstr(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.0, i64 0, i64 0))</span><br><span class="line">    %105 = load i32, i32* %1      ;load value of i</span><br><span class="line">    %106 = add i32 %105, 1</span><br><span class="line">    store i32 %106, i32* %1</span><br><span class="line">    br label %96</span><br><span class="line">107:                          ; preds = 96</span><br></pre></td></tr></table></figure><h2 id="7-3-乘除法优化"><a href="#7-3-乘除法优化" class="headerlink" title="7.3. 乘除法优化"></a>7.3. 乘除法优化</h2><p>只针对第二个操作数为立即数的乘除指令进行优化。</p><h3 id="7-3-1-乘法优化"><a href="#7-3-1-乘法优化" class="headerlink" title="7.3.1 乘法优化"></a>7.3.1 乘法优化</h3><p>对于乘数为0、1、2的整数幂、2的整数幂的相反数、2的整数幂-1、2的整数幂-2、2的整数幂+1进行优化，转为若干移位指令和加减指令。</p><h3 id="7-3-2-除法优化"><a href="#7-3-2-除法优化" class="headerlink" title="7.3.2 除法优化"></a>7.3.2 除法优化</h3><p>对于除数为2的整数幂、2的整数幂的相反数进行优化。</p><p>此外，对于能转化为乘法和移位运算的进行优化，例如对于testcase7中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div $t0, $t0, 5</span><br></pre></td></tr></table></figure><p>被优化为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    slt $t1, $zero, $t0</span><br><span class="line">    bnez $t1, _L_divOptimize_0</span><br><span class="line">    subu $t0, $zero, $t0</span><br><span class="line">_L_divOptimize_0:</span><br><span class="line">    li $t2, 3435973837</span><br><span class="line">    multu $t0, $t2</span><br><span class="line">    mfhi $t0</span><br><span class="line">    sra $t0, $t0, 2</span><br><span class="line">    bnez $t1, _L_divOptimize_1</span><br><span class="line">    subu $t0, $zero, $t0</span><br><span class="line">_L_divOptimize_1:</span><br></pre></td></tr></table></figure><p>需要注意，优化时，需要分正负两种情况，不然会产生错误。</p><h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><p>由于生成MIPS时直接完成寄存器分配这一“优化任务”，因此耗费了许多时间。最后因时间紧迫，其他优化暂时没有完成。</p><blockquote><p>Author：bush</p><p>更新日志：</p><ul><li>2024.9.24：完成词法分析，完成文档#1、#2、#3</li><li>2024.10.14：完成语法分析及此部分文档#4，修改#2.2，新增#3.2.3</li><li>2024.10.19：在期中模拟考发现回溯时未回溯已抛出错误导致多输出错误，修改#4.2.5</li><li>2024.11.2：完成语义分析，完成文档#5</li><li>2024.12.12：完成MIPS代码生成，完成文档#6</li><li>2024.12.17：完成优化文档#7</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编译技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
