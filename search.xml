<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法导论笔记整理回顾</title>
      <link href="/2025/07/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E5%9B%9E%E9%A1%BE/"/>
      <url>/2025/07/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是笔者大二上学的课了，现在把之前的笔记整理复习一遍。</p><p>部分内容由AI生成。。。</p></blockquote><h1>第2章 算法基础</h1><h2 id="2-1-插入排序">2.1 插入排序</h2><p>c++代码：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSERTION-SORT(A)</span><br><span class="line"><span class="keyword">for</span> j = <span class="number">2</span> <span class="keyword">to</span> A.length</span><br><span class="line">key = A[j]</span><br><span class="line">i = j - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key</span><br><span class="line">A[i+<span class="number">1</span>] =A[i];</span><br><span class="line">i = i - <span class="number">1</span>;</span><br><span class="line">A[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**插入排序</span></span><br><span class="line"><span class="comment">@para array and array&#x27;s length</span></span><br><span class="line"><span class="comment">下标从0开始</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="type">int</span>&amp; A, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line"><span class="type">int</span> key = A[j];</span><br><span class="line">i = j - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; A[i] &gt; key)&#123;</span><br><span class="line">A[i + <span class="number">1</span>] = A[i];</span><br><span class="line">i = i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> A[i + <span class="number">1</span>] = key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-分析算法">2.2 分析算法</h2><h2 id="2-3-设计算法">2.3 设计算法</h2><h3 id="分治法：">分治法：</h3><ol><li>**分解：**原问题为若干子问题，这些子问题是原问题的规模较小的实例</li><li>**解决：**解决这些子问题，递归地求解各子问题</li><li>**合并：**合并这些子问题的解成原问题的解</li></ol><h3 id="归并排序：">归并排序：</h3><p>归并排序是一种采用分治法思想的排序算法。它的基本思想是将待排序的序列不断划分为更小的子序列，直到每个子序列只有一个元素，然后再将这些子序列两两合并，最终得到一个有序的序列。</p><p>下面是归并排序的C++代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = q - p + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n2 = r - q;</span><br><span class="line"><span class="comment">//分割成A[p,q],A[q+1,r]</span></span><br><span class="line">    <span class="type">int</span>* L = <span class="keyword">new</span> <span class="type">int</span>[n1];</span><br><span class="line">    <span class="type">int</span>* R = <span class="keyword">new</span> <span class="type">int</span>[n2];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">        L[i] = arr[p + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n2; j++)</span><br><span class="line">        R[j] = arr[q + <span class="number">1</span> + j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;</span><br><span class="line">            arr[k] = L[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = R[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k] = L[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k] = R[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] L;</span><br><span class="line">    <span class="keyword">delete</span>[] R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> p, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> q = (p + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, p, q);</span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, q + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">merge</span>(arr, p, q, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用归并排序算法可以对数组进行排序。</p><h3 id="递归算法的时间复杂度分析">递归算法的时间复杂度分析</h3><p>对于递归算法的时间复杂度分析，可以使用递归树来进行推导。递归树的每一层表示递归算法的一次调用，而每一层中的节点表示该层中执行的基本操作次数。</p><p>以归并排序算法为例，设原始序列的长度为n。在每次递归调用中，将序列划分为两个子序列，直到每个子序列只有一个元素为止。因此，递归树的高度为log(n)。</p><p>在每一层的合并操作中，需要将两个子序列合并为一个有序的序列。合并操作的时间复杂度为O(n)，其中n表示当前层的序列长度。</p><p>因此，递归算法的总时间复杂度可以表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(n) = 2T(n/2) + O(n)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据主定理，可以得到归并排序的时间复杂度为O(nlog(n))。</p><p>总结：递归算法的时间复杂度分析需要考虑递归树的高度和每层的操作次数，通过递归关系式和主定理来计算总的时间复杂度。</p><h1>第3章 函数的增长</h1><h2 id="3-1-渐进记号">3.1 渐进记号</h2><h3 id="算法的渐进记号及含义">算法的渐进记号及含义</h3><p>在计算机科学中，我们使用渐进记号来描述算法的时间复杂度和空间复杂度。以下是常见的渐进记号及其含义：</p><ul><li>大O记号（O）：表示算法的上界，即算法的最坏情况时间复杂度。例如，O(n)表示线性时间复杂度，O(n^2)表示平方时间复杂度。</li><li>Ω记号（Ω）：表示算法的下界，即算法的最好情况时间复杂度。例如，Ω(n)表示线性时间复杂度，Ω(1)表示常数时间复杂度。</li><li>Θ记号（Θ）：表示算法的紧密界限，即算法的平均情况时间复杂度。例如，Θ(n)表示线性时间复杂度，Θ(1)表示常数时间复杂度。</li><li>小o记号（o）：表示算法的非紧密界限，即算法的最好情况时间复杂度没有上界。例如，o(n)表示比线性时间复杂度更好的复杂度。</li><li>小ω记号（ω）：表示算法的非紧密界限，即算法的最坏情况时间复杂度没有下界。例如，ω(n)表示比线性时间复杂度更差的复杂度。</li></ul><p>这些渐进记号帮助我们比较和分析不同算法的性能，以便选择最适合特定问题的算法。</p><h1>第4章 分治策略</h1><p>在算法中，求解递归式（recurrence relation）的方法有几种常见的技巧。这些方法对于分析算法的时间复杂度非常有帮助。以下是一些常见的求解递归式的方法：</p><ol><li><strong>代入法（Substitution Method）：</strong> 这是一种直观的方法，其中你猜测解的形式，然后用数学归纳法证明你的猜测是正确的。</li><li><strong>递归树法（Recurrence Tree Method）：</strong> 将递归式表示为一棵树，然后分析这棵树的深度和每个层次的代价。这对于理解递归调用的次数以及每次调用的代价很有帮助。</li><li><strong>主方法（Master Theorem）：</strong> 主方法是一种特定形式递归式的通用解法，适用于具有特定形式的分治算法。主方法有三种情况，每种情况对应于不同类型的递归式。</li></ol><p>这些方法通常在分析递归算法的时间复杂度时使用。选择哪种方法取决于递归式的形式以及你希望分析的粒度。在学习算法和数据结构时，这些方法通常会在课程中进行详细讲解。</p><p>主方法（Master Theorem）是一种用于分析递归算法时间复杂度的技术，特别适用于分治算法。主方法提供了一种简化的方式来确定递归算法的时间复杂度，尤其是对于具有特定形式的递归式。主方法通常用于解决以下形式的递归关系：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>⋅</mo><mi>T</mi><mrow><mo fence="true">(</mo><mfrac><mi>n</mi><mi>b</mi></mfrac><mo fence="true">)</mo></mrow><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = a \cdot T\left(\frac{n}{b}\right) + f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 是递归函数的时间复杂度。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 是递归调用的次数。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 是问题规模缩小的比例。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 是递归之外的其他操作的时间复杂度。</li></ul><p>主方法的一般形式为：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>⋅</mo><mi>T</mi><mrow><mo fence="true">(</mo><mfrac><mi>n</mi><mi>b</mi></mfrac><mo fence="true">)</mo></mrow><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mi>n</mi><mo>=</mo><msup><mi>b</mi><mi>i</mi></msup></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">T(n) = \begin{cases} \Theta (1) &amp; ,n=1\\a \cdot T\left(\frac{n}{b}\right) + f(n)&amp;,n=b^i\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≥</mo><mn>1</mn><mtext>，</mtext><mi>b</mi><mo>&gt;</mo><mn>1</mn><mtext>，</mtext><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \geq 1，b &gt; 1 ，f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 是渐进正函数。</p><p>主方法定理提供了对这类递归式的通用解决方案，其中包含了三种情况。这些情况涵盖了许多常见的递归算法。具体的情况取决于 a，b，和 f(n) 的关系。</p><p>主方法的三种情况如下：</p><ol><li><p><strong>情况一：</strong> 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>b</mi></msub><mrow><mi>a</mi><mo>−</mo><mi>ϵ</mi></mrow></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{\log_b{a - \epsilon}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2302em;"><span style="top:-2.2341em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2659em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">ϵ</span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>（其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\epsilon &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>），那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>b</mi></msub><mi>a</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Θ(n^{\log_b{a}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2302em;"><span style="top:-2.2341em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2659em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p></li><li><p><strong>情况二：</strong> 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>b</mi></msub><mi>a</mi></mrow></msup><mo>⋅</mo><msup><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>k</mi></msup><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Θ(n^{\log_b{a}} \cdot \log^k n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2302em;"><span style="top:-2.2341em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2659em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1834em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9334em;"><span style="top:-3.1473em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>（其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k \geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>），那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>b</mi></msub><mi>a</mi></mrow></msup><mo>⋅</mo><msup><mrow><mi>log</mi><mo>⁡</mo></mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Θ(n^{\log_b{a}} \cdot \log^{k+1} n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2302em;"><span style="top:-2.2341em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2659em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1834em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9334em;"><span style="top:-3.1473em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><aside>💡 特别地，如果$f(n)=\Theta(n^{\log_ba})$，则$T(n)=\Theta(n^{\log_ba}\cdot \log n)$。</aside></li><li><p><strong>情况三：</strong> 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>b</mi></msub><mrow><mi>a</mi><mo>+</mo><mi>ϵ</mi></mrow></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ω(n^{\log_b{a + \epsilon}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2302em;"><span style="top:-2.2341em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2659em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">ϵ</span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>（其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\epsilon &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>），如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>f</mi><mrow><mo fence="true">(</mo><mfrac><mi>n</mi><mi>b</mi></mfrac><mo fence="true">)</mo></mrow><mo>≤</mo><mi>k</mi><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a f\left(\frac{n}{b}\right) \leq kf(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>（其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k &lt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>）对于足够大的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 成立，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Θ(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span>。</p></li></ol><p>在应用主方法时，首先需要将递归式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 表达为上述形式，然后根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的增长速度与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>b</mi></msub><mi>a</mi></mrow></msup></mrow><annotation encoding="application/x-tex">n^{\log_b{a}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2302em;"><span style="top:-2.2341em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2659em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span></span></span></span></span></span></span></span></span> 进行比较，确定适用于哪一种情况。这样可以更方便地推导递归算法的渐进时间复杂度。</p><hr><p>P55 练习4.5-1</p><ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>4</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T(n)=2T(n/4)+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，a=2，b=4，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi></mrow><annotation encoding="application/x-tex">log_ba</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">a</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">=\frac 12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>n</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">f(n)=n^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi></mrow></msup><mo>−</mo><mi>ϵ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">=O(n^{log_ba}-\epsilon)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">o</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight">a</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϵ</span><span class="mclose">)</span></span></span></span>，因此<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msqrt><mi>n</mi></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=\Theta(\sqrt n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0503em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="padding-left:0.833em;">n</span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。、</li><li>同理，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msqrt><mi>n</mi></msqrt><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=\Theta(\sqrt n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0503em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="padding-left:0.833em;">n</span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=\Theta(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ol><hr><h1>第6章 堆排序</h1><h2 id="堆、堆排序算法">堆、堆排序算法</h2><p>堆（Heap）是一种数据结构，通常用于实现优先队列。堆分为最大堆和最小堆，最大堆的每个节点的值都大于或等于其子节点，而最小堆的每个节点的值都小于或等于其子节点。</p><p>堆排序算法是一种基于堆数据结构的排序方法。它的基本思想是首先将待排序的元素构建成一个最大堆或最小堆，然后依次将堆顶元素（最大值或最小值）取出并调整堆，直到所有元素都被取出，从而得到一个有序序列。</p><p>堆排序的步骤如下：</p><ol><li>构建堆：将待排序的元素按顺序插入到堆中，然后依次调整堆，使得每个节点都满足堆的性质。</li><li>堆顶元素与末尾元素交换：将堆顶元素与堆的最后一个元素交换位置。</li><li>调整堆：将交换后的堆顶元素重新调整为堆，保持堆的性质。</li><li>重复步骤2和步骤3，直到堆为空。</li></ol><p>堆排序的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中n是待排序元素的个数。它是一种原地排序算法，不需要额外的空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整堆的函数，确保以i为根的子树是一个最大堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;    <span class="comment">// 初始化最大元素的索引为当前节点</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;   <span class="comment">// 左子节点的索引</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;  <span class="comment">// 右子节点的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较左子节点与当前节点的值，找出较大值的索引</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])</span><br><span class="line">        largest = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较右子节点与当前节点的值，找出较大值的索引</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">        largest = right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大值的索引不是当前节点，交换它们，并递归调整交换后的子树</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line"><span class="comment">// 最后一个节点的下标为n-1，则父节点的下标为n/2-1：</span></span><br><span class="line"><span class="comment">// 若为左节点，n-1为奇，n为偶，（n-1-1）/2=n/2-1</span></span><br><span class="line"><span class="comment">// 若为右节点，n-1为偶，n为奇，（n-1-2）/2=（n-1）/2-1=[n/2]-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换堆顶元素与末尾元素，然后调整堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用堆排序函数</span></span><br><span class="line">    <span class="built_in">heapSort</span>(arr);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后的数组：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序">快速排序</h2><p>快速排序是一种常用的排序算法，它基于分治的思想。其主要步骤包括选择一个基准元素，将数组分成两部分，小于基准的元素放在左边，大于基准的元素放在右边，然后对左右两部分分别递归进行快速排序。</p><p>以下是快速排序的基本原理：</p><ol><li><strong>选择基准元素：</strong> 从数组中选择一个元素作为基准，通常选择最后一个元素。</li><li><strong>分区：</strong> 将数组重新排列，使得小于基准的元素在基准的左边，大于基准的元素在基准的右边。基准元素最终在其最终排序的位置上。</li><li><strong>递归：</strong> 对基准元素左右两边的子数组分别递归应用快速排序。</li></ol><p>下面是一个简单的C++实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数，选取最后一个元素作为基准值，将小于基准值的元素放在左侧，大于基准值的元素放在右侧</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];  <span class="comment">// 选择最后一个元素作为基准值</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;  <span class="comment">// 初始化i为比基准值小的元素的最后一个索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组，将小于基准值的元素交换到左侧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt; high; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将基准值放到最终的位置上</span></span><br><span class="line">    <span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[high]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 找到基准值的位置</span></span><br><span class="line">        <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(arr, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归对基准值左右两侧的子数组进行快速排序</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pivotIndex + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用快速排序函数</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后的数组：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>partition</code> 函数用于对数组进行分区，确定基准值的位置。然后，<code>quickSort</code> 函数递归地对基准值左右两侧的子数组进行快速排序。整体的快速排序算法时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><hr><p>快速排序的平均时间复杂度是 O(n log n)。这使得它成为一种非常高效的排序算法。</p><p>以下是快速排序时间复杂度的详细分析：</p><ol><li><strong>最好情况：</strong><ul><li>在最好的情况下，每次选择的基准值都将数组准确地分成两个大小相等的子数组。这导致递归树是平衡的，每一层都有 O(n) 个元素。</li><li>在这种情况下，递归的深度是 O(log n)，因为每次都将数组一分为二。</li><li>最好情况下的时间复杂度是 O(n log n)。</li></ul></li><li><strong>最坏情况：</strong><ul><li>在最坏的情况下，每次选择的基准值都是数组中的最小或最大元素。这导致递归树是不平衡的，其中一个分支没有元素，而另一个分支有 n-1 个元素。</li><li>在这种情况下，递归的深度是 O(n)。</li><li>最坏情况下的时间复杂度是 O(n^2)。</li></ul></li><li><strong>平均情况：</strong><ul><li>平均情况下，快速排序的时间复杂度为 O(n log n)。</li><li>这是通过对所有可能的输入情况进行平均计算得出的结果。</li><li>在实际应用中，快速排序通常是最好的选择，因为它的平均性能非常好。</li></ul></li></ol><p>总体而言，快速排序在平均情况下的性能较好，但在最坏情况下可能变得不太理想。为了降低最坏情况的发生概率，通常可以采用随机化的方法来选择基准值，或者采用三数中值分割法等策略来选择更好的基准值。这些方法可以提高快速排序的稳定性。</p><h1>第7章 快速排序</h1><p>快速排序（Quick Sort）是一种常用的排序算法，它基于分治法（Divide and Conquer）的思想。分治法的基本思想是将问题分成一些小的子问题，递归地解决这些子问题，然后合并其结果以解决原始问题。</p><p>以下是快速排序的详细过程：</p><ol><li><strong>选择枢纽元素：</strong> 从数组中选择一个元素作为枢纽元素（pivot）。通常选择数组的最后一个元素，但也可以选择其他位置的元素。</li><li><strong>分割阶段：</strong> 将数组中的元素重新排列，使得小于枢纽元素的元素位于其左侧，而大于枢纽元素的元素位于其右侧。枢纽元素此时已经处于正确的位置，称为分割点（pivot point）。<ul><li>设置两个指针，一个指向当前处理的元素，一个指向数组的起始位置。开始时，两个指针重合。</li><li>从数组的起始位置遍历到倒数第二个元素，将小于枢纽元素的元素交换到左侧，同时移动指针。</li><li>最后，将枢纽元素交换到正确的位置，使得左侧的元素都小于它，右侧的元素都大于它。</li><li>分割点的位置确定后，数组被分成两个部分，分别对这两个部分递归地应用快速排序。</li></ul></li><li><strong>递归排序：</strong> 对分割点左右两侧的子数组分别进行递归排序。</li><li><strong>合并：</strong> 递归排序的最终结果就是整个数组有序。由于分治法的特性，各个子数组在排序完成后，整个数组也就自然有序了。</li></ol><p>下面是一个简单的例子，演示了快速排序的过程：</p><p>假设数组为 <code>[12, 7, 11, 8, 5, 3, 2, 10]</code>，选择最后一个元素 10 作为枢纽元素：</p><ol><li>初始数组：<code>[12, 7, 11, 8, 5, 3, 2, 10]</code></li><li>枢纽元素选择为 10，分割点位置：4</li><li>分割后的数组：<code>[7, 8, 5, 3, 2, 10, 12, 11]</code></li><li>递归排序左侧子数组 <code>[7, 8, 5, 3, 2]</code></li><li>递归排序右侧子数组 <code>[12, 11]</code></li><li>最终有序数组：<code>[2, 3, 5, 7, 8, 10, 11, 12]</code></li></ol><p>这就是快速排序的基本思想和实现过程。它的平均时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组的长度。快速排序在实践中表现出色，被广泛应用于各种应用场景。</p><p>快速排序（Quick Sort）是一种常用的排序算法，属于分治法的一种。以下是一个简单的C++实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分割数组并返回分割点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];  <span class="comment">// 选择数组最后一个元素作为枢纽元素</span></span><br><span class="line">    <span class="type">int</span> i = (low - <span class="number">1</span>);      <span class="comment">// 设置分割点的初始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新排列数组，将小于枢纽元素的元素移到左侧，大于的移到右侧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt;= high - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将枢纽元素放到正确的位置</span></span><br><span class="line">    std::<span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[high]);</span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 获取分割点</span></span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对分割点左右两侧的子数组进行递归排序</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">12</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;原始数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\\n排序后的数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个程序演示了快速排序的基本原理，通过递归调用对数组进行排序。希望对你有帮助！如果有任何问题，欢迎提问。</p><h1>第15章 动态规划</h1><p>动态规划（Dynamic Programming，简称DP）是一种解决复杂问题的优化方法，它通常用于解决具有重叠子问题和最优子结构性质的问题。动态规划的核心思想是将问题分解成子问题，并通过存储子问题的解来避免重复计算，从而提高效率。</p><p>动态规划的一般步骤包括：</p><ol><li><strong>定义子问题：</strong> 将原问题分解成更小的子问题。</li><li><strong>找到状态转移方程：</strong> 定义问题的状态以及状态之间的关系，即如何通过已解决的子问题的解来计算原问题的解。</li><li><strong>解决基本问题：</strong> 找到最小子问题的解，通常是通过初始条件或边界条件来定义的。</li><li><strong>自底向上或自顶向下求解：</strong> 动态规划可以采用自底向上的迭代方法，也可以采用自顶向下的递归方法。</li></ol><p>动态规划常见的应用场景包括：</p><ul><li><strong>最优子结构：</strong> 问题的最优解可以通过子问题的最优解来构造。</li><li><strong>重叠子问题：</strong> 问题可以被分解成一些相同的子问题，这些子问题在求解过程中会被重复计算。</li><li><strong>状态转移方程：</strong> 问题的解可以通过状态之间的转移得到。</li></ul><p>一些经典的动态规划问题包括：</p><ol><li><strong>斐波那契数列：</strong> 寻找第n个斐波那契数。</li><li><strong>最长递增子序列：</strong> 找到给定数组中的最长递增子序列的长度。</li><li><strong>背包问题：</strong> 给定一组物品的重量和价值，确定如何选择这些物品以获得最大的总价值，在限定总重量的情况下。</li><li><strong>编辑距离：</strong> 计算两个字符串之间的最小编辑操作数，如插入、删除、替换，使得一个字符串变成另一个字符串。</li><li><strong>最短路径问题：</strong> 在图中找到从一个顶点到另一个顶点的最短路径。</li></ol><p>下面是一个简单的动态规划示例，计算斐波那契数列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">6</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Fibonacci(&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; <span class="built_in">fibonacci</span>(n) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>dp</code> 数组存储了计算过的子问题的解，通过迭代的方式自底向上计算斐波那契数列。</p><h2 id="经典动态规划问题">经典动态规划问题</h2><ul><li><p>钢条切割问题</p><p>钢条切割问题是动态规划中经典的例子之一。问题的描述是给定一段长度为n的钢条和一个价格表，如何切割钢条使得销售收益最大。</p><p>下面是一个简化的问题描述：</p><ul><li>钢条长度为i的价格为p[i]。</li><li>如果要切割钢条，会有不同的价格。</li></ul><p>问题的目标是找到一种切割方式，使得销售收益最大。这是一个典型的动态规划问题。</p><p>下面是一个简单的C++代码，用于解决钢条切割问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cutRod</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; price, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">// 钢条为i时</span></span><br><span class="line">        <span class="type">int</span> maxVal = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123; <span class="comment">// 切割成j和i-j两段</span></span><br><span class="line">            maxVal = <span class="built_in">max</span>(maxVal, price[j] + dp[i - j]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = maxVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; price = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">30</span>&#125;;  <span class="comment">// 价格表，下标对应钢条长度</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">8</span>;  <span class="comment">// 钢条长度</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxRevenue = <span class="built_in">cutRod</span>(price, n);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Maximum revenue for a rod of length &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; maxRevenue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个例子中，<code>price</code>向量表示每个长度的钢条的价格，<code>cutRod</code>函数通过动态规划计算最大的销售收益。在主函数中，我们可以改变钢条长度和价格表，以测试不同情况下的最大收益。</p><p>请注意，这只是钢条切割问题的一种解法，具体问题和实际应用可能需要适当的调整。</p></li></ul><h1>第17章 摊还分析</h1><h3 id="什么是摊还分析？"><strong>什么是摊还分析？</strong></h3><p>摊还分析其实就是评价某一个操作的代价，方法就是求某<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;spm=1001.2101.3001.7020">数据结构</a>中一系列操作的平均时间。</p><p>摊还分析与概率无关，可以保证某一系列操作在最坏情况下的平均性能。</p><ol><li><p>聚合分析：一个n个操作的序列最坏情况下花费的总时间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。在最坏情况下，每个操作的平均代价，或<strong>摊还代价</strong>为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">T(n)/n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">n</span></span></span></span>。</p></li><li><p>核算法（accounting method）</p></li><li><p>势能法</p></li></ol><h1>第22章 基本的图算法</h1><h2 id="图的表示">图的表示</h2><p>有两种主要的图表示方法：</p><ol><li><strong>邻接矩阵：</strong> 邻接矩阵是一个二维数组，用于表示图中节点之间的关系。如果图是有向的，邻接矩阵是一个方阵。对于无向图，邻接矩阵是对称的。矩阵的行和列代表图中的节点，矩阵中的值表示对应节点之间是否有边以及边的权重。</li><li><strong>邻接列表：</strong> 邻接列表是一种以列表的形式表示图的方法。对于每个节点，都有一个与之相邻的节点列表。这种表示方法更节省空间，特别是在稀疏图（边相对较少）的情况下。</li></ol><p>在实际编程中，选择哪种图表示方法取决于具体问题的要求和图的规模。如果图是稠密的（边相对较多），邻接矩阵可能更适合。而对于稀疏图，邻接列表可能更有效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; vis;</span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt; adj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> adj[u][v]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vis[u]) <span class="keyword">return</span>;</span><br><span class="line">  vis[u] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; ++v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (adj[u][v]) &#123;</span><br><span class="line">      <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  vis.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">  adj.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    adj[u][v] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索、深度优先搜索">广度优先搜索、深度优先搜索</h2><p>广度优先搜索（Breadth-First Search，简称BFS）是一种图搜索算法，用于遍历或搜索图的结构。以下是一个简单的C++实现，假设图的表示是邻接列表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> vertices;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjacencyList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> v) : <span class="built_in">vertices</span>(v), <span class="built_in">adjacencyList</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        adjacencyList[v].<span class="built_in">push_back</span>(w);</span><br><span class="line">        adjacencyList[w].<span class="built_in">push_back</span>(v);  <span class="comment">// undirected graph</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> startVertex)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(vertices, <span class="literal">false</span>)</span></span>;  <span class="comment">// Mark all vertices as not visited</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">        visited[startVertex] = <span class="literal">true</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(startVertex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> currentVertex = q.<span class="built_in">front</span>();</span><br><span class="line">            cout &lt;&lt; currentVertex &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjacencyList[currentVertex]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                    visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> startVertex)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(vertices, <span class="literal">false</span>)</span></span>;  <span class="comment">// Mark all vertices as not visited</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        visited[startVertex] = <span class="literal">true</span>;</span><br><span class="line">        s.<span class="built_in">push</span>(startVertex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> currentVertex = s.<span class="built_in">top</span>();</span><br><span class="line">            cout &lt;&lt; currentVertex &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjacencyList[currentVertex]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                    visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                    s.<span class="built_in">push</span>(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Example usage</span></span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BFS starting from vertex 0: &quot;</span>;</span><br><span class="line">    g.<span class="built_in">BFS</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;DFS starting from vertex 0: &quot;</span>;</span><br><span class="line">    g.<span class="built_in">DFS</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Graph</code> 类表示图，<code>addEdge</code> 方法用于添加边，而<code>BFS</code> 方法实现了广度优先搜索。你可以根据实际情况修改图的表示和算法的实现。这个示例是基于邻接列表的图表示。如果你使用邻接矩阵或其他表示方法，相应的数据结构和算法可能会有所不同。</p><aside>💡 **重点：DFS（接下来的拓扑排序要用到）**</aside><h3 id="算法特点"><strong>算法特点</strong></h3><ul><li>深度优先搜索是一个递归的过程。<ul><li>首先，选定一个出发点后进行遍历，如果有邻接的未被访问过的节点则继续前进。</li><li>若不能继续前进，则回退一步再前进</li><li>若回退一步仍然不能前进，则连续回退至可以前进的位置为止。</li><li>重复此过程，直到所有与选定点相通的所有顶点都被遍历。</li></ul></li><li>深度优先搜索是递归过程，带有回退操作，因此需要使用栈存储访问的路径信息。当访问到的当前顶点没有可以前进的邻接顶点时，需要进行出栈操作，将当前位置回退至出栈元素位置。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表的深度有限递归算法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Boolean; <span class="comment">// 这里我们定义Boolean为布尔类型，其值为TRUE或FALSE</span></span><br><span class="line">Boolean visited[MAX]; <span class="comment">// 访问标志的数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphAdjList GL, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">  EdgeNode *p;</span><br><span class="line">  </span><br><span class="line">  visited[i] = TRUE;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span> GL-&gt;adjList[i].data);</span><br><span class="line">  p = GL-&gt;adjList[i].firstEdge;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(p)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>( !visited[p-&gt;adjvex] )</span><br><span class="line">    &#123;</span><br><span class="line">      DFS(GL, p-&gt;adjvex);</span><br><span class="line">    &#125;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表的深度遍历操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(GraphAdjList GL)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; GL-&gt;numVertexes; i++ )</span><br><span class="line">  &#123;</span><br><span class="line">    visited[i] = FALSE; <span class="comment">// 初始化所有顶点状态都是未访问过状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; GL-&gt;numVertexes; i++ )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>( !visited[i] ) <span class="comment">// 若是连通图，只会执行一次</span></span><br><span class="line">    &#123;</span><br><span class="line">      DFS(GL, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="拓扑排序">拓扑排序</h2><p><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/10/20250710223149.png" alt="Untitled"></p><p>实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="type">int</span> in[MAXN];  <span class="comment">// 存储每个结点的入度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (in[i] == <span class="number">0</span>) S.<span class="built_in">push</span>(i);</span><br><span class="line">  <span class="keyword">while</span> (!S.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = S.<span class="built_in">front</span>();</span><br><span class="line">    S.<span class="built_in">pop</span>();</span><br><span class="line">    L.<span class="built_in">push_back</span>(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (--in[v] == <span class="number">0</span>) &#123;</span><br><span class="line">        S.<span class="built_in">push</span>(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (L.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : L) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DFS实现拓扑排序">DFS实现拓扑排序</h2><p><a href="http://t.csdnimg.cn/8NATr">基本图算法(二) 拓扑排序_拓扑排序算法-CSDN博客</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 边的结构体，表示图中的边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EdgeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> adjVertex;       <span class="comment">// 相邻顶点的索引</span></span><br><span class="line">    <span class="comment">// 其他边的信息，例如权重等，根据实际情况添加</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    EdgeNode* next;      <span class="comment">// 指向下一条边的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点的结构体，表示图中的顶点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexNode</span> &#123;</span><br><span class="line">    <span class="comment">// 顶点的其他信息，例如顶点值等，根据实际情况添加</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    EdgeNode* firstEdge;  <span class="comment">// 指向第一条与该顶点相邻的边的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的结构体，使用邻接表表示</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ALGraph</span> &#123;</span><br><span class="line">    std::vector&lt;VertexNode&gt; vertices;  <span class="comment">// 顶点数组，每个元素表示一个顶点</span></span><br><span class="line">    <span class="comment">// 其他图的信息，例如顶点数、边数等，根据实际情况添加</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>访问时三个状态：</p><blockquote><p>⋅「未搜索」：我们还没有搜索到这个节点，用0表示，标记为白色；</p><p>⋅「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成，用1表示，标记为灰色；</p><p>⋅「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求，用2表示，标记为绿色。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断有向图中是否有环</span></span><br><span class="line"><span class="type">bool</span> valid;</span><br><span class="line"><span class="comment">// 栈</span></span><br><span class="line"><span class="type">int</span>* stack;</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ALGraph G, <span class="type">int</span>* visited, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置当前节点状态为访问中(1)</span></span><br><span class="line">visited[u] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 访问节点u的所有临节点v</span></span><br><span class="line">EdgeNode* e = G.vertices[u].firstEdge;</span><br><span class="line"><span class="keyword">while</span> (e) &#123;</span><br><span class="line"><span class="type">int</span> v = e-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span> (!visited[v]) </span><br><span class="line"><span class="built_in">dfs</span>(G, visited, v);</span><br><span class="line"><span class="comment">// 如果节点v的状态为搜索中(1),则有向图有环</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">valid = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = e-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前节点状态为已访问(2)并入栈</span></span><br><span class="line">visited[u] = <span class="number">2</span>;</span><br><span class="line">stack[top++] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TopologicalSort</span><span class="params">(ALGraph G)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置每个顶点的状态为未搜索(0)</span></span><br><span class="line"><span class="type">int</span>* visited = <span class="built_in">calloc</span>(G.vertexNum, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">stack = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * G.vertexNum);</span><br><span class="line">valid = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexNum; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!valid)   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line"><span class="built_in">dfs</span>(G, visited, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!valid)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;There are loops in Graph\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (top) </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, stack[--top]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>第23章 最小生成树</h1><h2 id="一、最小生成树是什么？">一、最小生成树是什么？</h2><p>最小生成树，全称是Minimum Spanning Tree，简称为MST，其具体定义如下：<br>  在一给定的无向图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G = ( V , E )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">( u , v )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 代表连接顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> 与顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 的边，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w ( u , v )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 代表此边的权重。若存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 的子集且为无循环图，使得联通所有结点的的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w ( T )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span> 最小，则此<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 的最小生成树。即：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi><munder><mo><mo>∑</mo></mo><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>t</mi></mrow></munder></mi><mi>w</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(t)=\underset{(u,v)\in t}{\sum}w(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.966em;vertical-align:-1.216em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.75em;"><span style="top:-2.059em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.216em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></p><p>因此，最小生成树其实是最小权重生成树的简称。</p><h2 id="二、最小生成树的算法"><strong>二、最小生成树的算法</strong></h2><h3 id="1-Kurskal算法">1. Kurskal算法</h3><p><em>俗称“加边法”，算法复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>E</mi><mi>log</mi><mo>⁡</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(E\log V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>,其中E是边的数量，V是顶点数量，适合于边比较少的【稀疏图】。</em></p><p>Kruskal 算法提供一种在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>E</mi><mi>log</mi><mo>⁡</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(E\log V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span> 运行时间确定最小生成树的方案。Kruskal 算法基于贪心算法（Greedy Algorithm）的思想进行设计，其选择的贪心策略就是，每次都选择权重最小的但未形成环路的边加入到生成树中。实现利用【并查集】合并和检查是否形成环。其算法结构如下：</p><aside>👉 1、将所有的边按照权重非递减排序；2、选择最小权重的边，判断是否其在当前的生成树中形成了一个环路。如果环路没有形成，则将该边加入树中，否则放弃。3、重复步骤 2，直到有 V – 1 条边在生成树中。</aside><p>Kruskal算法是一种用于求解最小生成树（Minimum Spanning Tree）的贪心算法。以下是一个简单的C++实现，假设图是以边的形式表示的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边的结构体，包含起点、终点和权重</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较函数，用于排序</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt; other.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集（Union-Find）的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> size) &#123;</span><br><span class="line">        parent.<span class="built_in">resize</span>(size);</span><br><span class="line">        rank.<span class="built_in">resize</span>(size, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找根节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个集合</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">            <span class="comment">// 将rank较小的树连接到rank较大的树上</span></span><br><span class="line">            <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">                parent[rootX] = rootY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">                parent[rootY] = rootX;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果rank相等，则选择一个作为根，并增加其rank</span></span><br><span class="line">                parent[rootX] = rootY;</span><br><span class="line">                rank[rootY]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rank;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kruskal算法实现</span></span><br><span class="line"><span class="function">vector&lt;Edge&gt; <span class="title">kruskal</span><span class="params">(vector&lt;Edge&gt;&amp; edges, <span class="type">int</span> numVertices)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将边按权重升序排序</span></span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="function">UnionFind <span class="title">uf</span><span class="params">(numVertices)</span></span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;Edge&gt; result; <span class="comment">// 存储最小生成树的边</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : edges) &#123;</span><br><span class="line">        <span class="comment">// 如果加入这条边不会形成环，则加入最小生成树</span></span><br><span class="line">        <span class="keyword">if</span> (uf.<span class="built_in">find</span>(edge.start) != uf.<span class="built_in">find</span>(edge.end)) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(edge);</span><br><span class="line">            uf.<span class="built_in">unite</span>(edge.start, edge.end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用类：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> src, dest, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareEdges</span><span class="params">(<span class="type">const</span> Edge&amp; a, <span class="type">const</span> Edge&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.weight &lt; b.weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findParent</span><span class="params">(<span class="type">int</span> u, vector&lt;<span class="type">int</span>&gt;&amp; parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (parent[u] == u) ? u : (parent[u] = <span class="built_in">findParent</span>(parent[u], parent));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, vector&lt;<span class="type">int</span>&gt;&amp; parent, vector&lt;<span class="type">int</span>&gt;&amp; rank)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rootU = <span class="built_in">findParent</span>(u, parent);</span><br><span class="line">    <span class="type">int</span> rootV = <span class="built_in">findParent</span>(v, parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank[rootU] &gt; rank[rootV]) &#123;</span><br><span class="line">        parent[rootV] = rootU;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootU] &lt; rank[rootV]) &#123;</span><br><span class="line">        parent[rootU] = rootV;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[rootV] = rootU;</span><br><span class="line">        rank[rootU]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Edge&gt; <span class="title">kruskal</span><span class="params">(vector&lt;Edge&gt;&amp; edges, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;Edge&gt; result;</span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), compareEdges);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rank</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : edges) &#123;</span><br><span class="line">        <span class="type">int</span> rootSrc = <span class="built_in">findParent</span>(edge.src, parent);</span><br><span class="line">        <span class="type">int</span> rootDest = <span class="built_in">findParent</span>(edge.dest, parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootSrc != rootDest) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(edge);</span><br><span class="line">            <span class="built_in">merge</span>(rootSrc, rootDest, parent, rank);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 示例图的边集合，包括起点、终点和权重</span></span><br><span class="line">    vector&lt;Edge&gt; edges = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>&#125;</span><br><span class="line">        <span class="comment">// 可以根据需要添加更多的边</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图的顶点数</span></span><br><span class="line">    <span class="type">int</span> numVertices = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Kruskal算法求最小生成树</span></span><br><span class="line">    vector&lt;Edge&gt; minSpanningTree = <span class="built_in">kruskal</span>(edges, numVertices);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最小生成树的边</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Edges in the Minimum Spanning Tree:\\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : minSpanningTree) &#123;</span><br><span class="line">        cout &lt;&lt; edge.start &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; edge.end &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; edge.weight &lt;&lt; <span class="string">&quot;\\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个示例实现了一个简单的Kruskal算法，你可以根据需要修改边的集合和顶点数。在这个例子中，<code>Edge</code>结构体表示图的边，<code>UnionFind</code>类表示并查集，<code>kruskal</code>函数执行Kruskal算法，最后在<code>main</code>函数中输出最小生成树的边。</p><h3 id="2-Prim算法">2. Prim算法</h3><p><em>俗称“加点法”，算法复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ,其中V是顶点数量，适合于边比较多，顶点较少的【稠密图】。</em></p><aside>💡 从图$G={V,E}$中的某一顶点$U_0$出发，选择与它关联的具有最小权值的边$(U_0,v)$，将其顶点加入到生成树的顶点集合$U$中。以后每一步从一个顶点在$U$中，而另一个顶点不在$U$中的各条边中选择权值最小的边($u,v)$,把它的顶点加入到集合U中。如此继续下去，直到网中的所有顶点都加入到生成树顶点集合U中为止。</aside><p>Prim算法是一种用于求解最小生成树（Minimum Spanning Tree）的贪心算法，与Kruskal算法类似，但实现方式略有不同。Prim算法从一个初始顶点开始，逐步选择连接到当前生成树的最短边，直到生成树覆盖了图中所有的顶点。以下是Prim算法的详细解释和C++实现示例：</p><h3 id="Prim算法步骤：">Prim算法步骤：</h3><ol><li><strong>选择一个起始顶点作为初始生成树</strong>。</li><li><strong>将选择的顶点标记为已访问</strong>。</li><li><strong>在与当前生成树相邻的所有未访问顶点中，选择权值最小的边</strong>。</li><li><strong>将选择的边加入生成树，将连接的顶点标记为已访问</strong>。</li><li><strong>重复步骤3和步骤4，直到生成树包含了图中的所有顶点</strong>。</li></ol><h3 id="Prim算法C-实现：">Prim算法C++实现：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义边的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> dest, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用于最小堆的比较函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Edge&amp; a, <span class="type">const</span> Edge&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &gt; b.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prim算法实现</span></span><br><span class="line"><span class="function">vector&lt;Edge&gt; <span class="title">prim</span><span class="params">(vector&lt;vector&lt;Edge&gt;&gt;&amp; graph, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    vector&lt;Edge&gt; result;</span><br><span class="line">    priority_queue&lt;Edge, vector&lt;Edge&gt;, Compare&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将起始顶点标记为已访问</span></span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将起始顶点的所有边加入最小堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : graph[start]) &#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(edge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 从最小堆中取出权值最小的边</span></span><br><span class="line">        Edge current = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dest = current.dest;</span><br><span class="line">        <span class="type">int</span> weight = current.weight;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果目标顶点未访问，则将边加入生成树，并将目标顶点标记为已访问</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[dest]) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(&#123;dest, weight&#125;);</span><br><span class="line">            visited[dest] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将目标顶点的所有边加入最小堆</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : graph[dest]) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(edge);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>; <span class="comment">// 节点数</span></span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边信息（无向图）</span></span><br><span class="line">    graph[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    graph[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">6</span>&#125;);</span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">8</span>&#125;);</span><br><span class="line">    graph[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    graph[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    graph[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">6</span>&#125;);</span><br><span class="line">    graph[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">8</span>&#125;);</span><br><span class="line">    graph[<span class="number">4</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> startVertex = <span class="number">0</span>; <span class="comment">// 选择起始顶点</span></span><br><span class="line"></span><br><span class="line">    vector&lt;Edge&gt; result = <span class="built_in">prim</span>(graph, startVertex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最小生成树的边</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Edges in the Minimum Spanning Tree:\\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : result) &#123;</span><br><span class="line">        cout &lt;&lt; startVertex &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; edge.dest &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; edge.weight &lt;&lt; <span class="string">&quot;\\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是一个简单的Prim算法实现示例。请注意，Prim算法的实现可能因图的表示方式而异，上述代码使用邻接表来表示图。在实际应用中，你可能需要根据具体情况进行适当的修改。</p><h1>第24章 单源最短路径</h1><p>我们给定一个带权重的有向图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> 和权重函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>:</mo><mi>E</mi><mo>→</mo><mi mathvariant="bold-italic">R</mi></mrow><annotation encoding="application/x-tex">w:E\to \bm{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.00421em;">R</span></span></span></span></span></span> ，该权重函数将每条边映射到实数值的权重上。图中一条路径<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mo stretchy="false">⟨</mo><msub><mi>v</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>v</mi><mi>k</mi></msub><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">p=\langle v_0,v_1,\cdots,v_k\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">⟩</span></span></span></span> 的权重<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>是构成该路径的所有边的权重之和：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mi>w</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(p)=\sum_{i=1}^kw(v_{i-1},v_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2887em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.989em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h2 id="松弛操作（relaxation）">松弛操作（relaxation）</h2><p>维持一个属性<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi mathvariant="normal">.</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">v.d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord">.</span><span class="mord mathnormal">d</span></span></span></span>，用来记录从源节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>到节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>的最短路径的上界。</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZE-SINGLE-SOURCE(G,s)</span><br><span class="line"><span class="keyword">for</span> each vertex v \belong G.V</span><br><span class="line">v.d = \infty </span><br><span class="line">v.\pi = <span class="keyword">NIL</span></span><br><span class="line">s.d = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">RELAX(u,v,w)</span><br><span class="line"><span class="keyword">if</span> v.d&gt;u.d+w(u.v)</span><br><span class="line">v.d = u.d+w(u,v)</span><br><span class="line">v.\pi = u</span><br></pre></td></tr></table></figure><h2 id="Bellman-Ford算法">Bellman-Ford算法</h2><p>Bellman-Ford算法是一种用于解决单源最短路径问题的算法，它可以处理带有负权边的图。以下是Bellman-Ford算法的详细说明以及一个简单的C++实现。</p><h3 id="Bellman-Ford算法简介：">Bellman-Ford算法简介：</h3><p>Bellman-Ford算法的基本思想是通过不断迭代，更新从源节点到其他节点的最短路径估计值，直到找到最短路径或者确定图中存在负权环。</p><p>算法步骤：</p><ol><li>初始化：将源节点的最短路径估计值设为0，其他节点的最短路径估计值设为正无穷大。</li><li>进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|V| - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>轮迭代，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|V|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span></span></span></span>是图中节点的数量。</li><li>在每一轮迭代中，遍历图中的所有边，更新节点的最短路径估计值。</li><li>如果在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|V| - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>轮迭代后，仍然存在可以松弛的边，说明图中存在负权环。</li></ol><aside>💡 时间复杂度：$O(VE)$</aside><h3 id="C-实现：">C++实现：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> src, dest, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bellmanFord</span><span class="params">(vector&lt;Edge&gt;&amp; edges, <span class="type">int</span> V, <span class="type">int</span> E, <span class="type">int</span> src)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">distance</span><span class="params">(V, INT_MAX)</span></span>;</span><br><span class="line">    distance[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Relaxation step</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= V - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; E; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> u = edges[j].src;</span><br><span class="line">            <span class="type">int</span> v = edges[j].dest;</span><br><span class="line">            <span class="type">int</span> w = edges[j].weight;</span><br><span class="line">            <span class="keyword">if</span> (distance[u] != INT_MAX &amp;&amp; distance[u] + w &lt; distance[v]) &#123;</span><br><span class="line">                distance[v] = distance[u] + w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for negative-weight cycles</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> u = edges[i].src;</span><br><span class="line">        <span class="type">int</span> v = edges[i].dest;</span><br><span class="line">        <span class="type">int</span> w = edges[i].weight;</span><br><span class="line">        <span class="keyword">if</span> (distance[u] != INT_MAX &amp;&amp; distance[u] + w &lt; distance[v]) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Graph contains negative weight cycle!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print the result</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Shortest distances from source &quot;</span> &lt;&lt; src &lt;&lt; <span class="string">&quot; to all other vertices:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; distance[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V, E; <span class="comment">// V is the number of vertices, E is the number of edges</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the number of vertices and edges: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; V &gt;&gt; E;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;Edge&gt; <span class="title">edges</span><span class="params">(E)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the source, destination, and weight for each edge:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; edges[i].src &gt;&gt; edges[i].dest &gt;&gt; edges[i].weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> src;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the source vertex: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; src;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bellmanFord</span>(edges, V, E, src);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述C++代码中，<code>Edge</code>结构体表示图的边，<code>bellmanFord</code>函数实现了Bellman-Ford算法，其中<code>distance</code>数组存储了从源节点到各个节点的最短路径估计值。在算法结束后，它会输出从源节点到所有其他节点的最短路径。如果存在负权环，则会输出相应的提示。</p><h2 id="Dijkstra算法">Dijkstra算法</h2><p>Dijkstra算法是一种用于解决单源最短路径问题的贪心算法。它通过不断选择距离源节点最近的节点来逐步确定最短路径。以下是Dijkstra算法的详细说明以及一个简单的C++实现。</p><aside>💡 该算法要求所有边的权重都为非负值</aside><h3 id="Dijkstra算法简介：">Dijkstra算法简介：</h3><p>Dijkstra算法的基本思想是维护一个集合，其中包含了已经找到最短路径的节点，以及一个数组用于存储从源节点到其他节点的最短路径估计值。在每一步，选择距离源节点最近的未标记节点，并通过这个节点更新其他节点的最短路径估计值。重复这个过程，直到找到从源节点到目标节点的最短路径或者所有节点都被标记。</p><p>算法步骤：</p><ol><li>初始化：将源节点的最短路径估计值设为0，其他节点的最短路径估计值设为正无穷大。</li><li>在每一步中，选择未标记节点中距离源节点最近的节点，标记它，并更新通过这个节点到其他未标记节点的最短路径估计值。</li><li>重复步骤2，直到找到从源节点到目标节点的最短路径或者所有节点都被标记。</li></ol><h3 id="C-实现：-2">C++实现：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> dest, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> V; <span class="comment">// Number of vertices</span></span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; adj; <span class="comment">// Adjacency list</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> V) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">        adj.<span class="built_in">resize</span>(V);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> src, <span class="type">int</span> dest, <span class="type">int</span> weight)</span> </span>&#123;</span><br><span class="line">        Edge edge = &#123;dest, weight&#125;;</span><br><span class="line">        adj[src].<span class="built_in">push_back</span>(edge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> src)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">distance</span><span class="params">(V, INT_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line">        pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, src&#125;);</span><br><span class="line">        distance[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = pq.<span class="built_in">top</span>().second;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : adj[u]) &#123;</span><br><span class="line">                <span class="type">int</span> v = edge.dest;</span><br><span class="line">                <span class="type">int</span> w = edge.weight;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (distance[u] != INT_MAX &amp;&amp; distance[u] + w &lt; distance[v]) &#123;</span><br><span class="line">                    distance[v] = distance[u] + w;</span><br><span class="line">                    pq.<span class="built_in">push</span>(&#123;distance[v], v&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print the result</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Shortest distances from source &quot;</span> &lt;&lt; src &lt;&lt; <span class="string">&quot; to all other vertices:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; distance[i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V, E; <span class="comment">// V is the number of vertices, E is the number of edges</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the number of vertices and edges: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; V &gt;&gt; E;</span><br><span class="line"></span><br><span class="line">    <span class="function">Graph <span class="title">graph</span><span class="params">(V)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the source, destination, and weight for each edge:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> src, dest, weight;</span><br><span class="line">        cin &gt;&gt; src &gt;&gt; dest &gt;&gt; weight;</span><br><span class="line">        graph.<span class="built_in">addEdge</span>(src, dest, weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> src;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the source vertex: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; src;</span><br><span class="line"></span><br><span class="line">    graph.<span class="built_in">dijkstra</span>(src);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述C++代码中，<code>Edge</code>结构体表示图的边，<code>Graph</code>类封装了图的邻接列表和Dijkstra算法的实现。在算法结束后，它会输出从源节点到所有其他节点的最短路径。</p><h3 id="链式前向星">链式前向星</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn (int)1e6 + 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 2e9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line">priority_queue&lt;pr, vector&lt;pr&gt;, greater&lt;pr&gt;&gt; q;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">edgex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> head[maxn];</span><br><span class="line">edgex edge[maxn * <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].weight = w;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dis[maxn];</span><br><span class="line"><span class="type">bool</span> visit[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">        <span class="built_in">add</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> num = it.second;</span><br><span class="line">        <span class="keyword">if</span> (visit[num])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[num] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[num]; i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> to = edge[i].to;</span><br><span class="line">            <span class="type">int</span> weight = edge[i].weight;</span><br><span class="line">            dis[to] = <span class="built_in">min</span>(dis[to], <span class="built_in">max</span>(weight, dis[num]));</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[to], to));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[i] == inf)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>第25章 所有节点对的最短路径问题</h1><h2 id="Floyd-Warshall算法">Floyd-Warshall算法</h2><p>Floyd-Warshall算法是一种经典的图算法，用于求解所有点对之间的最短路径。该算法的时间复杂度为O<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>V</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(V^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中V是图中顶点的数量。它基于动态规划的思想，<strong>适用于有向图或无向图，可以处理带有负权边但无负权环路的图。</strong></p><hr><p><strong>动态规划的思路：</strong></p><pre><code>求图上两点 i、j 之间的最短距离，可以按“从小图到全图”的步骤，在逐步扩大图的过程中计算和更新最短路。想象图中的每个点是一个灯，开始时所有灯都是灭的。然后逐个点亮灯，每点亮一个灯，就重新计算 i、j 的最短路，要求路径只能经过点亮的灯。所有灯都点亮后，计算结束。在这个过程中，点亮第 k 个灯时，能用到 1∼k−1 个亮灯的结果。定义状态为 dp[k][i][j]，i、j、k 是点的编号，范围 1∼n 。状态 dp[k][i][j] 表示在包含 1∼k 点的子图上，点对 i、j 之间的最短路。当从子图 1∼k−1 扩展到子图 1∼k 时，状态转移方程这样设计：</code></pre><aside>💡 dp[k][i][j] = min(dp[k-1][i][j], dp[k-1][i][k] + dp[k-1][k][j])</aside><p><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/10/20250710223227.png" alt="Untitled"></p><pre><code>计算过程如上图所示，虚线圆圈内是包含了 1∼k−1 点的子图。方程中的 dp[k−1][i][j] 是虚线子图内的点对 i、j 的最短路；dp[k−1][i][k]+dp[k−1][k][j] 是经过 k 点的新路径的长度，即这条路径从 i 出发，先到 k，再从 k 到终点 j。比较不经过 k 的最短路径 dp[k−1][i][j] 和经过 k 的新路径，较小者就是新的 dp[k][i][j]。每次扩展一个新点 k 时，都能用到 1∼k−1 的结果，从而提高了效率。这就是**动态规划**的方法。当 k 从 1 逐步扩展到 n 时，最后得到的 dp[n][i][j] 是点对 i、j 之间的最短路径长度。由于 i 和 j 是图中所有的点对，所以能得到所有点对之间的最短路。</code></pre><hr><h3 id="算法步骤：">算法步骤：</h3><ol><li><strong>初始化</strong>：创建一个二维数组 <code>dist[][]</code> 用于存储节点之间的最短距离。初始化这个数组，使得 <code>dist[i][j]</code> 表示节点 <code>i</code> 到节点 <code>j</code> 的最短路径距离。如果两个节点之间有直接的边，则 <code>dist[i][j]</code> 设为这条边的权重值，否则设为一个较大的数或者无穷大。</li><li><strong>进行迭代</strong>：使用三重循环遍历所有节点对 <code>(i, j)</code>，在每次迭代中尝试找到节点 <code>k</code> 作为中间节点，检查是否存在一条路径经过节点 <code>k</code> 使得从 <code>i</code> 到 <code>j</code> 的路径长度变短。更新 <code>dist[i][j]</code> 为 <code>min(dist[i][j], dist[i][k] + dist[k][j])</code>。</li></ol><h3 id="用邻接矩阵表示图：">用邻接矩阵表示图：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 99999</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">floydWarshall</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> V) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dist = graph;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; V; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; V; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] != INF &amp;&amp; dist[k][j] != INF &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V;</span><br><span class="line">    cin &gt;&gt; V;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(V, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(V, INF));</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dist = <span class="built_in">floydWarshall</span>(graph, V);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个示例首先接受用户输入图的节点数和<strong>邻接矩阵</strong>，然后使用 Floyd-Warshall 算法计算最短路径矩阵，并将结果输出。记得将输入的边权重矩阵中不存在的边表示为INF或者一个足够大的数。</p><h3 id="C5-上机A题：（下面的代码还可以输出最短路径）">C5 上机A题：（下面的代码还可以输出最短路径）</h3><p>此题点的个数不多（不超过300），但是需要查询任意两点的最短距离，并且查询次数在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，因此特别适合用<strong>Floyd-Warshall</strong>算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max 303 <span class="comment">// 最大点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> INF = <span class="number">1e12</span> + <span class="number">1</span>; <span class="comment">// 权值最大为10^9，INF要开得比10^9大几个数量级</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AMGraph</span> &#123;<span class="comment">//定义邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vex, arc;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> arcs[Max][Max];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> dis[Max][Max];</span><br><span class="line"><span class="type">int</span>  path[Max][Max];<span class="comment">//dis存最短路程，path保存路径</span></span><br><span class="line"><span class="comment">// path[i][j] = k表示从i到k经过的最后一个节点为k，可以递归path[i][k]求出完整路径</span></span><br><span class="line"><span class="comment">// 若k为-1表示i和j不连通</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(AMGraph &amp;G)</span><span class="comment">//弗洛伊德算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= G.vex; i++)<span class="comment">//初始化dis和path</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= G.vex; j++)</span><br><span class="line">&#123;</span><br><span class="line">dis[i][j] = G.arcs[i][j];</span><br><span class="line"><span class="keyword">if</span> (dis[i][j] != INF&amp;&amp;i != j) path[i][j] = i;</span><br><span class="line"><span class="keyword">else</span> path[i][j] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************Floyd核心算法****************/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=G.vex; k++)<span class="comment">//遍历每个点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=G.vex; i++)<span class="comment">//遍历每条边</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= G.vex; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dis[i][k] + dis[k][j] &lt; dis[i][j]) &#123;</span><br><span class="line">dis[i][j] = dis[i][k] + dis[k][j];<span class="comment">//松弛操作</span></span><br><span class="line">path[i][j] = k;<span class="comment">//保存j前驱结点k</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putin</span><span class="params">(AMGraph &amp;G)</span><span class="comment">//输入图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; G.vex &gt;&gt; G.arc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= G.vex; i++)<span class="comment">//初始化邻接矩阵</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= G.vex; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == j) G.arcs[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> G.arcs[i][j] = INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.arc; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">if</span>(w &lt; G.arcs[u][v])</span><br><span class="line">    G.arcs[u][v] = w;</span><br><span class="line"><span class="comment">//G.arcs[v][u] = w;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">AMGraph G;</span><br><span class="line"><span class="built_in">putin</span>(G);</span><br><span class="line"><span class="built_in">Floyd</span>(G);</span><br><span class="line">    <span class="type">int</span> q, u, v;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span>((u != v) &amp;&amp; (path[u][v] == <span class="number">-1</span>))&#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; dis[u][v] &lt;&lt; endl;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>第26章 最大流</h1><h2 id="EK（Edmond—Karp）算法">EK（Edmond—Karp）算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arraysize 201</span></span><br><span class="line"><span class="type">int</span> maxData = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">int</span> capacity[arraysize][arraysize]; <span class="comment">//记录残留网络的容量</span></span><br><span class="line"><span class="type">int</span> flow[arraysize];                <span class="comment">//标记从源点到当前节点实际还剩多少流量可用</span></span><br><span class="line"><span class="type">int</span> pre[arraysize];                 <span class="comment">//标记在这条路径上当前节点的前驱,同时标记该节点是否在队列中</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; myqueue;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> src,<span class="type">int</span> des)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">while</span>(!myqueue.<span class="built_in">empty</span>())       <span class="comment">//队列清空</span></span><br><span class="line">        myqueue.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m<span class="number">+1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre[src]=<span class="number">0</span>;</span><br><span class="line">    flow[src]= maxData;</span><br><span class="line">    myqueue.<span class="built_in">push</span>(src);</span><br><span class="line">    <span class="keyword">while</span>(!myqueue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = myqueue.<span class="built_in">front</span>();</span><br><span class="line">        myqueue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(index == des)            <span class="comment">//找到了增广路径</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m<span class="number">+1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=src &amp;&amp; capacity[index][i]&gt;<span class="number">0</span> &amp;&amp; pre[i]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                 pre[i] = index; <span class="comment">//记录前驱</span></span><br><span class="line">                 flow[i] = <span class="built_in">min</span>(capacity[index][i],flow[index]);   <span class="comment">//关键：迭代的找到增量</span></span><br><span class="line">                 myqueue.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre[des]==<span class="number">-1</span>)      <span class="comment">//残留图中不再存在增广路径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> flow[des];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxFlow</span><span class="params">(<span class="type">int</span> src,<span class="type">int</span> des)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> increasement= <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sumflow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((increasement=<span class="built_in">BFS</span>(src,des))!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="type">int</span> k = des;          <span class="comment">//利用前驱寻找路径</span></span><br><span class="line">         <span class="keyword">while</span>(k!=src)</span><br><span class="line">         &#123;</span><br><span class="line">              <span class="type">int</span> last = pre[k];</span><br><span class="line">              capacity[last][k] -= increasement; <span class="comment">//改变正向边的容量</span></span><br><span class="line">              capacity[k][last] += increasement; <span class="comment">//改变反向边的容量</span></span><br><span class="line">              k = last;</span><br><span class="line">         &#125;</span><br><span class="line">         sumflow += increasement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sumflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> start,end,ci;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(capacity,<span class="number">0</span>,<span class="built_in">sizeof</span>(capacity));</span><br><span class="line">        <span class="built_in">memset</span>(flow,<span class="number">0</span>,<span class="built_in">sizeof</span>(flow));</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;start&gt;&gt;end&gt;&gt;ci;</span><br><span class="line">            <span class="keyword">if</span>(start == end)               <span class="comment">//考虑起点终点相同的情况</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            capacity[start][end] +=ci;     <span class="comment">//此处注意可能出现多条同一起点终点的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">maxFlow</span>(<span class="number">1</span>,m)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ford-Fulkerson算法">Ford-Fulkerson算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> map[<span class="number">300</span>][<span class="number">300</span>];</span><br><span class="line"><span class="type">int</span> used[<span class="number">300</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t,<span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map[s][i] &gt; <span class="number">0</span> &amp;&amp; !used[i]) &#123;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> d = <span class="built_in">dfs</span>(i,t,<span class="built_in">min</span>(f,map[s][i]));</span><br><span class="line">            <span class="keyword">if</span>(d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                map[s][i] -= d;</span><br><span class="line">                map[i][s] += d;</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxflow</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="built_in">sizeof</span>(used));</span><br><span class="line">        <span class="type">int</span> f = <span class="built_in">dfs</span>(s,t,INF);<span class="comment">//不断找从s到t的增广路</span></span><br><span class="line">        <span class="keyword">if</span>(f == <span class="number">0</span>) <span class="keyword">return</span> flow;<span class="comment">//找不到了就回去</span></span><br><span class="line">        flow += f;<span class="comment">//找到一个流量f的路</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n) != EOF) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(map,<span class="number">0</span>,<span class="built_in">sizeof</span>(map));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; m ; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> from,to,cap;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;from,&amp;to,&amp;cap);</span><br><span class="line">            map[from][to] += cap;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">maxflow</span>(<span class="number">1</span>,n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&lt;/span&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dinic算法">Dinic算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> MAX = <span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> n, m; </span><br><span class="line"><span class="type">int</span> s, t;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c[MAX][MAX], dep[MAX];<span class="comment">//dep[MAX]代表当前层数</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span><span class="comment">//重新建图，按层次建图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dep));</span><br><span class="line">    dep[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c[u][v] &gt; <span class="number">0</span> &amp;&amp; dep[v] == <span class="number">-1</span>)&#123;<span class="comment">//如果可以到达且还没有访问，可以到达的条件是剩余容量大于0，没有访问的条件是当前层数还未知</span></span><br><span class="line">                dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">long</span> <span class="type">long</span> mi, <span class="type">int</span> t)</span><span class="comment">//查找路径上的最小流量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == t)</span><br><span class="line">        <span class="keyword">return</span> mi;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[u][v] &gt; <span class="number">0</span> &amp;&amp; dep[v] == dep[u] + <span class="number">1</span>  &amp;&amp; (tmp = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(mi, c[u][v]), t)))&#123;</span><br><span class="line">            c[u][v] -= tmp;</span><br><span class="line">            c[v][u] += tmp;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>, tmp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>(s, t))&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            tmp = <span class="built_in">dfs</span>(s, inf, t);</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ans += tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c));</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            c[u][v] += w;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">dinic</span>(s, t) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>算法问题选编</h1><h2 id="计算几何">计算几何</h2><h3 id="基础模板">基础模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> inf = <span class="number">1e100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">double</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(d) &lt; eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(d &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dcmp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x - y) &lt; eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">1.49999</span>;</span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">floor</span>(x);<span class="comment">//向下取整函数</span></span><br><span class="line">    <span class="type">int</span> cx = <span class="built_in">ceil</span>(x);<span class="comment">//向上取整函数</span></span><br><span class="line">    <span class="type">int</span> rx = <span class="built_in">round</span>(x);<span class="comment">//四舍五入函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f %d %d %d\n&quot;</span>, x, fx, cx, rx);</span><br><span class="line">    <span class="comment">//输出结果 1.499990 1 2 1</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><aside>💡 不要直接用等号判断浮点数是否相等！</aside><ol><li>误差判别法</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dcmp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x - y) &lt; eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>化浮为整</li></ol><p>在不溢出整数范围的情况下，可以通过乘上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">10^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>转化为整数运算，最后再将结果转化为浮点数输出</p><aside>💡 输出时一定要小心不要输出 −0</aside><h3 id="点与向量">点与向量</h3><p><img src="C:/Users/bush/Downloads/d8ccad17-591b-4ffd-839c-a7eff71de0d0_Export-d81b6b00-2ff1-46bc-ab30-566c925b0020/Untitled.png" alt="Untitled"></p><p><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/10/20250710223846.png" alt="Untitled"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x = <span class="number">0</span>, <span class="type">double</span> y = <span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line">Vector <span class="keyword">operator</span> + (Vector A, Vector B)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(A.x+B.x, A.y+B.y);</span><br><span class="line">&#125;</span><br><span class="line">Vector <span class="keyword">operator</span> - (Point A, Point B)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(A.x-B.x, A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line">Vector <span class="keyword">operator</span> * (Vector A, <span class="type">double</span> p)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(A.x*p, A.y*p);</span><br><span class="line">&#125;</span><br><span class="line">Vector <span class="keyword">operator</span> / (Vector A, <span class="type">double</span> p)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(A.x/p, A.y/p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)</span><br><span class="line">        <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(a.x-b.x) == <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(a.y-b.y) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Dot</span><span class="params">(Vector A, Vector B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.x*B.x + A.y*B.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取模（长度）</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Length</span><span class="params">(Vector A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">Dot</span>(A, A));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Angle</span><span class="params">(Vector A, Vector B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">acos</span>(<span class="built_in">Dot</span>(A, B)/<span class="built_in">Length</span>(A)/<span class="built_in">Length</span>(B));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Cross</span><span class="params">(Vector A, Vector B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.x*B.y-A.y*B.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 平行四边形有向面积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Area2</span><span class="params">(Point A, Point B, Point C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cross</span>(B-A, C-A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 逆时针旋转后的向量</span></span><br><span class="line"><span class="function">Vector <span class="title">Rotate</span><span class="params">(Vector A, <span class="type">double</span> rad)</span></span>&#123;<span class="comment">//rad为弧度 且为逆时针旋转的角</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(A.x*<span class="built_in">cos</span>(rad)-A.y*<span class="built_in">sin</span>(rad), A.x*<span class="built_in">sin</span>(rad)+A.y*<span class="built_in">cos</span>(rad));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算向量逆时针旋转九十度的单位法向量</span></span><br><span class="line"><span class="function">Vector <span class="title">Normal</span><span class="params">(Vector A)</span></span>&#123;<span class="comment">//向量A左转90°的单位法向量</span></span><br><span class="line">    <span class="type">double</span> L = <span class="built_in">Length</span>(A);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(-A.y/L, A.x/L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断折线bc→是不是向ab的逆时针方向（左边）转向</span></span><br><span class="line"><span class="comment">// 凸包构造时将会频繁用到此公式</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ToLeftTest</span><span class="params">(Point a, Point b, Point c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cross</span>(b - a, c - b) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="点与线">点与线</h3><p>![Untitled](C:/Users/bush/Downloads/d8ccad17-591b-4ffd-839c-a7eff71de0d0_Export-d81b6b00-2ff1-46bc-ab30-566c925b0020/Untitled 2.png)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;<span class="comment">//直线定义</span></span><br><span class="line">    Point v, p;</span><br><span class="line">    <span class="built_in">Line</span>(Point v, Point p):<span class="built_in">v</span>(v), <span class="built_in">p</span>(p) &#123;&#125;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="type">double</span> t)</span></span>&#123;<span class="comment">//返回点P = v + (p - v)*t</span></span><br><span class="line">        <span class="keyword">return</span> v + (p - v)*t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//计算两直线交点</span></span><br><span class="line"><span class="comment">//调用前需保证 Cross(v, w) != 0</span></span><br><span class="line"><span class="function">Point <span class="title">GetLineIntersection</span><span class="params">(Point P, Vector v, Point Q, Vector w)</span></span>&#123;</span><br><span class="line">    Vector u = P-Q;</span><br><span class="line">    <span class="type">double</span> t = <span class="built_in">Cross</span>(w, u)/<span class="built_in">Cross</span>(v, w);</span><br><span class="line">    <span class="keyword">return</span> P+v*t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点P到直线AB距离公式</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">DistanceToLine</span><span class="params">(Point P, Point A, Point B)</span></span>&#123;</span><br><span class="line">    Vector v1 = B-A, v2 = P-A;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">Cross</span>(v1, v2)/<span class="built_in">Length</span>(v1));</span><br><span class="line">&#125;<span class="comment">//不去绝对值，得到的是有向距离</span></span><br><span class="line"><span class="comment">//点P到线段AB距离公式</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">DistanceToSegment</span><span class="params">(Point P, Point A, Point B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A == B)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Length</span>(P-A);</span><br><span class="line">    Vector v1 = B-A, v2 = P-A, v3 = P-B;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dcmp</span>(<span class="built_in">Dot</span>(v1, v2)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Length</span>(v2);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dcmp</span>(<span class="built_in">Dot</span>(v1, v3)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Length</span>(v3);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DistanceToLine</span>(P, A, B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点P在直线AB上的投影点</span></span><br><span class="line"><span class="function">Point <span class="title">GetLineProjection</span><span class="params">(Point P, Point A, Point B)</span></span>&#123;</span><br><span class="line">    Vector v = B-A;</span><br><span class="line">    <span class="keyword">return</span> A+v*(<span class="built_in">Dot</span>(v, P-A)/<span class="built_in">Dot</span>(v, v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断p点是否在线段a1a2上</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OnSegment</span><span class="params">(Point p, Point a1, Point a2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dcmp</span>(<span class="built_in">Cross</span>(a1-p, a2-p)) == <span class="number">0</span> &amp;&amp; <span class="built_in">dcmp</span>(<span class="built_in">Dot</span>(a1-p, a2-p)) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断两线段是否相交</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SegmentProperIntersection</span><span class="params">(Point a1, Point a2, Point b1, Point b2)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> c1 = <span class="built_in">Cross</span>(a2-a1, b1-a1), c2 = <span class="built_in">Cross</span>(a2-a1, b2-a1);</span><br><span class="line">    <span class="type">double</span> c3 = <span class="built_in">Cross</span>(b2-b1, a1-b1), c4 = <span class="built_in">Cross</span>(b2-b1, a2-b1);</span><br><span class="line">    <span class="comment">//if判断控制是否允许线段在端点处相交，根据需要添加</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">sgn</span>(c1) || !<span class="built_in">sgn</span>(c2) || !<span class="built_in">sgn</span>(c3) || !<span class="built_in">sgn</span>(c4))&#123;</span><br><span class="line">        <span class="type">bool</span> f1 = <span class="built_in">OnSegment</span>(b1, a1, a2);</span><br><span class="line">        <span class="type">bool</span> f2 = <span class="built_in">OnSegment</span>(b2, a1, a2);</span><br><span class="line">        <span class="type">bool</span> f3 = <span class="built_in">OnSegment</span>(a1, b1, b2);</span><br><span class="line">        <span class="type">bool</span> f4 = <span class="built_in">OnSegment</span>(a2, b1, b2);</span><br><span class="line">        <span class="type">bool</span> f = (f1|f2|f3|f4);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">sgn</span>(c1)*<span class="built_in">sgn</span>(c2) &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(c3)*<span class="built_in">sgn</span>(c4) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多边形">多边形</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多边形有向面积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">PolygonArea</span><span class="params">(Point* p, <span class="type">int</span> n)</span></span>&#123;<span class="comment">//p为端点集合，n为端点个数</span></span><br><span class="line">    <span class="type">double</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; ++i)</span><br><span class="line">        s += <span class="built_in">Cross</span>(p[i]-p[<span class="number">0</span>], p[i<span class="number">+1</span>]-p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断点是否在多边形内，若点在多边形内返回1，在多边形外部返回0，在多边形上返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPointInPolygon</span><span class="params">(Point p, vector&lt;Point&gt; poly)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> wn = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = poly.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">OnSegment</span>(p, poly[i], poly[(i<span class="number">+1</span>)%n])) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">sgn</span>(<span class="built_in">Cross</span>(poly[(i<span class="number">+1</span>)%n] - poly[i], p - poly[i]));</span><br><span class="line">        <span class="type">int</span> d1 = <span class="built_in">sgn</span>(poly[i].y - p.y);</span><br><span class="line">        <span class="type">int</span> d2 = <span class="built_in">sgn</span>(poly[(i<span class="number">+1</span>)%n].y - p.y);</span><br><span class="line">        <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>) wn++;</span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(wn != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="圆">圆</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span>&#123; <span class="comment">// 定义</span></span><br><span class="line">    Point c;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line">    <span class="built_in">Circle</span>(Point c, <span class="type">double</span> r):<span class="built_in">c</span>(c), <span class="built_in">r</span>(r) &#123;&#125;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="type">double</span> a)</span></span>&#123;<span class="comment">//通过圆心角求坐标</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(c.x + <span class="built_in">cos</span>(a)*r, c.y + <span class="built_in">sin</span>(a)*r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//求圆与直线交点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getLineCircleIntersection</span><span class="params">(Line L, Circle C, <span class="type">double</span>&amp; t1, <span class="type">double</span>&amp; t2, vector&lt;Point&gt;&amp; sol)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y;</span><br><span class="line">    <span class="type">double</span> e = a*a + c*c, f = <span class="number">2</span>*(a*b + c*d), g = b*b + d*d - C.r*C.r;</span><br><span class="line">    <span class="type">double</span> delta = f*f - <span class="number">4</span>*e*g;<span class="comment">//判别式</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(delta) &lt; <span class="number">0</span>)<span class="comment">//相离</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(delta) == <span class="number">0</span>)&#123;<span class="comment">//相切</span></span><br><span class="line">        t1 = -f /(<span class="number">2</span>*e);</span><br><span class="line">        t2 = -f /(<span class="number">2</span>*e);</span><br><span class="line">        sol.<span class="built_in">push_back</span>(L.<span class="built_in">point</span>(t1));<span class="comment">//sol存放交点本身</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//相交</span></span><br><span class="line">    t1 = (-f - <span class="built_in">sqrt</span>(delta))/(<span class="number">2</span>*e);</span><br><span class="line">    sol.<span class="built_in">push_back</span>(L.<span class="built_in">point</span>(t1));</span><br><span class="line">    t2 = (-f + <span class="built_in">sqrt</span>(delta))/(<span class="number">2</span>*e);</span><br><span class="line">    sol.<span class="built_in">push_back</span>(L.<span class="built_in">point</span>(t2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两圆相交面积</span></span><br><span class="line"><span class="comment">// 通过计算两个圆相交所构成的两个扇形面积和减去其构成的筝形的面积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">AreaOfOverlap</span><span class="params">(Point c1, <span class="type">double</span> r1, Point c2, <span class="type">double</span> r2)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> d = <span class="built_in">Length</span>(c1 - c2);</span><br><span class="line">    <span class="keyword">if</span>(r1 + r2 &lt; d + eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(d &lt; <span class="built_in">fabs</span>(r1 - r2) + eps)&#123;</span><br><span class="line">        <span class="type">double</span> r = <span class="built_in">min</span>(r1, r2);</span><br><span class="line">        <span class="keyword">return</span> pi*r*r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> x = (d*d + r1*r1 - r2*r2)/(<span class="number">2.0</span>*d);</span><br><span class="line">    <span class="type">double</span> p = (r1 + r2 + d)/<span class="number">2.0</span>;</span><br><span class="line">    <span class="type">double</span> t1 = <span class="built_in">acos</span>(x/r1);</span><br><span class="line">    <span class="type">double</span> t2 = <span class="built_in">acos</span>((d - x)/r2);</span><br><span class="line">    <span class="type">double</span> s1 = r1*r1*t1;</span><br><span class="line">    <span class="type">double</span> s2 = r2*r2*t2;</span><br><span class="line">    <span class="type">double</span> s3 = <span class="number">2</span>*<span class="built_in">sqrt</span>(p*(p - r1)*(p - r2)*(p - d));</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 - s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寻找凸包">寻找凸包</h2><h3 id="Graham扫描法">Graham扫描法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x = <span class="number">0</span>, <span class="type">double</span> y = <span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line">Point lst[maxn];</span><br><span class="line"><span class="type">int</span> stk[maxn], top;</span><br><span class="line">Vector <span class="keyword">operator</span> - (Point A, Point B)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(A.x-B.x, A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Cross</span><span class="params">(Vector v0, Vector v1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v<span class="number">0.</span>x*v<span class="number">1.</span>y - v<span class="number">1.</span>x*v<span class="number">0.</span>y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Dis</span><span class="params">(Point p1, Point p2)</span> </span>&#123; <span class="comment">//计算 p1p2的 距离</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((p<span class="number">2.</span>x-p<span class="number">1.</span>x)*(p<span class="number">2.</span>x-p<span class="number">1.</span>x)+(p<span class="number">2.</span>y-p<span class="number">1.</span>y)*(p<span class="number">2.</span>y-p<span class="number">1.</span>y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point p1, Point p2)</span> </span>&#123; <span class="comment">//极角排序函数 ，角度相同则距离小的在前面</span></span><br><span class="line">    <span class="type">int</span> tmp = <span class="built_in">sgn</span>(<span class="built_in">Cross</span>(p1 - lst[<span class="number">0</span>], p2 - lst[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(tmp == <span class="number">0</span> &amp;&amp; <span class="built_in">Dis</span>(lst[<span class="number">0</span>], p1) &lt; <span class="built_in">Dis</span>(lst[<span class="number">0</span>], p2))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点的编号0 ~ n - 1</span></span><br><span class="line"><span class="comment">//返回凸包结果stk[0 ~ top - 1]为凸包的编号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graham</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    Point p0;</span><br><span class="line">    p<span class="number">0.</span>x = lst[<span class="number">0</span>].x;</span><br><span class="line">    p<span class="number">0.</span>y = lst[<span class="number">0</span>].y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>( (p<span class="number">0.</span>y &gt; lst[i].y) || ((p<span class="number">0.</span>y == lst[i].y) &amp;&amp; (p<span class="number">0.</span>x &gt; lst[i].x)) ) &#123;</span><br><span class="line">            p<span class="number">0.</span>x = lst[i].x;</span><br><span class="line">            p<span class="number">0.</span>y = lst[i].y;</span><br><span class="line">            k = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lst[k] = lst[<span class="number">0</span>];</span><br><span class="line">    lst[<span class="number">0</span>] = p0;</span><br><span class="line">    <span class="built_in">sort</span>(lst + <span class="number">1</span>, lst + n, cmp);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        top = <span class="number">1</span>;</span><br><span class="line">        stk[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) &#123;</span><br><span class="line">        top = <span class="number">2</span>;</span><br><span class="line">        stk[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        stk[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    stk[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    stk[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    top = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(top &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">Cross</span>(lst[stk[top - <span class="number">1</span>]] - lst[stk[top - <span class="number">2</span>]], lst[i] - lst[stk[top - <span class="number">2</span>]]) &lt;= <span class="number">0</span>)</span><br><span class="line">            --top;</span><br><span class="line">        stk[top] = i;</span><br><span class="line">        ++top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Andrew算法">Andrew算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x = <span class="number">0</span>, <span class="type">double</span> y = <span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line">Vector <span class="keyword">operator</span> - (Point A, Point B)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(A.x-B.x, A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)</span><br><span class="line">        <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Cross</span><span class="params">(Vector v0, Vector v1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v<span class="number">0.</span>x*v<span class="number">1.</span>y - v<span class="number">1.</span>x*v<span class="number">0.</span>y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算凸包，输入点数组为 p，个数为 n， 输出点数组为 ch。函数返回凸包顶点数</span></span><br><span class="line"><span class="comment">//如果不希望凸包的边上有输入点，则把两个 &lt;= 改为 &lt;</span></span><br><span class="line"><span class="comment">//在精度要求高时建议用dcmp比较</span></span><br><span class="line"><span class="comment">//输入不能有重复点，函数执行完后输入点的顺序被破坏</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ConvexHull</span><span class="params">(Point* p, <span class="type">int</span> n, Point* ch)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(p, p+n);</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(m &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">Cross</span>(ch[m<span class="number">-1</span>] - ch[m<span class="number">-2</span>], p[i] - ch[m<span class="number">-2</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        ch[m++] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-2</span>; i&gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(m &gt; k &amp;&amp; <span class="built_in">Cross</span>(ch[m<span class="number">-1</span>] - ch[m<span class="number">-2</span>], p[i] - ch[m<span class="number">-2</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        ch[m++] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)</span><br><span class="line">        --m;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多项式与快速傅里叶变换">多项式与快速傅里叶变换</h2><p>多项式与快速傅里叶变换（FFT）之间存在密切的关系，特别是在离散傅里叶变换（DFT）的计算中。FFT 是一种高效计算 DFT 的算法，而 DFT 又与多项式的乘法有关。</p><h3 id="多项式">多项式</h3><p>在代数中，一个多项式是由变量的幂和系数的有限和组成的表达式。例如，一个一元多项式：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>a</mi><mi>n</mi></msub><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">P(x) = a_0 + a_1x + a_2x^2 + \ldots + a_nx^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9641em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8144em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_0, a_1, \ldots, a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是多项式的系数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 是变量。</p><h3 id="离散傅里叶变换（DFT）">离散傅里叶变换（DFT）</h3><p>离散傅里叶变换将一个离散序列（通常是时域上的信号）转换为其在频域上的表示。对于一个 (N)-点序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_0, x_1, \ldots, x_{N-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>，其 DFT 定义如下：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>k</mi></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>x</mi><mi>n</mi></msub><mo>⋅</mo><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mrow><mn>2</mn><mi>π</mi><mi>i</mi></mrow><mi>N</mi></mfrac><mi>k</mi><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X_k = \sum_{n=0}^{N-1} x_n \cdot e^{-\frac{2\pi i}{N}kn}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2809em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9812em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9616em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9616em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8551em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">πi</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mord mathnormal mtight">kn</span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">X_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是频域上的第  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>  个复数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> 是自然对数的底，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 是虚数单位。</p><h3 id="快速傅里叶变换（FFT）">快速傅里叶变换（FFT）</h3><p>FFT 是一种高效计算 DFT 的算法，通过减少运算次数，从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的复杂度降低到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。FFT 的算法实现多种，其中最常见的是 Cooley-Tukey 算法。</p><h3 id="FFT与多项式乘法">FFT与多项式乘法</h3><p>由于 DFT 与多项式的系数之间存在对应关系，FFT 被广泛用于多项式乘法。对于两个多项式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>，它们的乘积的系数可以通过计算它们的 DFT，相乘，再通过逆 DFT 得到。这样，可以将多项式的乘法复杂度从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，降低到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p>在这个例子中，<code>multiply</code> 函数用于计算两个多项式的卷积。你可以根据自己的需要调整输入多项式的系数。这段代码使用了复数类型 <code>complex&lt;double&gt;</code> 来表示复数，其中 <code>real()</code> 函数获取实部。最后，结果被四舍五入到最接近的整数。</p><p>对于更高效的迭代FFT，你可以使用位逆序置换（Bit-Reversal Permutation）来优化数据的存储和访问。以下是一个使用位逆序置换的迭代FFT的C++实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> complex&lt;<span class="type">double</span>&gt; Complex;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位逆序置换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bitReverse</span><span class="params">(vector&lt;Complex&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> bits = <span class="built_in">log2</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> bit = <span class="number">0</span>; bit &lt; bits; bit++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; bit)) &#123;</span><br><span class="line">                j |= <span class="number">1</span> &lt;&lt; (bits - <span class="number">1</span> - bit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代FFT</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">iterativeFFT</span><span class="params">(vector&lt;Complex&gt;&amp; a, <span class="type">bool</span> invert)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">bitReverse</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">double</span> angle = <span class="number">2</span> * PI / len * (invert ? <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="function">Complex <span class="title">wlen</span><span class="params">(cos(angle), sin(angle))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += len) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                Complex u = a[i + j];</span><br><span class="line">                Complex v = w * a[i + j + len / <span class="number">2</span>];</span><br><span class="line">                a[i + j] = u + v;</span><br><span class="line">                a[i + j + len / <span class="number">2</span>] = u - v;</span><br><span class="line">                w *= wlen;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (invert) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            a[i] /= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多项式卷积</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;Complex&gt; <span class="title">fa</span><span class="params">(a.begin(), a.end())</span>, <span class="title">fb</span><span class="params">(b.begin(), b.end())</span></span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; <span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>())) n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    fa.<span class="built_in">resize</span>(n);</span><br><span class="line">    fb.<span class="built_in">resize</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">iterativeFFT</span>(fa, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">iterativeFFT</span>(fb, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        fa[i] *= fb[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">iterativeFFT</span>(fa, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result[i] = <span class="built_in">round</span>(fa[i].<span class="built_in">real</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 第一个多项式系数</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;; <span class="comment">// 第二个多项式系数</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">multiply</span>(a, b);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result of convolution: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : result) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个实现中，<code>bitReverse</code> 函数用于执行位逆序置换，然后在迭代FFT的过程中使用这个置换后的数据。这有助于提高数据存储和访问的效率。</p><h2 id="字符串匹配">字符串匹配</h2><h3 id="1-朴素字符串匹配算法（Naive-String-Matching）：">1.<strong>朴素字符串匹配算法（Naive String Matching）：</strong></h3><p>也称为暴力匹配算法，它从文本的第一个字符开始与模式的第一个字符匹配，然后逐个字符比较，直到找到匹配或遍历完整个文本。</p><h3 id="2-Rabin-Karp算法：-基于哈希的字符串匹配算法。">2. **Rabin-Karp算法：**基于哈希的字符串匹配算法。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> prime = <span class="number">101</span>;  <span class="comment">// 选择一个较大的质数作为哈希函数的模</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算字符串的哈希值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculateHash</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        hash += (<span class="type">int</span>)str[i] * <span class="built_in">pow</span>(prime, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新哈希值，用于滑动窗口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recalculateHash</span><span class="params">(<span class="type">int</span> oldHash, <span class="type">char</span> oldChar, <span class="type">char</span> newChar, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (oldHash - oldChar + newChar * <span class="built_in">pow</span>(prime, length - <span class="number">1</span>)) * prime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rabin-Karp算法实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rabinKarpSearch</span><span class="params">(<span class="type">const</span> string&amp; pattern, <span class="type">const</span> string&amp; text)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> patternLength = pattern.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> textLength = text.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> patternHash = <span class="built_in">calculateHash</span>(pattern, patternLength);</span><br><span class="line">    <span class="type">int</span> textHash = <span class="built_in">calculateHash</span>(text, patternLength);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= textLength - patternLength; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (patternHash == textHash) &#123;</span><br><span class="line">            <span class="comment">// 如果哈希值相等，可能找到了匹配，进一步检查字符是否真的匹配</span></span><br><span class="line">            <span class="type">bool</span> match = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; patternLength; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pattern[j] != text[i + j]) &#123;</span><br><span class="line">                    match = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Pattern found at index &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新哈希值，准备检查下一个子串</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; textLength - patternLength) &#123;</span><br><span class="line">            textHash = <span class="built_in">recalculateHash</span>(textHash, text[i], text[i + patternLength], patternLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string text = <span class="string">&quot;ABABCABABABCABCABABC&quot;</span>;</span><br><span class="line">    string pattern = <span class="string">&quot;ABABC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Text: &quot;</span> &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pattern: &quot;</span> &lt;&lt; pattern &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rabinKarpSearch</span>(pattern, text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-有限自动机法：">3. <strong>有限自动机法：</strong></h3><p>有限状态自动机（Finite State Machine，FSM）是一种用于字符串匹配的有效算法。在这种算法中，模式字符串被预处理成一个有限状态自动机，然后利用该自动机在文本中进行匹配。以下是有限状态自动机字符串匹配算法（Aho-Corasick算法）的简要说明和C++实现：</p><h4 id="Aho-Corasick算法">Aho-Corasick算法</h4><p>Aho-Corasick算法是一种多模式字符串匹配算法，它可以同时搜索多个模式串。</p><h5 id="基本思想：">基本思想：</h5><ol><li>构建Trie树：将所有模式串构建成一个Trie树，每个节点表示一个字符，从根节点到叶子节点的路径表示一个模式串。</li><li>添加失败路径（Failure Function）：为Trie树中的每个节点添加失败路径，使得在匹配失败时能够跳转到Trie树中的其他位置。</li><li>匹配过程：在文本串中按顺序遍历字符，并根据Trie树进行匹配，利用失败路径实现快速跳转。</li></ol><h5 id="C-实现：-3">C++实现：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, TrieNode*&gt; children;</span><br><span class="line">    TrieNode* fail;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">fail</span>(<span class="literal">nullptr</span>), <span class="built_in">isEnd</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AhoCorasick</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AhoCorasick</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加模式串到Trie树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addPattern</span><span class="params">(<span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : pattern) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children.<span class="built_in">find</span>(c) == node-&gt;children.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                node-&gt;children[c] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建失败路径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildFailureFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;TrieNode*&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : root-&gt;children) &#123;</span><br><span class="line">            kv.second-&gt;fail = root;</span><br><span class="line">            q.<span class="built_in">push</span>(kv.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TrieNode* curr = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : curr-&gt;children) &#123;</span><br><span class="line">                <span class="type">char</span> symbol = kv.first;</span><br><span class="line">                TrieNode* child = kv.second;</span><br><span class="line">                q.<span class="built_in">push</span>(child);</span><br><span class="line"></span><br><span class="line">                TrieNode* failure = curr-&gt;fail;</span><br><span class="line">                <span class="keyword">while</span> (failure != <span class="literal">nullptr</span> &amp;&amp; failure-&gt;children.<span class="built_in">find</span>(symbol) == failure-&gt;children.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    failure = failure-&gt;fail;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (failure != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    child-&gt;fail = failure-&gt;children[symbol];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    child-&gt;fail = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在文本中匹配模式串</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">match</span><span class="params">(<span class="type">const</span> string&amp; text)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; text.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">char</span> c = text[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;children.<span class="built_in">find</span>(c) == node-&gt;children.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                node = node-&gt;fail;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node = root;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node-&gt;children[c];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 打印匹配的模式串</span></span><br><span class="line">                <span class="built_in">printMatches</span>(node, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印匹配的模式串</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printMatches</span><span class="params">(TrieNode* node, <span class="type">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;isEnd) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Pattern found at index &quot;</span> &lt;&lt; endIndex &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AhoCorasick ac;</span><br><span class="line">    ac.<span class="built_in">addPattern</span>(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">    ac.<span class="built_in">addPattern</span>(<span class="string">&quot;she&quot;</span>);</span><br><span class="line">    ac.<span class="built_in">addPattern</span>(<span class="string">&quot;his&quot;</span>);</span><br><span class="line">    ac.<span class="built_in">addPattern</span>(<span class="string">&quot;hers&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ac.<span class="built_in">buildFailureFunction</span>();</span><br><span class="line"></span><br><span class="line">    string text = <span class="string">&quot;ahishers&quot;</span>;</span><br><span class="line">    ac.<span class="built_in">match</span>(text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是一个简单的Aho-Corasick算法的实现，可以根据实际需要进行优化和扩展。</p><h3 id="4-KMP算法">4. <strong>KMP算法</strong></h3><p>KMP（Knuth-Morris-Pratt）算法是一种高效的字符串匹配算法，它通过利用已经匹配过的信息来避免不必要的字符比较。以下是KMP算法的简要说明和C++实现：</p><h4 id="KMP算法">KMP算法</h4><h5 id="基本思想：-2">基本思想：</h5><ol><li>构建部分匹配表（Partial Match Table，PMT）：PMT记录了每个前缀的最长相等的真前缀和真后缀的长度。</li><li>利用PMT进行匹配：在匹配过程中，当发生不匹配时，根据PMT找到一个合适的位置跳过一部分字符。</li></ol><h5 id="C-实现：-4">C++实现：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建部分匹配表（Partial Match Table）</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buildPMT</span><span class="params">(<span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> patternLength = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pmt</span><span class="params">(patternLength, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; patternLength) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern[i] == pattern[length]) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            pmt[i] = length;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (length != <span class="number">0</span>) &#123;</span><br><span class="line">                length = pmt[length - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pmt[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pmt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP算法实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmpSearch</span><span class="params">(<span class="type">const</span> string&amp; pattern, <span class="type">const</span> string&amp; text)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> patternLength = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> textLength = text.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建部分匹配表</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pmt = <span class="built_in">buildPMT</span>(pattern);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">// 索引用于遍历text</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">// 索引用于遍历pattern</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; textLength) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern[j] == text[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == patternLength) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Pattern found at index &quot;</span> &lt;&lt; i - j &lt;&lt; endl;</span><br><span class="line">            j = pmt[j - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; textLength &amp;&amp; pattern[j] != text[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                j = pmt[j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string text = <span class="string">&quot;ABABDABACDABABCABAB&quot;</span>;</span><br><span class="line">    string pattern = <span class="string">&quot;ABABC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Text: &quot;</span> &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pattern: &quot;</span> &lt;&lt; pattern &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">kmpSearch</span>(pattern, text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是一个简单的KMP算法的实现示例，用于在文本中查找模式串的出现。这个算法通过构建部分匹配表来提高匹配效率。在实际应用中，可以根据需要进行适当的优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 教材实现：</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">computePrefix</span><span class="params">(<span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; pattern[k] != pattern[i]) &#123;</span><br><span class="line">            k = pi[k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pattern[k] == pattern[i])&#123;</span><br><span class="line">            k = k + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pi[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> KMP-<span class="built_in">MATCHER</span>()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库复习笔记</title>
      <link href="/2025/07/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/07/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>数据库相关概念</h1><ul><li>数据 &amp; 信息：数据+解释=信息</li><li>数据管理：数据存储/维护/查询/安全等</li><li>数据库：是存储介质上的一个/组文件，不能直接编辑，需通过数据库管理系统来操作</li><li><strong>数据库管理系统DBMS</strong>：管理数据库的一种大型复杂软件系统</li><li><strong>数据库系统DMS</strong>：由应用程序、数据库、数据库管理系统和用户组成</li></ul><h1>ER模型</h1><p><strong>ER 图</strong> 全称是 Entity Relationship Diagram（实体联系图），提供了表示实体类型、属性和联系的方法。</p><p>ER 图由下面 3 个要素组成：</p><ul><li><strong>实体</strong>：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。在 ER 图中，实体使用<strong>矩形框</strong>表示。</li><li><strong>属性</strong>：即某个实体拥有的属性，属性用来描述组成实体的要素。在 ER 图中，属性使用<strong>椭圆形</strong>表示。</li><li><strong>联系</strong>：即实体与实体之间的关系，在 ER 图中用<strong>菱形</strong>表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。</li></ul><h1>关系模型</h1><ul><li><strong>元组</strong>：元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li><li><strong>码/键</strong>：码就是能唯一标识实体的属性，对应表中的列。</li><li><strong>候选码/候选键</strong>：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li><li><strong>主码/主键</strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li><li><strong>外码/外键</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li><li><strong>主属性</strong>：候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li><li><strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li></ul><h1>范式</h1><h2 id="1NF">1NF</h2><p>第一范式（First Normal Form）是最基本的规范形式，即<strong>关系中每个属性都是不可再分的简单项</strong>。</p><h2 id="2NF">2NF</h2><p>如果关系模式R ∈ 1NF，且<strong>每个非主属性都完全函数依赖于R的每个关系键</strong>，则称R属于第二范式（Second Normal Form），简称2NF，记作R ∈ 2NF。</p><h2 id="3NF">3NF</h2><p>如果关系模式R ∈ 2NF，且每个非主属性都不传递依赖于R的每个关系键，则称R属于第三范式（Third Normal  Form），简称3NF，记作R ∈ 3NF。</p><h2 id="其他范式">其他范式</h2><ul><li>BCNF：如果关系模式R ∈ 1NF，且所有的函数依赖X→Y（Y ∉ X），决定因素X都包含了R的一个候选键，则称R属于BC范式（Boyce-Codd Normal Form），记作R ∈ BCNF。</li></ul><h1>SQL语言</h1><h2 id="DQL">DQL</h2><h3 id="单表查询">单表查询</h3><p>查询语句基本结构：</p><ul><li><p>SELECT子句：指定要显示的属性列（DISTNCT）</p></li><li><p>FROM子句：指定查询对象(基本表或视图)</p></li><li><p>WHERE子句：指定查询条件</p></li><li><p>GROUP BY子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用集函数。</p></li><li><p>HAVING短语：筛选出只有满足指定条件的组</p></li><li><p>ORDER BY子句：对查询结果表按指定列值的升序或降序排序</p></li></ul><hr><h3 id="多表查询">多表查询</h3><p>连接查询（在From子句中涉及多个表的查询）：</p><ul><li><p>广义笛卡尔积：不带连接谓词的连</p></li><li><p>等值连接(含自然连接)：</p><ul><li>自然连接：等值连接的一种特殊情况，把目标列中重复的属性列去掉</li></ul></li><li><p>非等值连接查询：连接运算符不是=号的连接</p></li><li><p>自身连接查询：一个表与其自己进行连接，需要给表的两个副本起别名以示区别</p></li><li><p>外连接查询：普通连接（内连接，INNER JOIN）只返回两个表中<strong>匹配的记录</strong>；外连接（OUTTER JOIN）不仅返回<strong>匹配的记录</strong>，还返回<strong>未匹配的一侧或两侧的记录</strong>，未匹配部分用 <code>NULL</code> 补齐。</p><ul><li>LEFT OUTER JOIN 或 LEFT JOIN</li><li>RIGHT OUTER JOIN 或 RIGHT JOIN</li><li>FULL OUTER JOIN 或 FULL JOIN</li></ul><blockquote><p>MySQL 不支持 FULL JOIN，可以用 <code>UNION</code> 实现：Left join Union Right join</p></blockquote></li><li><p>复合条件连接查询</p></li></ul><hr><h3 id="子查询">子查询</h3><ul><li>相关子查询：子查询的查询条件依赖于父查询</li><li>不相关子查询：由里向外逐层处理</li></ul><p>WHERE子句中引出子查询的谓词：IN/=、比较运算符、ALL/ANY、EXISTS/NOT EXISTS；</p><p>FROM子句中的子查询相当于返回一张临时表。</p><hr><h3 id="集合查询">集合查询</h3><p><code>UNION</code> ：用于<strong>合并两个或多个 <code>SELECT</code> 查询的结果</strong>，形成一个统一的结果集。</p><blockquote><p>MySQL只支持UNION（并），不支持INTERSECT/EXCEPT（交/差）。</p></blockquote><h2 id="DDL">DDL</h2><ul><li><p>创建表</p><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/10/20250710191512.png" alt="image-20250710191509273" style="zoom: 50%;" /></li><li><p>删除表：<code>DROP TABEL &lt;表名&gt;</code></p></li><li><p>修改表：</p><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/10/20250710191658.png" alt="image-20250710191656484" style="zoom: 50%;" /></li></ul><h2 id="DML">DML</h2><ul><li><p>插入数据</p><ul><li><p>插入单条元组</p><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/10/20250710192434.png" alt="image-20250710192432361" style="zoom: 50%;" /></li><li><p>插入子查询结果</p><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/10/20250710192532.png" alt="image-20250710192530527" style="zoom:50%;" /></li></ul></li><li><p>修改数据</p><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/10/20250710192639.png" alt="image-20250710192637371" style="zoom:50%;" /><ul><li>修改某一个元组的值</li><li>修改多个元组的值</li><li>带子查询的修改语句</li></ul></li><li><p>删除数据</p><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/10/20250710192759.png" alt="image-20250710192757239" style="zoom:50%;" /><ul><li>删除某一个元组的值</li><li>删除多个元组的值</li><li>带子查询的删除语句</li></ul></li></ul><h2 id="TCL（事务控制语言）">TCL（事务控制语言）</h2><p><strong>MySQL 默认是隐式提交</strong>，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<code>autocommit</code> 标记是针对每个连接而不是针对服务器的。</p><p>指令：</p><ul><li><code>START TRANSACTION</code> - 指令用于标记事务的起始点。</li><li><code>SAVEPOINT</code> - 指令用于创建保留点。</li><li><code>ROLLBACK TO</code> - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 <code>START TRANSACTION</code> 语句处。</li><li><code>COMMIT</code> - 提交事务。</li></ul><h2 id="DCL">DCL</h2><p><strong>DCL 的主要功能是控制用户的访问权限。</strong></p><ul><li><p>权限授予<code>GRANT</code>：</p><ul><li>如<code>Grant select on TableA on UserA</code>（表级）<code>Grant select (a, b) on TableA on UserA</code>（列级）</li></ul></li><li><p>权限收回<code>Revoke</code>：</p><ul><li>如<code>Revoke select on TableA from UserA</code></li></ul></li><li><p>创建新用户：</p><ul><li><code>Create user username IDENTIFIED BY ‘password’</code></li></ul></li><li><p>角色：命名的权限集合，使用角色可以方便的进行授权管理</p><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/10/20250710213003.png" alt="image-20250710213001894" style="zoom: 33%;" /></li></ul><h2 id="视图">视图</h2><p>视图是一种虚表（virtual table），是从一个或几个基本表（或视图）导出的表。</p><blockquote><p>视图其实是在数据字典中存储的一条Select 语句</p></blockquote><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/10/20250710192931.png" alt="image-20250710192929826" style="zoom:50%;" /><p>视图的作用：</p><ul><li>视图能够简化用户的操作</li><li>视图使用户能以多种角度看待同一数据</li><li>视图对重构数据库提供了一定程度的逻辑独立性</li><li>视图能够对机密数据提供安全保护</li></ul><h1>索引与查询优化</h1><h2 id="索引">索引</h2><p>什么是索引：</p><ul><li>是主表上的一种辅助数据结构</li><li>对数据库表中一个或多个列的值进行排序</li><li>用于提高主表的查询速度</li><li>如果想按特定列的值来查找数据，则与在表中搜索所有的行相比，索引有助于更快地获取信息</li></ul><p><strong>优点</strong>：</p><ul><li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong>：</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><h2 id="B-树索引">B+树索引</h2><p>B+树索引是数据库系统中使用最广泛的多级索引。具有如下特点：</p><ul><li>将索引键组织成一棵平衡树， 即从树根到树叶的所有路径一样长</li><li>数据（指向基本表记录存储位置的指针）存储在叶结点</li><li>最底层的叶节点包含每个索引键和指向被索引行的指针（行id）</li><li>叶节点之间有通道可供平行查询</li><li>每一个叶节点都和磁盘页面大小一致</li><li>查询的时间复杂度：$O(log_mn) $(m为分叉数，即B+树的阶）</li></ul><h2 id="查询优化">查询优化</h2><p>SQL语句执行过程：</p><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/10/20250710205450.png" alt="image-20250710205448837" style="zoom:50%;" /><p>查询优化的一般准则：</p><ul><li>选择运算应尽可能先做<ul><li>目的：减小中间关系</li></ul></li><li>在执行连接操作前对关系适当进行预处理<ul><li>按连接属性排序</li><li>在连接属性上建立索引</li></ul></li><li>投影运算和选择运算同时做<ul><li>目的：避免重复扫描关系</li></ul></li><li>将投影运算与其前面或后面的双目运算结合<ul><li>目的：减少扫描关系的遍数</li></ul></li><li>提取公共子表达式</li><li>…</li></ul><hr><p>查询优化的一般过程：</p><ol><li><p>将查询转换成某种内部表示，通常是语法树</p></li><li><p>根据一定的等价变换规则把语法树转换成标准（优化）形式 （代数优化）</p></li><li><p>选择低层的操作算法（物理优化）</p><ul><li>对于语法树中的每一个操作计算各种执行算法的执行代价</li><li>选择代价小的执行算法</li></ul></li><li><p>生成查询计划(查询执行方案)</p></li></ol><h1>存储过程</h1><p>存储过程可以看成是对一系列 SQL 操作的批处理。存储过程可以由触发器，其他存储过程以及 Java， Python，PHP 等应用程序调用。</p><p>使用存储过程的好处：</p><ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul><h1>触发器</h1><p>触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。</p><p>我们可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。</p><p>使用触发器的优点：</p><ul><li>SQL 触发器提供了另一种检查数据完整性的方法。</li><li>SQL 触发器可以捕获数据库层中业务逻辑中的错误。</li><li>SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，您不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。</li><li>SQL 触发器对于审计表中数据的更改非常有用。</li></ul><p>使用触发器的缺点：</p><ul><li>SQL 触发器只能提供扩展验证，并且不能替换所有验证。必须在应用程序层中完成一些简单的验证。例如，您可以使用 JavaScript 在客户端验证用户的输入，或者使用服务器端脚本语言（如 JSP，PHP，<a href="http://ASP.NET">ASP.NET</a>，Perl）在服务器端验证用户的输入。</li><li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。</li><li>SQL 触发器可能会增加数据库服务器的开销。</li></ul><blockquote><p>MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。</p></blockquote><p>创建触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">trigger_time</span><br><span class="line">trigger_event</span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  trigger_statements</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> `trigger_insert_user`</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT INTO</span> `user_history`(user_id, operate_type, operate_time)</span><br><span class="line">    <span class="keyword">VALUES</span> (NEW.id, <span class="string">&#x27;add a user&#x27;</span>,  now());</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h1>NoSQL</h1><p>NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p><h2 id="NoSQL的类型">NoSQL的类型</h2><p>NoSQL 数据库主要可以分为下面四种类型：</p><ul><li><strong>键值</strong>：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li><li><strong>文档</strong>：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li><li><strong>图形</strong>：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。</li><li><strong>宽列</strong>：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</li></ul><h2 id="SQL与NoSQL的区别">SQL与NoSQL的区别</h2><table><thead><tr><th></th><th>SQL 数据库</th><th>NoSQL 数据库</th></tr></thead><tbody><tr><td>数据存储模型</td><td>结构化存储，具有固定行和列的表格</td><td>非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边</td></tr><tr><td>发展历程</td><td>开发于 1970 年代，重点是减少数据重复</td><td>开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本</td></tr><tr><td>例子</td><td>Oracle、MySQL、Microsoft SQL Server、PostgreSQL</td><td>文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、HBase，图表：Neo4j、Amazon Neptune、Giraph</td></tr><tr><td>ACID 属性</td><td>提供原子性、一致性、隔离性和持久性 (ACID) 属性</td><td>通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB。不过，MongoDB 对 ACID 事务的支持和 MySQL 还是有所区别的。</td></tr><tr><td>性能</td><td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构</td><td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定</td></tr><tr><td>扩展</td><td>垂直（使用性能更强大的服务器进行扩展）、读写分离、分库分表</td><td>横向（增加服务器的方式横向扩展，通常是基于分片机制）</td></tr><tr><td>用途</td><td>普通企业级的项目的数据存储</td><td>用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化</td></tr><tr><td>查询语法</td><td>结构化查询语言 (SQL)</td><td>数据访问语法可能因数据库而异</td></tr></tbody></table><hr><blockquote><p>参考：<a href="https://javaguide.cn/">https://javaguide.cn/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java SE复习笔记</title>
      <link href="/2025/07/04/Java%20SE%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/07/04/Java%20SE%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第一次找实习wwwwwwww好紧张希望能顺利。</p></blockquote><h1>Java SE复习笔记</h1><h2 id="JVM">JVM</h2><p>Java虚拟机（Java Virtual Machine，简称JVM）是运行所有Java程序的抽象计算机，是Java语言的运行环境。</p><p>Java语言的一个非常重要的特点就是<strong>与平台的无关性</strong>（一次编译、处处运行）。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。</p><p>JVM中提供的JIT（即时编译方式）将字节码直接转化成高性能的本地机器码，即JIT使得Java程序既能跨平台又能高速运行。</p><h2 id="Java集合">Java集合</h2><p><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/04/20250704183013.gif" alt="img"></p><h3 id="ArrayList">ArrayList</h3><p>Java ArrayList 常用方法列表如下：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-add.html">add()</a></td><td style="text-align:left">将元素插入到指定位置的 arraylist 中</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-addall.html">addAll()</a></td><td style="text-align:left">添加集合中的所有元素到 arraylist 中</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-clear.html">clear()</a></td><td style="text-align:left">删除 arraylist 中的所有元素</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-clone.html">clone()</a></td><td style="text-align:left">复制一份 arraylist</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-contains.html">contains()</a></td><td style="text-align:left">判断元素是否在 arraylist</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-get.html">get()</a></td><td style="text-align:left">通过索引值获取 arraylist 中的元素</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-indexof.html">indexOf()</a></td><td style="text-align:left">返回 arraylist 中元素的索引值</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-removeall.html">removeAll()</a></td><td style="text-align:left">删除存在于指定集合中的 arraylist 里的所有元素</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-remove.html">remove()</a></td><td style="text-align:left">删除 arraylist 里的单个元素</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-size.html">size()</a></td><td style="text-align:left">返回 arraylist 里元素数量</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-isempty.html">isEmpty()</a></td><td style="text-align:left">判断 arraylist 是否为空</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-sublist.html">subList()</a></td><td style="text-align:left">截取部分 arraylist 的元素</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-set.html">set()</a></td><td style="text-align:left">替换 arraylist 中指定索引的元素</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-sort.html">sort()</a></td><td style="text-align:left">对 arraylist 元素进行排序</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-toarray.html">toArray()</a></td><td style="text-align:left">将 arraylist 转换为数组</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-tostring.html">toString()</a></td><td style="text-align:left">将 arraylist 转换为字符串</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-surecapacity.html">ensureCapacity</a>()</td><td style="text-align:left">设置指定容量大小的 arraylist</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-lastindexof.html">lastIndexOf()</a></td><td style="text-align:left">返回指定元素在 arraylist 中最后一次出现的位置</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-retainall.html">retainAll()</a></td><td style="text-align:left">保留 arraylist 中在指定集合中也存在的那些元素</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-containsall.html">containsAll()</a></td><td style="text-align:left">查看 arraylist 是否包含指定集合中的所有元素</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-trimtosize.html">trimToSize()</a></td><td style="text-align:left">将 arraylist 中的容量调整为数组中的元素个数</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-removerange.html">removeRange()</a></td><td style="text-align:left">删除 arraylist 中指定索引之间存在的元素</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-replaceall.html">replaceAll()</a></td><td style="text-align:left">将给定的操作内容替换掉数组中每一个元素</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-removeif.html">removeIf()</a></td><td style="text-align:left">删除所有满足特定条件的 arraylist 元素</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist-foreach.html">forEach()</a></td><td style="text-align:left">遍历 arraylist 中每一个元素并执行特定操作</td></tr></tbody></table><h3 id="Linked-List">Linked List</h3><p><strong>以下情况使用 ArrayList :</strong></p><ul><li>频繁访问列表中的某一个元素。</li><li>只需要在列表末尾进行添加和删除元素操作。</li></ul><p><strong>以下情况使用 LinkedList :</strong></p><ul><li>你需要通过循环迭代来访问列表中的某些元素。</li><li>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</li></ul><blockquote><p>LinkedList 实现了 Queue 接口、Deque 接口，可作为队列、双向队列使用。</p></blockquote><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-add.html">public boolean add(E e)</a></td><td style="text-align:left">链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-addall.html">public void add(int index, E element)</a></td><td style="text-align:left">向指定位置插入元素。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-addall.html">public boolean addAll(Collection c)</a></td><td style="text-align:left">将一个集合的所有元素添加到链表后面，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-addall.html">public boolean addAll(int index, Collection c)</a></td><td style="text-align:left">将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-addfirst.html">public void addFirst(E e)</a></td><td style="text-align:left">元素添加到头部。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-addlast.html">public void addLast(E e)</a></td><td style="text-align:left">元素添加到尾部。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-offer.html">public boolean offer(E e)</a></td><td style="text-align:left">向链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-offerfirst.html">public boolean offerFirst(E e)</a></td><td style="text-align:left">头部插入元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-offerlast.html">public boolean offerLast(E e)</a></td><td style="text-align:left">尾部插入元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-clear.html">public void clear()</a></td><td style="text-align:left">清空链表。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-removefirst.html">public E removeFirst()</a></td><td style="text-align:left">删除并返回第一个元素。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-removelast.html">public E removeLast()</a></td><td style="text-align:left">删除并返回最后一个元素。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-remove.html">public boolean remove(Object o)</a></td><td style="text-align:left">删除某一元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-remove.html">public E remove(int index)</a></td><td style="text-align:left">删除指定位置的元素。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-poll.html">public E poll()</a></td><td style="text-align:left">删除并返回第一个元素。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-remove.html">public E remove()</a></td><td style="text-align:left">删除并返回第一个元素。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-contains.html">public boolean contains(Object o)&lt;</a>/td&gt;</td><td style="text-align:left">判断是否含有某一元素。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-get.html">public E get(int index)</a></td><td style="text-align:left">返回指定位置的元素。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-getfirst.html">public E getFirst()</a></td><td style="text-align:left">返回第一个元素。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-getlast.html">public E getLast()</a></td><td style="text-align:left">返回最后一个元素。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-indexof.html">public int indexOf(Object o)</a></td><td style="text-align:left">查找指定元素从前往后第一次出现的索引。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-lastindexof.html">public int lastIndexOf(Object o)</a></td><td style="text-align:left">查找指定元素最后一次出现的索引。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-peek.html">public E peek()</a></td><td style="text-align:left">返回第一个元素。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-element.html">public E element()</a></td><td style="text-align:left">返回第一个元素。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-peekfirst.html">public E peekFirst()</a></td><td style="text-align:left">返回头部元素。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-peeklast.html">public E peekLast()</a></td><td style="text-align:left">返回尾部元素。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-set.html">public E set(int index, E element)</a></td><td style="text-align:left">设置指定位置的元素。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-clone.html">public Object clone()</a></td><td style="text-align:left">克隆该列表。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-descendingiterator.html">public Iterator descendingIterator()</a></td><td style="text-align:left">返回倒序迭代器。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-size.html">public int size()</a></td><td style="text-align:left">返回链表元素个数。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist-listiterator.html">public ListIterator listIterator(int index)</a></td><td style="text-align:left">返回从指定位置开始到末尾的迭代器。</td></tr><tr><td style="text-align:left">[public Object<a href="https://www.runoob.com/java/java-linkedlist-toarray.html">] toArray()</a></td><td style="text-align:left">返回一个由链表元素组成的数组。</td></tr><tr><td style="text-align:left">[public T<a href="https://www.runoob.com/java/java-linkedlist-toarray.html">] toArray(T[] a)</a></td><td style="text-align:left">返回一个由链表元素转换类型而成的数组。</td></tr></tbody></table><h3 id="HashSet">HashSet</h3><table><thead><tr><th style="text-align:left"><strong>方法</strong></th><th style="text-align:left"><strong>返回值</strong></th><th style="text-align:left"><strong>说明</strong></th><th style="text-align:left"><strong>示例</strong></th></tr></thead><tbody><tr><td style="text-align:left"><code>add(E e)</code></td><td style="text-align:left"><code>boolean</code></td><td style="text-align:left">添加元素到集合，成功返回 <code>true</code>，重复元素返回 <code>false</code>。</td><td style="text-align:left"><code>set.add(&quot;Java&quot;);</code></td></tr><tr><td style="text-align:left"><code>remove(Object o)</code></td><td style="text-align:left"><code>boolean</code></td><td style="text-align:left">删除指定元素，成功返回 <code>true</code>，元素不存在返回 <code>false</code>。</td><td style="text-align:left"><code>set.remove(&quot;Python&quot;);</code></td></tr><tr><td style="text-align:left"><code>contains(Object o)</code></td><td style="text-align:left"><code>boolean</code></td><td style="text-align:left">检查集合是否包含指定元素。</td><td style="text-align:left"><code>if (set.contains(&quot;Java&quot;)) &#123; ... &#125;</code></td></tr><tr><td style="text-align:left"><code>size()</code></td><td style="text-align:left"><code>int</code></td><td style="text-align:left">返回集合中的元素数量。</td><td style="text-align:left"><code>int count = set.size();</code></td></tr><tr><td style="text-align:left"><code>isEmpty()</code></td><td style="text-align:left"><code>boolean</code></td><td style="text-align:left">判断集合是否为空。</td><td style="text-align:left"><code>if (set.isEmpty()) &#123; ... &#125;</code></td></tr><tr><td style="text-align:left"><code>clear()</code></td><td style="text-align:left"><code>void</code></td><td style="text-align:left">清空集合中的所有元素。</td><td style="text-align:left"><code>set.clear();</code></td></tr><tr><td style="text-align:left"><code>iterator()</code></td><td style="text-align:left"><code>Iterator&lt;E&gt;</code></td><td style="text-align:left">返回集合的迭代器，用于遍历元素。</td><td style="text-align:left"><code>for (String s : set) &#123; ... &#125;</code></td></tr><tr><td style="text-align:left"><code>toArray()</code></td><td style="text-align:left"><code>Object[]</code></td><td style="text-align:left">将集合转换为数组。</td><td style="text-align:left"><code>Object[] arr = set.toArray();</code></td></tr><tr><td style="text-align:left"><code>toArray(T[] a)</code></td><td style="text-align:left"><code>T[]</code></td><td style="text-align:left">将集合转换为指定类型的数组。</td><td style="text-align:left"><code>String[] arr = set.toArray(new String[0]);</code></td></tr><tr><td style="text-align:left"><code>addAll(Collection&lt;? extends E&gt; c)</code></td><td style="text-align:left"><code>boolean</code></td><td style="text-align:left">添加另一个集合的所有元素（并集操作）。</td><td style="text-align:left"><code>set.addAll(Arrays.asList(&quot;A&quot;, &quot;B&quot;));</code></td></tr><tr><td style="text-align:left"><code>retainAll(Collection&lt;?&gt; c)</code></td><td style="text-align:left"><code>boolean</code></td><td style="text-align:left">仅保留与指定集合共有的元素（交集操作）。</td><td style="text-align:left"><code>set.retainAll(otherSet);</code></td></tr><tr><td style="text-align:left"><code>removeAll(Collection&lt;?&gt; c)</code></td><td style="text-align:left"><code>boolean</code></td><td style="text-align:left">删除与指定集合共有的元素（差集操作）。</td><td style="text-align:left"><code>set.removeAll(otherSet);</code></td></tr></tbody></table><h3 id="HashMap">HashMap</h3><p>Java HashMap 常用方法列表如下：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-clear.html">clear()</a></td><td style="text-align:left">删除 hashMap 中的所有键/值对</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-clone.html">clone()</a></td><td style="text-align:left">复制一份 hashMap</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-isempty.html">isEmpty()</a></td><td style="text-align:left">判断 hashMap 是否为空</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-size.html">size()</a></td><td style="text-align:left">计算 hashMap 中键/值对的数量</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-put.html">put()</a></td><td style="text-align:left">将键/值对添加到 hashMap 中</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-putall.html">putAll()</a></td><td style="text-align:left">将所有键/值对添加到 hashMap 中</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-putifabsent.html">putIfAbsent()</a></td><td style="text-align:left">如果 hashMap 中不存在指定的键，则将指定的键/值对插入到 hashMap 中。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-remove.html">remove()</a></td><td style="text-align:left">删除 hashMap 中指定键 key 的映射关系</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-containskey.html">containsKey()</a></td><td style="text-align:left">检查 hashMap 中是否存在指定的 key 对应的映射关系。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-containsvalue.html">containsValue()</a></td><td style="text-align:left">检查 hashMap 中是否存在指定的 value 对应的映射关系。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-replace.html">replace()</a></td><td style="text-align:left">替换 hashMap 中是指定的 key 对应的 value。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-replaceall.html">replaceAll()</a></td><td style="text-align:left">将 hashMap 中的所有映射关系替换成给定的函数所执行的结果。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-get.html">get()</a></td><td style="text-align:left">获取指定 key 对应对 value</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-getordefault.html">getOrDefault()</a></td><td style="text-align:left">获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-foreach.html">forEach()</a></td><td style="text-align:left">对 hashMap 中的每个映射执行指定的操作。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-entryset.html">entrySet()</a></td><td style="text-align:left">返回 hashMap 中所有映射项的集合集合视图。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-keyset.html">keySet</a>()</td><td style="text-align:left">返回 hashMap 中所有 key 组成的集合视图。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-values.html">values()</a></td><td style="text-align:left">返回 hashMap 中存在的所有 value 值。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-merge.html">merge()</a></td><td style="text-align:left">添加键值对到 hashMap 中</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-compute.html">compute()</a></td><td style="text-align:left">对 hashMap 中指定 key 的值进行重新计算</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-computeifabsent.html">computeIfAbsent()</a></td><td style="text-align:left">对 hashMap 中指定 key 的值进行重新计算，如果不存在这个 key，则添加到 hashMap 中</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap-computeifpresent.html">computeIfPresent()</a></td><td style="text-align:left">对 hashMap 中指定 key 的值进行重新计算，前提是该 key 存在于 hashMap 中。</td></tr></tbody></table><h2 id="Java-I-O">Java I/O</h2><p><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/05/20250705095318.png" alt="img"></p><h3 id="字节流（处理二进制数据）">字节流（处理二进制数据）</h3><h4 id="InputStream">InputStream</h4><p><code>InputStream</code>用于从源头（通常是文件）读取数据（字节信息）到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>read()</code></td><td>返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</td></tr><tr><td><code>read(byte b[ ])</code></td><td>从输入流中读取一些字节存储到数组 <code>b</code> 中，返回读取的字节数。如果没有可用字节读取，返回 <code>-1</code>。</td></tr><tr><td><code>read(byte b[], int off, int len)</code></td><td>在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</td></tr><tr><td><code>skip(long n)</code></td><td>忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</td></tr><tr><td><code>available()</code></td><td>返回输入流中可以读取的字节数。</td></tr><tr><td><code>close()</code></td><td>关闭输入流释放相关的系统资源。</td></tr></tbody></table><p>从 Java 9 开始，<code>InputStream</code> 新增加了多个实用的方法：</p><ul><li><code>readAllBytes()</code>：读取输入流中的所有字节，返回字节数组。</li><li><code>readNBytes(byte[] b, int off, int len)</code>：阻塞直到读取 <code>len</code> 个字节。</li><li><code>transferTo(OutputStream out)</code>：将所有字节从一个输入流传递到一个输出流。</li></ul><hr><p><code>FileInputStream</code>配合<code>BufferedInputStream</code>实现读取String对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个 BufferedInputStream 对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 读取文件的内容并复制到 String 对象中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bufferedInputStream.readAllBytes());</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><p><code>DataInputStream</code>可读取多种类型的值、<code>ObjectInputStream</code>可以反序列化对象，使用方法都与上面类似，构造函数使用一个<code>FileInputStream</code>作为参数。</p><h4 id="OutputStream">OutputStream</h4><p><code>OutputStream</code>用于将数据（字节信息）写入到目的地（通常是文件），<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>write(int b)</code></td><td>将特定字节写入输出流。</td></tr><tr><td><code>write(byte b[ ])</code></td><td>将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</td></tr><tr><td><code>write(byte[] b, int off, int len)</code></td><td>在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</td></tr><tr><td><code>flush()</code></td><td>刷新此输出流并强制写出所有缓冲的输出字节。</td></tr><tr><td><code>close()</code></td><td>闭输出流释放相关的系统资源。</td></tr></tbody></table><h3 id="字符流（处理文本数据）">字符流（处理文本数据）</h3><h4 id="Reader">Reader</h4><p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p><p>方法与<code>InputStream</code>类似，但是类型由<code>byte</code>改为<code>char</code>。</p><h4 id="Writer">Writer</h4><p>同理。但是除可写入<code>char[]</code>类型外还可写入<code>String</code>类。</p><h3 id="I-O模型">I/O模型</h3><ul><li>BIO：<strong>同步阻塞I/O</strong></li><li>NIO（Non-Blocking I/O、New I/O）：<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong></li><li>AIO（Asynchronous I/O）：<strong>信号驱动 I/O</strong> 、<strong>异步 I/O</strong></li></ul><h2 id="并发编程">并发编程</h2><h3 id="进程和线程">进程和线程</h3><ul><li><strong>进程</strong>：进程是一个正在执行的程序实例。每个进程都有独立的内存空间、系统资源分配（如文件描述符等）以及一个或多个线程。</li><li><strong>线程</strong>：线程是进程内的基本执行单位，是操作系统进行运行操作的最小单元。一个进程内的所有线程共享该进程的资源，包括内存空间和文件描述符等。</li></ul><blockquote><p>共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></p></blockquote><h4 id="线程的生命周期和状态">线程的生命周期和状态</h4><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p><ul><li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li><li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li><li>BLOCKED：阻塞状态，需要等待锁释放。</li><li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li>TERMINATED：终止状态，表示该线程已经运行完毕。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/bush-cn/TyporaImages@main/img/2025/07/06/20250706105802.png" alt="Java 线程状态变迁图"></p><h3 id="并发与并行的区别">并发与并行的区别</h3><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li></ul><p>最关键的点是：是否是 <strong>同时</strong> 执行。</p><h3 id="同步和异步的区别">同步和异步的区别</h3><ul><li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用直接返回。</li></ul><h3 id="死锁">死锁</h3><p>死锁的四个必要条件：</p><ol><li><strong>互斥条件</strong>：该资源任意一个时刻只由一个线程占用。</li><li><strong>请求与保持条件</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li><strong>不剥夺条件</strong>：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li><strong>循环等待条件</strong>：若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><hr><blockquote><p>参考：<a href="https://javaguide.cn/">https://javaguide.cn/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题及解决方案</title>
      <link href="/2025/06/13/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2025/06/13/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="跨域请求问题">跨域请求问题</h2><p>跨域请求问题是**浏览器的同源策略（Same-Origin Policy, SOP）**所导致的一种前端限制。</p><h3 id="同源">同源</h3><p>所谓“同源”，是指两个页面的协议（protocol）、域名（host）和端口（port）<strong>必须完全相同</strong>。</p><p>例如：</p><table><thead><tr><th>URL</th><th>是否同源</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://example.com/page1">http://example.com/page1</a></td><td>是</td><td>与自己比</td></tr><tr><td><a href="http://example.com:8080/page1">http://example.com:8080/page1</a></td><td>否</td><td>端口不同</td></tr><tr><td><a href="https://example.com/page1">https://example.com/page1</a></td><td>否</td><td>协议不同</td></tr><tr><td><a href="http://api.example.com/page1">http://api.example.com/page1</a></td><td>否</td><td>子域不同</td></tr></tbody></table><h3 id="跨域">跨域</h3><p>当浏览器的网页尝试向<strong>不同源的服务器</strong>发送请求时，就发生了<strong>跨域请求</strong>，如：</p><ul><li>当前网页在 <code>http://localhost:8080</code></li><li>JS 发起 AJAX 请求到 <code>http://api.example.com</code>，此时就是跨域请求</li></ul><p>常见跨域行为包括：</p><ul><li>Ajax 请求接口</li><li>加载第三方脚本、样式、图片（部分不受限制）</li><li>使用 <code>fetch</code> 获取不同域资源</li><li>WebSocket（需特殊处理）</li></ul><h3 id="Spring-Boot-中跨域的处理方法">Spring Boot 中跨域的处理方法</h3><p><strong>CORS（Cross-Origin Resource Sharing，跨域资源共享）</strong> 是一种<strong>浏览器与服务器之间</strong>的协议，允许浏览器从<strong>不同源的服务器</strong>安全地请求资源。</p><p>CORS 是当前主流的解决跨域请求的方法。Spring Boot中，可以在控制器方法上加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://localhost:3000&quot;)</span> <span class="comment">// 允许来自 localhost:3000 的跨域请求</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/data&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt; getData() &#123;</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们大作业采用的另一种方法是编写全局跨域配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)  <span class="comment">// 改为对所有路径生效</span></span><br><span class="line">                .allowedOrigins(<span class="string">&quot;[your-origin-url]&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)  <span class="comment">// 允许所有头部</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
            <tag> 跨域 </tag>
            
            <tag> CORS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket使用</title>
      <link href="/2025/06/13/WebSocket%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/06/13/WebSocket%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="WebSocket"><strong>WebSocket</strong></h2><p>WebSocket 是一种<strong>基于 TCP 协议</strong>的<strong>全双工通信协议</strong>，它允许客户端和服务器之间建立持久的、双向的通信连接。相比传统的 HTTP 请求 - 响应模式，WebSocket 提供了实时、低延迟的数据传输能力。通过 WebSocket，客户端和服务器可以<strong>随时发送数据</strong>，而不需要每次都重新建立连接。实现<strong>实时更新和即时通信</strong>的功能。</p><p>WebSocket 协议经过了多个浏览器和服务器的支持，成为了现代 Web 应用中常用的通信协议之一。它广泛应用于聊天应用、实时数据更新、多人游戏等场景，为 Web 应用提供了更好的用户体验和更高效的数据传输方式。</p><table><thead><tr><th>特点</th><th>描述</th></tr></thead><tbody><tr><td><strong>持久连接</strong></td><td>建立一次连接后，客户端和服务器之间保持连接状态</td></tr><tr><td><strong>全双工通信</strong></td><td>客户端和服务器都可以主动发送消息</td></tr><tr><td><strong>低延迟、实时性强</strong></td><td>适合聊天、游戏、股票、实时推送等应用</td></tr><tr><td><strong>节省资源</strong></td><td>与传统 HTTP 请求相比，减少了请求头等开销</td></tr><tr><td><strong>基于 TCP 协议</strong></td><td>和 HTTP 一样基于 TCP，但是一个独立协议</td></tr></tbody></table><h3 id="Spring-Boot中使用WebSocket">Spring Boot中使用WebSocket</h3><p>以我们组的大作业为例，在学生答题端和教师监考端之间建立了WebSocket连接，实现答题进度及考试状态实时通信。具体步骤如下：</p><h4 id="1-引入依赖">1. 引入依赖</h4><p>在<code>pom.xml</code>中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-创建配置类">2. 创建配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.buaa.javahuikao.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.simp.config.MessageBrokerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.StompEndpointRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry config)</span> &#123;</span><br><span class="line">        config.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>); <span class="comment">// 客户端订阅地址前缀</span></span><br><span class="line">        config.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>); <span class="comment">// 服务端接收消息地址前缀</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/ws&quot;</span>) <span class="comment">// WebSocket连接端点</span></span><br><span class="line">                .setAllowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>enableSimpleBroker(&quot;/topic&quot;)</code>：启用了一个 <strong>简单的内存消息代理（message broker）</strong>，当客户端订阅 <code>/topic/*</code> 开头的地址时，消息将会被推送到这些订阅者。</p></li><li><p><code>setApplicationDestinationPrefixes(&quot;/app&quot;)</code>：客户端向服务端 <strong>发送消息的路径前缀</strong>。只有以 <code>/app</code> 开头的消息，才会被 <code>@MessageMapping</code> 注解的方法接收处理。</p></li><li><p><code>addEndpoint(&quot;/ws&quot;)</code>：注册一个 <strong>WebSocket 连接端点</strong>，客户端将通过这个地址发起连接（例如：<code>ws://localhost:8080/ws</code>）。</p></li><li><p><code>setAllowedOriginPatterns(&quot;*&quot;)</code>：允许所有来源跨域连接（生产环境建议指定具体域名）。</p><p><code>withSockJS()</code>：启用 <strong>SockJS 兼容模式</strong>，保证在 WebSocket 不可用时（如浏览器不支持）可以回退到 AJAX 长轮询。</p></li></ul><h4 id="3-在REST接口类中使用WebSocket">3. 在REST接口类中使用WebSocket</h4><p>首先注入 <code>SimpMessagingTemplate</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SimpMessagingTemplate messagingTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InvigilationController</span><span class="params">(SimpMessagingTemplate messagingTemplate)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.messagingTemplate = messagingTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>SimpMessagingTemplate</code> 是 Spring 提供的一个工具类，用于在服务端向客户端 <strong>发送 STOMP 消息</strong>。</li><li>可以理解为是一个“消息发送器”，配合前面的 <code>WebSocketConfig</code> 使用。</li></ul><p>接着，使用<code>messagingTemplate.convertAndSend(destination, payload)</code>向服务端推送消息。此处，</p><h4 id="4-前端订阅消息并更新页面">4. 前端订阅消息并更新页面</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立WebSocket连接</span></span><br><span class="line"><span class="keyword">const</span> socketProgress = <span class="keyword">new</span> <span class="title class_">SockJS</span>(<span class="string">&quot;http://localhost:8081/ws&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> stompClientProgress = <span class="title class_">Stomp</span>.<span class="title function_">over</span>(socketProgress);</span><br><span class="line">stompClientProgress.<span class="title function_">connect</span>(&#123;&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebSocket Progress 连接成功！&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> examId = exam_id</span><br><span class="line">    <span class="keyword">const</span> subscription = stompClientProgress.<span class="title function_">subscribe</span>(</span><br><span class="line">        <span class="string">`/topic/exam/<span class="subst">$&#123;examId&#125;</span>/progress`</span>,</span><br><span class="line">        <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(message.<span class="property">body</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;收到进度更新:&quot;</span>, data);</span><br><span class="line">            <span class="title function_">updateStudentProgress</span>(data.<span class="property">studentId</span>, data.<span class="property">progress</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立WebSocket连接</span></span><br><span class="line"><span class="keyword">const</span> socketStatus = <span class="keyword">new</span> <span class="title class_">SockJS</span>(<span class="string">&quot;http://localhost:8081/ws&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> stompClientStatus = <span class="title class_">Stomp</span>.<span class="title function_">over</span>(socketStatus);</span><br><span class="line">stompClientStatus.<span class="title function_">connect</span>(&#123;&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebSocket Status 连接成功！&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> examId = exam_id</span><br><span class="line">    <span class="keyword">const</span> subscription = stompClientStatus.<span class="title function_">subscribe</span>(</span><br><span class="line">        <span class="string">`/topic/exam/<span class="subst">$&#123;examId&#125;</span>/status`</span>,</span><br><span class="line">        <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(message.<span class="property">body</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;收到状态更新:&quot;</span>, data);</span><br><span class="line">            <span class="title function_">updateStudentStatus</span>(data.<span class="property">studentId</span>, data.<span class="property">status</span>, data.<span class="property">description</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
            <tag> WebSocket </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 多线程</title>
      <link href="/2025/06/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2025/06/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Java多线程"><strong>Java多线程</strong></h2><h3 id="Java-SE中的多线程">Java SE中的多线程</h3><p>Java SE中最基础的多线程方式（适用于任何Java程序）包括两种：</p><ul><li><p><strong>方法1：继承 Thread 类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程名：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.start();  <span class="comment">// 启动线程，run() 方法会被自动调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>方法2：实现 Runnable 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程名：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p>此外，还可以使用线程池。Java 提供 <code>ExecutorService</code> 接口，Spring Boot 中也常用线程池来管理并发任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>); <span class="comment">// 创建固定线程数的线程池</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        executor.submit(task);</span><br><span class="line">        executor.shutdown(); <span class="comment">// 关闭线程池（不立即关闭，会等待任务完成）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Boot-中使用多线程">Spring Boot 中使用多线程</h3><p>Spring Boot 提供了更加优雅的方式来使用多线程：</p><h4 id="方法1-使用-Async-异步方法（简单高效）">方法1. 使用 <code>@Async</code> 异步方法（简单高效）</h4><p>第一步：启动类或配置类上加 <code>@EnableAsync</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span>  <span class="comment">// 启用异步支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：在你要异步执行的方法上加 <code>@Async</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTaskService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行任务，线程名：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：调用异步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyTaskService taskService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/run&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">runTask</span><span class="params">()</span> &#123;</span><br><span class="line">        taskService.doTask();  <span class="comment">// 异步执行，不阻塞主线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务已提交&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法2-自定义线程池配置（高级）">方法2. 自定义线程池配置（高级）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;customExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">taskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">5</span>);       <span class="comment">// 核心线程数</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">10</span>);       <span class="comment">// 最大线程数</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>);    <span class="comment">// 队列容量</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;MyExecutor-&quot;</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>@Async</code> 中指定线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async(&quot;customExecutor&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行任务，线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体在我们的大作业中，我们配置了提交答案和状态更新两个线程池，保证大量并发请求的执行响应速度。</p><h4 id="线程池-vs-Async">线程池 vs @Async</h4><table><thead><tr><th>场景</th><th>推荐做法</th></tr></thead><tbody><tr><td>简单异步处理（发邮件、发短信）</td><td><code>@Async</code></td></tr><tr><td>控制线程数、可复用线程资源</td><td>自定义线程池</td></tr><tr><td>定时任务</td><td>使用 <code>@Scheduled</code></td></tr><tr><td>批量并发任务，需获取返回值</td><td><code>CompletableFuture + @Async</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记</title>
      <link href="/2025/06/13/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/06/13/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>Redis学习笔记</h1><h2 id="Redis"><strong>Redis</strong></h2><h3 id="Redis简介">Redis简介</h3><p>Redis（<strong>Remote Dictionary Server</strong>）是一种<strong>开源的、基于内存的键值对（key-value）数据库</strong>，可以用作数据库、缓存和消息中间件。它以<strong>极高的性能、丰富的数据结构和多种实用功能</strong>而著称，被广泛用于高并发、低延迟的应用场景中，如电商秒杀、社交应用、排行榜、会话缓存等。</p><h4 id="Redis特点">Redis特点</h4><table><thead><tr><th>特点</th><th>说明</th></tr></thead><tbody><tr><td><strong>高性能</strong></td><td>所有数据操作都在内存中完成，读写速度极快（百万级QPS）。</td></tr><tr><td><strong>丰富数据结构</strong></td><td>支持多种数据类型：字符串（string）、列表（list）、集合（set）、有序集合（zset）、哈希表（hash）、位图、HyperLogLog、地理位置等。</td></tr><tr><td><strong>持久化</strong></td><td>虽然是内存数据库，但支持将数据持久化到磁盘，防止宕机数据丢失（RDB快照和AOF日志）。</td></tr><tr><td><strong>支持事务</strong></td><td>可以一次执行多个命令，具备基本的事务特性（MULTI/EXEC）。</td></tr><tr><td><strong>支持发布/订阅</strong></td><td>可实现消息系统的 pub/sub 通信模型。</td></tr><tr><td><strong>支持主从复制与集群</strong></td><td>具备高可用（哨兵）与分布式（Redis Cluster）能力。</td></tr><tr><td><strong>原子操作</strong></td><td>所有单条 Redis 命令都是原子的，适合做计数器、分布式锁等。</td></tr></tbody></table><h4 id="Redis的典型应用场景">Redis的典型应用场景</h4><ul><li>页面缓存（如商品详情页、热点新闻）</li><li>Session存储（分布式登录状态维护）</li><li>秒杀系统（抢购计数、库存控制）</li><li>排行榜系统（ZSet）</li><li>实时消息推送（Pub/Sub）</li><li>分布式锁（基于setnx等命令）</li></ul><h4 id="NoSQL">NoSQL</h4><p>NoSQL（<strong>Not Only SQL</strong>）是一类<strong>非关系型数据库系统</strong>的统称，设计初衷是为了解决传统关系型数据库（如MySQL、Oracle）在高并发、大数据量、分布式存储等场景下的性能瓶颈。</p><p>NoSQL包括以下类型：</p><table><thead><tr><th>类型</th><th>代表数据库</th><th>描述</th><th>典型用途</th></tr></thead><tbody><tr><td><strong>键值（Key-Value）</strong></td><td><strong>Redis</strong>, Riak</td><td>以 key 映射 value，结构简单，性能极高</td><td>缓存、会话存储</td></tr><tr><td><strong>文档型</strong></td><td>MongoDB, CouchDB</td><td>类似 JSON 的文档结构，灵活支持嵌套字段</td><td>内容管理、用户信息存储</td></tr><tr><td><strong>列族型（宽列）</strong></td><td>HBase, Cassandra</td><td>按列存储数据，适合大数据分析</td><td>日志系统、数据仓库</td></tr><tr><td><strong>图数据库</strong></td><td>Neo4j, JanusGraph</td><td>用节点和边表示数据及其关系</td><td>社交网络、知识图谱、推荐系统</td></tr></tbody></table><h3 id="Redis-数据类型">Redis 数据类型</h3><table><thead><tr><th>数据类型</th><th>说明</th><th>常见用途</th></tr></thead><tbody><tr><td>String（字符串）</td><td>基本的数据存储单元，可以存储字符串、整数或者浮点数。</td><td>缓存、计数器</td></tr><tr><td>Hash（哈希）</td><td>一个键值对集合，可以存储多个字段。</td><td>用户信息、配置项</td></tr><tr><td>List（列表）</td><td>一个简单的列表，可以存储一系列的字符串元素。</td><td>队列、任务流</td></tr><tr><td>Set（集合）</td><td>一个无序集合，可以存储不重复的字符串元素。</td><td>标签、去重、社交关系</td></tr><tr><td>ZSet（有序集合）</td><td>类似于集合，但是每个元素都有一个分数与之关联。</td><td>排行榜、评分系统</td></tr><tr><td>Bitmap（位图）</td><td>基于字符串类型，可以对每个位进行操作。</td><td>签到、状态记录</td></tr><tr><td>HyperLogLog</td><td>用于基数统计，可以估算集合中的唯一元素数量。</td><td>UV、去重统计</td></tr><tr><td>GEO</td><td>用于存储地理位置信息。</td><td>附近的人、位置服务</td></tr><tr><td>Pub/Sub</td><td>一种消息通信模式，允许客户端订阅消息通道，并接收发布到该通道的消息。</td><td>通知系统、聊天室</td></tr></tbody></table><h4 id="1-String（字符串）">1. String（字符串）</h4><ul><li><p><strong>最基础的数据类型</strong>，一个键对应一个字符串值，可以是文本或二进制数据（如图片、JSON、数字等）。</p><blockquote><p>一个键最大能存储 512MB</p></blockquote></li><li><p>操作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SET key value<span class="comment"># 设置键的值</span></span><br><span class="line">GET key<span class="comment"># 获取键的值</span></span><br><span class="line">INCR key<span class="comment"># 将键的值加 1</span></span><br><span class="line">DECR key<span class="comment"># 将键的值减 1</span></span><br><span class="line">APPEND key value<span class="comment"># 将值追加到键的值之后</span></span><br></pre></td></tr></table></figure></li><li><p><strong>应用场景</strong>：</p><ul><li>缓存文本信息</li><li>计数器（如访问量）</li><li>存储JSON（如用户token）</li></ul></li></ul><h4 id="2-Hash（哈希）">2. Hash（哈希）</h4><ul><li><p>类似 Java 中的 Map 或 Python 的字典，一个键对应一个字段集合，每个字段有自己的值。</p></li><li><p>操作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value<span class="comment"># 设置哈希表中字段的值。</span></span><br><span class="line">HGET key field<span class="comment"># 获取哈希表中字段的值。</span></span><br><span class="line">HGETALL key<span class="comment"># 获取哈希表中所有字段和值。</span></span><br><span class="line">HDEL key field<span class="comment"># 删除哈希表中的一个或多个字段。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>应用场景</strong>：</p><ul><li>存储对象（如用户、商品属性）</li><li>节省内存（相比多个字符串键）</li></ul></li></ul><h4 id="3-List（列表）">3. List（列表）</h4><ul><li><p>一个键对应一个链表结构，支持两端插入（可作队列或栈）。</p></li><li><p>操作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key value<span class="comment"># 将值插入到列表头部。</span></span><br><span class="line">RPUSH key value<span class="comment"># 将值插入到列表尾部。</span></span><br><span class="line">LPOP key<span class="comment"># 移出并获取列表的第一个元素。</span></span><br><span class="line">RPOP key<span class="comment"># 移出并获取列表的最后一个元素。</span></span><br><span class="line">LRANGE key start stop<span class="comment"># 获取列表在指定范围内的元素。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>应用场景</strong>：</p><ul><li>消息队列</li><li>任务列表（如评论流、延迟队列）</li></ul></li></ul><h4 id="4-Set（集合）">4. Set（集合）</h4><ul><li><p>无序、<strong>不重复</strong>的字符串集合。</p></li><li><p>操作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SADD key value<span class="comment"># 向集合添加一个或多个成员。</span></span><br><span class="line">SREM key value<span class="comment"># 移除集合中的一个或多个成员。</span></span><br><span class="line">SMEMBERS key<span class="comment"># 返回集合中的所有成员。</span></span><br><span class="line">SISMEMBER key value<span class="comment"># 判断值是否是集合的成员。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>应用场景</strong>：</p><ul><li>标签系统</li><li>共同好友计算（交集）</li><li>去重（如IP集合）</li></ul></li></ul><h4 id="5-Sorted-Set（有序集合，ZSet）">5. Sorted Set（有序集合，ZSet）</h4><ul><li><p>类似 Set，但每个元素带一个分数（score，double型），按分数排序。</p></li><li><p>操作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score value<span class="comment"># 向有序集合添加一个或多个成员，或更新已存在成员的分数。</span></span><br><span class="line">ZRANGE key start stop [WITHSCORES]<span class="comment"># 返回指定范围内的成员。</span></span><br><span class="line">ZREM key value<span class="comment"># 移除有序集合中的一个或多个成员。</span></span><br><span class="line">ZSCORE key value<span class="comment"># 返回有序集合中，成员的分数值。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>应用场景</strong>：</p><ul><li>排行榜（积分、排名）</li><li>优先级队列</li><li>带权重排序的数据列表</li></ul></li></ul><h4 id="6-Bitmap（二进制位图）">6. Bitmap（二进制位图）</h4><ul><li><p>用二进制位表示布尔状态，每个位可设置为0或1，适用于大量布尔信息存储。</p></li><li><p>操作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SETBIT online_users 1234 1</span><br><span class="line">GETBIT online_users 1234</span><br><span class="line">BITCOUNT online_users</span><br></pre></td></tr></table></figure></li><li><p><strong>应用场景</strong>：</p><ul><li>用户签到记录（某天是否在线）</li><li>活跃用户统计</li><li>登录状态记录</li></ul></li></ul><h4 id="7-HyperLogLog">7. HyperLogLog</h4><ul><li><p>用于<strong>统计唯一元素个数</strong>（近似值），但占用内存极小（12KB 固定）。</p></li><li><p>操作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PFADD uv_counter user1 user2</span><br><span class="line">PFCOUNT uv_counter</span><br></pre></td></tr></table></figure></li><li><p><strong>应用场景</strong>：</p><ul><li>网站 UV 统计</li><li>去重计数但不要求精确</li></ul></li></ul><h4 id="8-GEO（地理空间坐标）">8. GEO（地理空间坐标）</h4><ul><li><p>存储经纬度坐标，并支持附近查询等操作。</p></li><li><p>操作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GEOADD locations 116.40 39.90 <span class="string">&quot;Beijing&quot;</span></span><br><span class="line">GEODIST locations <span class="string">&quot;Beijing&quot;</span> <span class="string">&quot;Shanghai&quot;</span></span><br><span class="line">GEORADIUS locations 116.40 39.90 100 km</span><br></pre></td></tr></table></figure></li><li><p><strong>应用场景</strong>：</p><ul><li>附近的人、附近的店</li><li>LBS（基于地理位置服务）</li></ul></li></ul><h4 id="9-Pub-Sub（发布订阅）">9. Pub/Sub（发布订阅）</h4><ul><li><p>Redis 的<strong>消息系统</strong>，支持发布-订阅机制。</p></li><li><p>操作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE news</span><br><span class="line">PUBLISH news <span class="string">&quot;Redis 6.0 released&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>应用场景</strong>：</p><ul><li>实时消息推送</li><li>聊天室系统</li><li>日志采集系统</li></ul></li></ul><h3 id="Redis键">Redis键</h3><p>通用命令如下：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>SET key value</code></td><td>设置键的值</td></tr><tr><td><code>GET key</code></td><td>获取键的值</td></tr><tr><td><code>DEL key</code></td><td>删除键</td></tr><tr><td><code>EXISTS key</code></td><td>判断键是否存在</td></tr><tr><td><code>EXPIRE key seconds</code></td><td>设置键的过期时间</td></tr><tr><td><code>TTL key</code></td><td>查看剩余存活时间</td></tr><tr><td><code>KEYS pattern</code></td><td>按模式查找键（如 <code>user:*</code>）</td></tr><tr><td><code>TYPE key</code></td><td>返回键的数据类型</td></tr></tbody></table><p>键管理命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>EXPIRE key seconds</code></td><td>设置过期时间（秒）</td></tr><tr><td><code>PEXPIRE key milliseconds</code></td><td>设置过期时间（毫秒）</td></tr><tr><td><code>TTL key</code></td><td>查看剩余生存时间</td></tr><tr><td><code>PERSIST key</code></td><td>移除过期时间</td></tr><tr><td><code>RENAME old new</code></td><td>重命名键</td></tr></tbody></table><h3 id="Redis事务">Redis事务</h3><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>MULTI</code></td><td>开启事务</td></tr><tr><td><code>EXEC</code></td><td>提交事务</td></tr><tr><td><code>DISCARD</code></td><td>放弃事务</td></tr><tr><td><code>WATCH key</code></td><td>监视键值是否被其他客户端修改</td></tr></tbody></table><h3 id="Redis连接与服务器">Redis连接与服务器</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>AUTH password</code></td><td>验证密码是否正确</td></tr><tr><td><code>ECHO message</code></td><td>打印字符串</td></tr><tr><td><code>PING</code></td><td>查看服务器是否运行</td></tr><tr><td><code>QUIT</code></td><td>关闭当前连接</td></tr><tr><td><code>SELECT index</code></td><td>切换到指定的数据库</td></tr><tr><td><code>INFO</code></td><td>查看服务器信息和统计</td></tr><tr><td><code>MONITOR</code></td><td>实时查看操作命令</td></tr><tr><td><code>FLUSHDB</code></td><td>清空当前数据库</td></tr><tr><td><code>FLUSHALL</code></td><td>清空所有数据库</td></tr><tr><td><code>DBSIZE</code></td><td>返回当前数据库中 key 的数量</td></tr></tbody></table><h3 id="Redis数据备份与恢复">Redis数据备份与恢复</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>SAVE</code></td><td>同步保存快照（阻塞）</td></tr><tr><td><code>BGSAVE</code></td><td>异步保存快照</td></tr><tr><td><code>BGREWRITEAOF</code></td><td>重写 AOF 文件</td></tr><tr><td><code>LASTSAVE</code></td><td>上次保存的时间</td></tr></tbody></table><h3 id="Java（Spring-Boot）中使用Redis">Java（Spring Boot）中使用Redis</h3><p>以我们组的大作业项目为例，我们采用Redis实现试卷数据的缓存，使得试卷在毫秒内加载完成。</p><h4 id="1-添加依赖">1. 添加依赖</h4><p>在 pom.xml 文件中添加 Redis 相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Spring Data Redis --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-配置Redis连接信息">2. 配置Redis连接信息</h4><p>在<code>application.yml</code>中添加连接信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># ……其他配置</span></span><br><span class="line">  <span class="comment"># Redis配置</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">50</span>  <span class="comment"># 匹配线程池大小</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">20</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="3-使用RedisTemplate进行操作">3. 使用RedisTemplate进行操作</h4><p>创建配置类，其作用是定义一个自定义的 <code>RedisTemplate&lt;String, Object&gt;</code> Bean，指定序列化方式，以便在项目中可以更方便地使用 Redis 存储和读取对象数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.buaa.javahuikao.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.runtime.ObjectMethods;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(factory);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ExamService.java</code>中注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br></pre></td></tr></table></figure><p>使用<code>redisTemplate.opsForValue().get(cacheKey)</code>从缓存中获取数据、<code>redisTemplate.opsForValue().set(cacheKey,jsonData)</code>向缓存中写入数据。此处使用Jackson的序列化工具<code>ObjectMapper</code>将对象与Json字符串相互转换，redis缓存中存的字符串值为序列化后的Json字符串，读取缓存后也需要反序列化为Java对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.buaa.javahuikao.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.buaa.javahuikao.dto.StudentExamQuestionDTO;</span><br><span class="line"><span class="keyword">import</span> com.buaa.javahuikao.mapper.ExamQuestionMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisCallback;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamQuestionService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXAM_QUESTIONS_KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;exam:questions:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">CACHE_EXPIRE_HOURS</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">// 缓存过期时间(小时)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ExamQuestionMapper examQuestionMapper;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper; <span class="comment">//json处理器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StudentExamQuestionDTO <span class="title function_">getExamQuestions</span><span class="params">(<span class="type">int</span> examId)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> EXAM_QUESTIONS_KEY_PREFIX + examId;</span><br><span class="line">        <span class="comment">//尝试从缓存获取</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cachedData</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span>(cachedData != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> objectMapper.readValue(cachedData,StudentExamQuestionDTO.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;redis缓存错误：&quot;</span>+ e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缓存未命中</span></span><br><span class="line">        <span class="type">StudentExamQuestionDTO</span> <span class="variable">questions</span> <span class="operator">=</span> examQuestionMapper.getExamQuestions(examId);</span><br><span class="line">        <span class="comment">//写入缓存</span></span><br><span class="line">        <span class="keyword">if</span> (questions!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">jsonData</span> <span class="operator">=</span> objectMapper.writeValueAsString(questions);</span><br><span class="line">                redisTemplate.opsForValue().set(</span><br><span class="line">                        cacheKey,</span><br><span class="line">                        jsonData,</span><br><span class="line">                        CACHE_EXPIRE_HOURS,</span><br><span class="line">                        TimeUnit.HOURS</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(JsonProcessingException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;写入缓存错误：&quot;</span>+ e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> questions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于具有共同属性C/C++函数生成测试用例的有效性实验</title>
      <link href="/2025/03/04/%E5%9F%BA%E4%BA%8E%E5%85%B7%E6%9C%89%E5%85%B1%E5%90%8C%E5%B1%9E%E6%80%A7C-C-%E5%87%BD%E6%95%B0%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7%E5%AE%9E%E9%AA%8C/"/>
      <url>/2025/03/04/%E5%9F%BA%E4%BA%8E%E5%85%B7%E6%9C%89%E5%85%B1%E5%90%8C%E5%B1%9E%E6%80%A7C-C-%E5%87%BD%E6%95%B0%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1>基于具有共同属性C/C++函数生成测试用例的有效性实验</h1><p>验证有效性：若C/C++语言的两个函数在文件读写、分配内存、参数处理、结构体构造或极端数值等方面存在相似性，则他们对应的单元测试代码可以提供参考性。</p><p>由于Github中C/C++语言的单元测试代码少，且多因为测试粒度问题在一个测试用例中测试的是一整个模块、涉及多个函数，因此可能只找到符合条件的两函数后，对其中一个函数先生成单测后再进行实验。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++单元测试生成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++单元测试生成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图神经网络论文阅读</title>
      <link href="/2025/03/02/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
      <url>/2025/03/02/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1>Graph Attention Networks</h1><h3 id="1-研究背景与动机">1. 研究背景与动机</h3><ul><li><strong>图数据的挑战</strong>：传统的卷积神经网络（CNNs）适用于规则网格数据（如图像），但很多实际任务（如社交网络、生物网络等）中的数据以图的形式存在，结构不规则。</li><li>现有方法的不足：<ul><li><strong>谱方法</strong>：基于图拉普拉斯特征分解，<strong>计算量大</strong>且<strong>依赖于特定图结构</strong>，难以泛化到新图。</li><li><strong>非谱方法</strong>（MoNet, GraphSAGE)：直接在图上定义卷积操作，但难以统一处理邻居数目不固定的问题。</li></ul></li><li><strong>自注意力机制启发</strong>：近年来，自注意力在序列模型（如机器翻译）中表现突出，启发作者将自注意力思想应用到图数据中，更灵活地聚合邻居信息，以完成图数据的节点分类任务。</li><li>自注意力结构的特点：<ol><li>计算高效，所有运算可以并行化</li><li>通过指定任意的邻节点权重，可以处理节点度数不同的图</li><li>模型可直接应用于归纳学习任务，可以泛化到模型从未见过的图</li></ol></li></ul><hr><h3 id="2-Graph-Attention-Networks（GAT）方法简介">2. Graph Attention Networks（GAT）方法简介</h3><ul><li><strong>核心思想</strong>：通过自注意力机制，让每个节点在聚合自身邻居特征时，根据邻居的重要性分配不同权重，从而获得更有效的节点表示。</li><li><strong>输入与输出</strong>：输入为节点特征集合 <strong>h</strong>，输出为更新后的节点特征 <strong>h</strong>′，支持特征维度变换。</li><li><strong>Graph Attention Layer的关键步骤</strong>：<ol><li><strong>线性变换</strong>：通过权重矩阵 <strong>W</strong> 对所有节点的输入特征进行同样的线性变换，得到新的特征表示。</li><li><strong>计算注意力系数</strong>：<ul><li>对于每个节点 i 及其一阶邻居 j（含i），利用一个共享的注意力机制（单层前馈网络加上 LeakyReLU 激活）计算原始的注意力分数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">e_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。</li><li>对每个节点的所有邻居分数进行 softmax 归一化，得到归一化的注意力系数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\alpha_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。</li></ul></li><li><strong>特征聚合</strong>：使用归一化后的注意力系数，对邻居节点的特征进行加权求和，并经过sigmoid非线性激活，生成新的节点表示。</li><li><strong>多头注意力</strong>：通过并行执行多个独立的注意力机制（即多头注意力），提升模型的稳定性与表达能力。最后在输出层可选择拼接（中间层）或平均（输出层）多头结果。</li></ol></li><li><strong>优势</strong>：<ul><li><strong>计算高效</strong>：无需矩阵分解或全局图结构信息，计算复杂度与GCN相当（O(∣V∣FF′+∣E∣F′) ，支持并行化。</li><li><strong>动态权重分配</strong>：通过注意力机制为不同邻居分配不同权重，提升模型表达能力。</li><li><strong>灵活性强</strong>：不依赖于图的全局结构，可处理有向图、不同大小的邻居集合，且适用于归纳学习（处理训练时未见过的新图）。</li><li><strong>可解释性</strong>：注意力系数反映了模型在聚合邻居信息时对各邻居的关注程度，有助于理解模型的决策过程。</li></ul></li></ul><hr><h3 id="3-实验设置与结果">3. 实验设置与结果</h3><ul><li><strong>数据集</strong>：<ul><li><strong>转导任务</strong>：使用 Cora、Citeseer 和 Pubmed 三个标准引文网络数据集，节点特征为文档的词袋表示，每个节点对应一个类别。</li><li><strong>归纳任务</strong>：使用蛋白质相互作用（PPI）数据集，该数据集包含多个不同的图，测试时的图完全未在训练中出现。</li></ul></li><li><strong>模型结构</strong>：<ul><li><strong>转导任务</strong>：采用两层 GAT 模型，第一层使用多头注意力（例如 8 个头）提取中间特征，第二层用于分类，配合 dropout 和 L2 正则化。</li><li><strong>归纳任务</strong>：采用三层 GAT 模型，并利用跳跃连接来缓解深层模型训练中的信息衰减问题。</li></ul></li><li><strong>实验结果</strong>：<ul><li>在转导任务上，GAT 在 Cora、Citeseer 和 Pubmed 数据集上均超过或匹配了如 GCN、Chebyshev 滤波器和 MoNet 等多种方法的表现。</li><li>在归纳任务（PPI 数据集）上，GAT 显著提升了微平均 F1 得分，验证了其在新图环境下的强泛化能力，同时也证明了赋予邻居不同权重的重要性。</li></ul></li></ul><hr><h3 id="4-结论与未来工作">4. 结论与未来工作</h3><ul><li><strong>主要贡献</strong>：<ul><li>提出了基于自注意力机制的图神经网络架构，能够灵活高效地处理图结构数据。</li><li>在不需要事先知道全局图结构的前提下，实现了对不同大小邻居集合的有效处理，并适用于归纳学习。</li><li>在多个标准数据集上达到了最先进的性能，验证了模型的有效性和广泛适用性。</li></ul></li><li><strong>未来研究方向</strong>：<ul><li>扩展模型到图分类任务。</li><li>探索如何更高效地处理大规模图数据和提高批处理能力。</li><li>深入利用注意力机制进行模型解释，并尝试整合边特征信息以处理更复杂的图数据。</li></ul></li></ul><h1>Deep Graph Infomax (DGI)</h1><h3 id="1-研究背景与动机-2">1. 研究背景与动机</h3><ul><li><strong>图数据的挑战</strong>：传统的图神经网络（如GCN）多采用监督学习，而在许多实际场景下图数据往往没有标注信息。</li><li><strong>无监督学习的需求</strong>：现有方法常基于随机游走或邻近重构目标，但这类方法可能过分强调局部邻接信息，忽略了全局结构特征。</li><li><strong>核心思想</strong>：如何在不依赖标签的情况下，从图结构数据中学习到既保留局部细节又能反映全局结构的节点表示。</li></ul><hr><h3 id="2-方法概述：Deep-Graph-Infomax-DGI">2. 方法概述：Deep Graph Infomax (DGI)</h3><ul><li><strong>局部与全局互信息最大化</strong>：DGI 的主要思想是利用互信息最大化，通过对比图中局部（即节点及其邻域）表示与图整体全局摘要之间的关系，促使模型学习到富有全局结构信息的节点表示。</li><li>方法流程：<ol><li><strong>编码器（Encoder）</strong>：采用图卷积网络（GCN）或其它图神经网络模型，从输入的节点特征和邻接矩阵中提取局部“补丁”表示。</li><li><strong>读取函数（Readout Function）</strong>：将所有节点的局部表示聚合成一个全局摘要向量，反映整个图的全局信息。</li><li><strong>判别器（Discriminator）</strong>：通过一个二分类器对比真实的局部-全局配对与负样本配对（通过对输入数据进行随机扰动或负采样获得），采用二元交叉熵损失函数进行训练，进而最大化局部表示与全局摘要之间的互信息。</li></ol></li></ul><hr><h3 id="3-理论分析">3. 理论分析</h3><ul><li><strong>理论证明</strong>：论文提供了一系列引理和定理，证明了在局部与全局表示间最小化判别器的分类错误能够上界地最大化这两者之间的互信息。</li><li><strong>互信息与最优判别器</strong>：当读取函数具备单射性（injective）时，全局摘要能够捕获输入图的所有信息，进而使得模型在理论上达到最优互信息。</li></ul><hr><h3 id="4-实验与结果">4. 实验与结果</h3><ul><li>任务设置：<ul><li><strong>转导式任务</strong>：在 Cora、Citeseer 和 Pubmed 等引用网络上进行节点分类实验。</li><li><strong>归纳式任务</strong>：在 Reddit 社交网络和 PPI 蛋白质相互作用网络上进行归纳式节点分类实验。</li></ul></li><li>结果表现：<ul><li>在转导式任务上，DGI 的表现超越了许多无监督方法，并在某些数据集上甚至与监督学习的 GCN 模型竞争。</li><li>在归纳式任务中，DGI 同样展示了优越的性能，证明了其在大规模和多图场景下的适用性。</li></ul></li><li><strong>鲁棒性</strong>：DGI 对负样本生成（如特征打乱或邻接矩阵扰动）的策略具有较高的鲁棒性，能够在不同负采样方式下保持良好性能。</li></ul><hr><h3 id="5-定性分析与结论">5. 定性分析与结论</h3><ul><li><strong>可视化分析</strong>：通过 t-SNE 等技术对节点表示进行可视化，结果显示经过 DGI 学习的表示在低维空间中形成了明显的类别聚类结构。</li><li><strong>嵌入维度分析</strong>：研究发现，部分嵌入维度在区分正负样本时起到关键作用，而其余维度则主要编码了有用的节点特征信息；即便移除部分维度，分类性能仍能保持较高水平。</li><li><strong>总结</strong>：DGI 提出了一种全新的图无监督学习方法，通过局部与全局信息的对比，有效捕捉了图数据的结构特征，并在多个标准数据集上验证了其优异的性能，为无监督图表示学习提供了新的思路和方向。</li></ul><hr><p>整体而言，DGI 的创新点在于利用互信息最大化来桥接局部节点表示与全局图信息之间的联系，从而在无监督的情形下学习到高质量的节点表示，为后续的图任务（如节点分类、社区检测等）提供了坚实的基础。</p><h1>Semi-Supervised Classification with Graph Convolutional Networks</h1><h3 id="1-研究背景与动机-3">1. <strong>研究背景与动机</strong></h3><p>本文针对图结构数据中的节点分类问题，提出了一种半监督学习方法。传统方法往往依赖于显式的图拉普拉斯正则化，但这在实际应用中可能会受到图中边仅表示节点相似性的限制。作者希望利用图结构和节点特征的联合信息，通过神经网络直接对图进行建模，从而提高分类效果。</p><h3 id="2-方法原理与模型构建">2. <strong>方法原理与模型构建</strong></h3><ul><li><p><strong>谱图卷积近似</strong>：论文首先从谱图卷积出发，利用切比雪夫多项式对卷积操作进行近似，从而实现局部化滤波。通过限制多项式的阶数，最终得到一阶近似形式。</p></li><li><p><strong>层级传播规则</strong>：进一步简化后，提出了基于重新归一化技巧的传播规则，即</p><p>H(l+1) = σ( D̃^(–1/2) Ã D̃^(–1/2) H(l) W(l) )</p><p>其中 Ã = A + Iₙ，D̃ 是 Ã 的度矩阵，这样设计既考虑了节点自连接，又解决了深层网络中可能出现的数值不稳定问题。</p></li></ul><h3 id="3-半监督节点分类框架">3. <strong>半监督节点分类框架</strong></h3><ul><li><strong>网络架构</strong>：以两层GCN为例，第一层将输入特征与图结构信息融合后生成隐藏表示，第二层再通过 softmax 输出各节点的分类概率。</li><li><strong>损失函数</strong>：采用交叉熵损失，仅在少量标记节点上进行监督训练，从而利用整个图结构信息进行传播和特征提取。</li><li><strong>训练方式</strong>：由于数据集（如引用网络）的规模适中，可采用全批量梯度下降，并通过 dropout 等技术防止过拟合。</li></ul><h3 id="4-实验与结果-2">4. <strong>实验与结果</strong></h3><ul><li>在 Citeseer、Cora、Pubmed 以及知识图谱 NELL 数据集上进行实验，结果显示该模型在分类准确率和计算效率上均明显优于传统方法，如标签传播、深度嵌入、Planetoid 等。</li><li>另外，实验还分析了不同层数和传播模型对性能的影响，证明了重新归一化传播规则在性能和稳定性上的优势。</li></ul><h3 id="5-讨论与未来工作">5. <strong>讨论与未来工作</strong></h3><ul><li>讨论部分分析了GCN在捕捉局部结构信息方面的优势，并指出模型在处理大规模图数据时内存消耗较大，未来可以探索基于小批量随机梯度下降的扩展方法。</li><li>论文还探讨了与 Weisfeiler-Lehman 算法的关系，说明即使是未经过训练的GCN也能作为强大的特征提取器。</li></ul><h3 id="6-结论">6. <strong>结论</strong></h3><p>文章提出的GCN模型通过简化谱卷积操作，构建了高效且易扩展的半监督分类框架，成功地将图结构信息与节点特征结合起来，不仅提升了分类准确率，同时显著降低了计算复杂度，为后续图神经网络的发展奠定了基础。</p>]]></content>
      
      
      <categories>
          
          <category> 图神经网络研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatDev总结笔记</title>
      <link href="/2025/02/22/ChatDev%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/02/22/ChatDev%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>基于大模型智能体的虚拟化软件开发团队</h1><h2 id="项目介绍">项目介绍</h2><p>软件开发过程涉及到需求分析、总体设计、详细设计、编码和测试等多种活动和多种角色的开发者。随着大模型技术的快速发展，很多软件开发活动都可以通过自动化和智能化方式来实现。本项目利用<strong>大模型</strong>和<strong>多智能体</strong>技术来实现智能化软件开发全过程，通过agent模拟不同角色的软件开发人员，通过agent之间的协同完成复杂的软件开发过程。</p><h2 id="参考文献">参考文献</h2><p><a href="https://openreview.net/pdf?id=yW0AZ5wPji">https://openreview.net/pdf?id=yW0AZ5wPji</a></p><h1>ChatDev论文总结</h1><h2 id="What-is-ChatDev">What is ChatDev?</h2><p>ChatDev, a <em>chat</em>-powered software-<em>dev</em>elopment framework integrating multiple “software agents” for active involvement in three core phases of the software lifecycle: design, coding, and testing.</p><h2 id="Methodology">Methodology</h2><h3 id="1-chat-chain">1. chat chain</h3><p>ChatDev introduces <em>chat chain</em> to further break down each phase into smaller and manageable subtasks</p><ul><li>waterfall model -&gt; chat chain</li><li>chat chain -&gt; sequential phases</li><li>phase -&gt; sequential subtasks<ul><li>coding phase -&gt; code writing + completion</li><li>testing phase -&gt; code review (static testing) + system testing (dynamic testing)</li></ul></li><li>subtask -&gt; extraction of solutions -&gt; dialogue of Instructor &amp; Assistant</li><li>dialogue -&gt; loop -&gt; instructor instructing while assistant responding</li></ul><hr><ul><li><strong>Agentization</strong>: inception prompting mechanism</li><li><strong>Memory</strong>: <em>short-term memory</em> / <em>long-term memory</em></li></ul><h3 id="2-communicative-dehallucination">2. communicative dehallucination</h3><p>ChatDev devise <em>communicative dehallucination</em> to alleviate unexpected hallucinations, which <u>encourages the assistant to actively seek more detailed suggestions from the instructor before delivering a formal response.</u></p><h2 id="Evaluation">Evaluation</h2><ul><li>Baselines: GPT-Engineer(fundamental), MetaGPT(advanced)</li><li>Datasets: SRDD</li><li>Metrics: Completeness + Executability + Consistency = Quality</li></ul><p>The most important: multiple agents and roles</p><h2 id="Limitations-Solutions"><strong>Limitations</strong> &amp; Solutions</h2><ol><li>Firstly, the capabilities of autonomous agents in software production might be overestimated: <u>it is crucial to clearly define detailed software requirements.</u></li><li>Secondly, unlike traditional function level code generation, automating the evaluation of general-purpose software is highly complex: <u>consider additional factors such as functionalities, robustness, safety, and user-friendliness.</u></li><li>Thirdly, compared to single-agent approaches, multiple agents require more tokens and time, increasing computational demands and environmental impact: <u>enhance agent capabilities with fewer interactions</u></li></ol><h1>想法</h1><ul><li>针对论文提到的第二点不足，利用多模态大模型添加用户这一agent，提供对应用的界面、操作、使用等的反馈，作为增加的评判软件质量的标准并加以迭代</li></ul>]]></content>
      
      
      <categories>
          
          <category> 虚拟化软件开发团队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatDev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读-Memory Management Test-Case Generation of C Programs using Bounded Model Checking</title>
      <link href="/2025/01/19/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Memory-Management-Test-Case-Generation-of-C-Programs-using-Bounded-Model-Checking/"/>
      <url>/2025/01/19/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Memory-Management-Test-Case-Generation-of-C-Programs-using-Bounded-Model-Checking/</url>
      
        <content type="html"><![CDATA[<p>论文链接：<a href="https://link.springer.com/chapter/10.1007/978-3-319-22969-0_18">Memory Management Test-Case Generation of C Programs Using Bounded Model Checking | SpringerLink</a></p><h2 id="使用工具">使用工具</h2><ul><li>Efficient SMT-Based Bounded Model Checking（<strong>ESBMC</strong>，原文：<a href="https://ieeexplore.ieee.org/abstract/document/5928354">SMT-Based Bounded Model Checking for Embedded ANSI-C Software | IEEE Journals &amp; Magazine | IEEE Xplore</a>）：ESBMC以C语言源程序为输入，以一系列“Claim”为输出，这些Claim指明了该程序的安全属性，即可能出现内存错误的地方，包括检查与算术不足和溢出、零除法、越界索引、指针安全、死锁和数据竞争相关的属性。在ESBMC中，验证过程是完全自动化的，不需要用户使用前条件或后条件注释程序。</li><li><strong>Safety Properties</strong>：论文定义了“安全属性”的概念。如果一个系统不能满足一个安全属性，那么就存在一个有限的执行来显示这个失败，使用断言将对应的错误复现，就可以生成针对性的testcase。</li><li><strong>CUnit</strong>（<a href="https://cunit.sourceforge.net/doc/introduction.html#usage">CUnit - Introduction (sourceforge.net)</a>）：测试框架。CUnit支持更好的组织和代码重用，以更有效的方式创建单元测试。其支持完整的C语言书写，并提供了一组用于测试逻辑条件的断言。</li></ul><h2 id="方法过程">方法过程</h2><p><img src="../assets/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Memory-Management-Test-Case-Generation-of-C-Programs-using-Bounded-Model-Checking/image-20250121204757596.png" alt="image-20250121204757596"></p><ol><li>用ESBMC识别安全属性，得到Claims。</li><li>从安全属性中提取信息。即从四个方面分析Claim：identification、comments、line number、property。</li><li>翻译安全属性。即将Claims翻译成C程序中的断言代码。</li><li>内存跟踪分析。使用Pycparser（<a href="https://github.com/eliben/pycparser">eliben/pycparser: :snake: Complete C99 parser in pure Python (github.com)</a>）生成C语言的语法树AST，再根据AST进行分析，目的是确保指针安全性。分为两个阶段：<ol><li>识别和跟踪所分析的源代码中的变量，以及变量的操作和分配。对于非指针，直接进行变量映射；对于指针，执行对象映射，跟踪指针的运算、分配、回收。</li><li>对源代码的特定功能，用于根据程序执行监视内存地址和这些变量指向的地址。插入函数<code>mark_map_MF</code>，改函数以前阶段映射的数据为输入，维护一个包含内存地址、指向的地址、作用域范围、标识符、行数的列表，最后生成Map2Check提供的断言函数。</li></ol></li><li>根据ESBMC和Map2Check生成的断言生成testcase，包括原生C语言的断言和测试框架的断言函数。</li><li>测试实施，包括两个测试模型。</li><li>执行测试。</li></ol><h2 id="一些疑问">一些疑问</h2><ul><li>论文里变量的<code>dynamic</code>是什么意思？</li><li>两个测试模型没看懂🤯</li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++单元测试生成 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++单测生成调研</title>
      <link href="/2025/01/12/C-%E5%8D%95%E6%B5%8B%E7%94%9F%E6%88%90%E8%B0%83%E7%A0%94/"/>
      <url>/2025/01/12/C-%E5%8D%95%E6%B5%8B%E7%94%9F%E6%88%90%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1>C++单测生成调研</h1><p>调研C++单元测试生成在Undefined Behavior、内存、指针、Error Handling四个方面的特点、挑战及现状，据此考虑主要根据哪些特点来迁移已有模型。</p><h2 id="1-Undefined-Behavior">1. Undefined Behavior</h2><p>未定义行为（<strong>Undefined Behavior</strong>, UB）是编程语言规范中未对某些构造强制规定行为的部分。它为编译器优化提供了自由，但可能导致程序在不同平台上的行为不一致。<u>C/C++比Java具有更多UB</u>。</p><blockquote><p>A difficult trade-off in the design of a systems programming language is how much freedom to grant the compiler to generate efficient code for a target instruction set. On one hand, programmers prefer that a program behaves identically on all hardware platforms. On the other hand, programmers want to get high performance by allowing the compiler to exploit specific properties of the instruction set of their hardware platform. A technique that languages use to make this trade-off is labeling certain program constructs as <strong>undefined behavior</strong>, for which the language imposes no requirements on <u>compiler</u> writers.</p><p>From: [Kaashoek_Undefined behavior.pdf (<a href="http://mit.edu">mit.edu</a>)](<a href="https://dspace.mit.edu/bitstream/handle/1721.1/86949/Kaashoek_Undefined">https://dspace.mit.edu/bitstream/handle/1721.1/86949/Kaashoek_Undefined</a> behavior.pdf)</p></blockquote><p>Example:</p><ul><li>division by zero</li><li>oversized shift</li><li>signed integer overflow</li><li>out-of-bounds pointer</li><li>null pointer dereference</li><li>type-punned pointer dereference（类型转换指针解引用）</li><li>uninitialized read</li></ul><hr><p>未找到针对性的测试用例生成的论文。</p><h2 id="2-内存">2. 内存</h2><p><a href="https://arxiv.org/pdf/1710.06125">EffectiveSan: Type and Memory Error Detection using Dynamically Typed C/C++ (arxiv.org)</a></p><p>C/C++类型系统是静态且弱的，会出现<strong>类型错误</strong>（例如错误的类型转换）和<strong>内存错误</strong>（例如数组越界、使用释放后的内存等）。</p><p>提出了<strong>动态类型</strong> C/C++ 的概念。要点如下：</p><ol><li>每个分配的对象都会绑定<strong>动态类型信息</strong>（称为“有效类型”），用于描述其类型、边界和子对象布局。</li><li>在运行时检查指针使用是否合法，包括指针的类型正确性和边界正确性。</li><li>EffectiveSan 支持复杂对象的子对象布局：涵盖嵌套结构体、类的继承、联合等。</li></ol><hr><p><a href="https://d1wqtxts1xzle7.cloudfront.net/76763038/sefm2015-libre.pdf?1639840124=&amp;response-content-disposition=inline%3B+filename%3DMemory_Management_Test_Case_Generation_o.pdf&amp;Expires=1736853826&amp;Signature=VM6--U4EKTgiW1nLN-1mQXQkfkmonBSz5V5MVphAvpKUSmYedrxd6oAj54WBdfZdr~XLyU9oMYH6zq6MHsGnN1LpFcS7aiVs9RMDuC00b8UmBZJtydQXjWVUpW2pnJKtCtL5Fwj0TptHUrzgVudnBaUGAdPuEg7y1GAMPcR1q~OZy0mcSXYNSW2-S21MESUWGVWSmkohHiUEjYmrYYzxxUgNmR2FuzZIm9ktaiin~ZMqWX1R3ZyrhyOYivnoLmV542tU0odxKT3VyI5ITzZ9IJ-RqT8M1bvAtXuf6x2YMjP3CY~RBgJpmfqlwWGKRhje266VLoYnrpj3AXA4Vb10gQ__&amp;Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA">sefm2015-libre.pdf (d1wqtxts1xzle7.cloudfront.net)</a></p><p>名为Map2Check的工具。提供了一种改进的<strong>单元测试生成</strong>方法，结合<strong>ESBMC模型检查器</strong>和动态分析技术，显著提高了<strong>内存管理</strong>缺陷检测的精度。</p><ol><li>识别安全属性，利用ESBMC提取潜在的程序缺陷。</li><li>从安全属性中提取信息，如位置和潜在缺陷。</li><li>将安全属性翻译为C代码中的<strong>断言</strong>。</li><li>内存跟踪，记录程序执行期间内存地址的使用情况。</li><li>在源代码中添加<strong>断言</strong>以验证安全属性。</li><li>实现测试用例，通过CUnit或原生C断言执行测试。</li><li>执行测试并分析结果。</li></ol><h2 id="3-指针">3. 指针</h2><p><a href="https://www.sciencedirect.com/science/article/pii/S0950584922000027">An automated test data generation method for void pointers and function pointers in C/C++ libraries and embedded projects - ScienceDirect</a></p><p>介绍了一种名为VFP（Void and Function Pointers test data generation）的自动化测试数据生成方法，旨在提高C/C++库和嵌入式项目中void指针和函数指针的测试覆盖率。</p><ul><li><p><strong>背景</strong>：在C/C++项目中，指针的使用非常普遍，尤其是void指针和函数指针。这些指针在实际项目中频繁出现，但目前对于这类指针的测试数据生成研究较少。</p></li><li><p><strong>方法</strong>：VFP方法基于Concolic测试方法（结合了静态和动态测试的方法），通过预处理源代码来找出所有可能的void指针类型和函数指针的引用。VFP方法的关键在于分析源代码，找出void指针的所有可能类型和函数指针的引用，并利用这些信息生成初始测试数据。</p><ol><li><strong>参数预处理</strong>：分析被测单元内部和外部的源代码，找出所有可能的void指针类型和函数指针引用。</li><li><strong>随机测试数据生成</strong>：使用类型映射和引用映射，结合随机值生成，为其他数据类型生成初始测试数据。</li><li><strong>测试数据执行和测试路径分析</strong>：执行生成的测试数据，收集覆盖的测试路径，并尝试找出未覆盖的节点和最短未覆盖测试路径。</li><li><strong>定向测试数据生成</strong>：基于未覆盖的测试路径，生成路径约束，并转换为SMT-Lib表达式，由SMT求解器求解，生成新的测试数据。</li></ol></li></ul><h2 id="4-Error-Handling">4. Error Handling</h2><p>C语言的错误处理方式是通过函数返回值指示错误状态（通常还有宏定义的errno），通过条件语句处理错误。C++在保留C风格的错误处理方式时，新增了异常处理。</p><p><a href="https://dl.acm.org/doi/abs/10.1145/3106237.3106300">Automatically diagnosing and repairing error handling bugs in C | Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering (acm.org)</a></p><p>研究结果表明，错误处理漏洞通常由四个原因引起：错误/缺失的错误检查（EC）、错误/缺失的错误传播（EP）、错误/缺失的错误输出（EO）和错误/缺失的资源释放（RR）。作者利用这些发现设计并实现了一个名为ErrDoc的工具，该工具使用受限符号执行来探索所有可能的错误路径，并使用静态分析技术验证错误值是否被检查、向上游传播或记录。</p><ol><li><strong>探索错误路径</strong>：ErrDoc通过符号执行来识别所有可能的错误路径，并标记CFG中的相应节点和边。</li><li><strong>检测和分类错误处理漏洞</strong>：ErrDoc利用前一步收集的信息，输出有漏洞的程序位置和相应的漏洞类别。</li><li><strong>修复错误处理漏洞</strong>：ErrDoc自动修复四种类型的错误处理漏洞，通过修改AST来引入修复</li></ol><p>（自动修复=&gt;生成对应处的用例？）</p>]]></content>
      
      
      <categories>
          
          <category> C/C++单元测试生成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++单元测试生成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记</title>
      <link href="/2025/01/11/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/01/11/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>C++学习笔记</h1><h1>前言</h1><p>必修课系统教学的只有C语言和Java，而Python比较简单虽没有系统教学但也在许多课程中经常使用。本来培养方案上是有C++的选修课的，但是不知道为什么不开了，上学期的编译也有用C++编程的选择。笔者这个篇笔记只记录学习其与C/Java的不同点。</p><p>参考：[菜鸟教程](<a href="https://www.runoob.com/cplusplus/cpp-tutorial.html">C++ 教程 | 菜鸟教程 (runoob.com)</a>)</p><h1>1、简介</h1><p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p><p>C++ 被认为是一种<strong>中级</strong>语言，它综合了高级语言和低级语言的特点。</p><h2 id="1-1、特点">1.1、特点</h2><ul><li>C++有类似Java的面向对象的特点，即封装、继承、多态、抽象（在学Java的时候就已经知道，Java只能单继承而C++可以多继承）。</li><li>标准的 C++ 由三个重要部分组成：核心语言、C++标准库、标准模板库STL（这个在算法课上用过）</li></ul><h2 id="1-2、使用">1.2、使用</h2><p>C++的使用场景（后续若参加冯如杯，需要结合产业实际，如老师说的汽车C++软件）：</p><ul><li><p><strong>游戏开发</strong>：C++ 是游戏开发领域中最常用的编程语言之一，因为它具有高效的性能和直接控制硬件的能力。许多主要的游戏引擎，如 Unreal Engine 和 Unity，都使用 C++ 编写。</p><blockquote><p>我高中/大一的时候还很想从事游戏开发呢……</p></blockquote></li><li><p><strong>嵌入式系统开发</strong>：C++ 可以在嵌入式系统中发挥重要作用，如智能手机、汽车、机器人和家电等领域。由于嵌入式系统通常具有严格的资源限制和实时要求，因此 C++ 的高效性能和内存控制功能非常有用。</p></li><li><p>金融领域：C++ 在金融领域中被广泛应用，如高频交易、算法交易和风险管理等领域。由于这些应用程序需要高效的性能和对硬件的直接控制，C++ 语言是一个合适的选择。</p></li><li><p>图形图像处理：C++ 可以用于开发图形和图像处理应用程序，如计算机视觉、计算机图形学和人工智能领域。由于这些应用程序需要高效的计算能力和对硬件的控制，因此 C++ 是一个很好的选择。</p><blockquote><p>智能计算系统的C++算子？</p></blockquote></li><li><p>科学计算和数值分析：C++ 可以用于开发科学计算和数值分析应用程序，如数值模拟和高性能计算等领域。由于这些应用程序需要高效的计算能力和对硬件的直接控制，C++ 语言是一个很好的选择。</p></li></ul><h1>2、基本语法</h1><p>过程性语言部分，与C/Java类似。</p><h1>3、数据类型</h1><ul><li><p>基本类型：相较于C语言多了bool类</p></li><li><p>枚举类型：类似Java的枚举类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名&#123; </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[=整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure></li><li><p>类型转换：</p><ul><li><p><strong>静态转换（static_cast）</strong>：将一种数据类型的值强制转换为另一种数据类型的值。不进行任何运行时类型检查，因此可能会导致运行时错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i); <span class="comment">// 静态将int类型转换为float类型</span></span><br></pre></td></tr></table></figure></li><li><p><strong>动态转换（dynamic_cast）</strong>：通常用于将一个基类指针或引用转换为派生类指针或引用。运行时进行类型检查，如果不能进行转换则返回空指针或引发异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">Base* ptr_base = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* ptr_derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(ptr_base); <span class="comment">// 将基类指针转换为派生类指针</span></span><br></pre></td></tr></table></figure></li><li><p><strong>常量转换（const_cast）</strong>：用于将 const 类型的对象转换为非 const 类型的对象。只能用于转换掉 const 属性，不能改变对象的类型。</p></li><li><p><strong>重新解释转换（reinterpret_cast）</strong>：重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。不进行任何类型检查。</p></li></ul></li></ul><h1>4、修饰符类型</h1><p>类型限定符提供了变量的额外信息，用于在定义变量或函数时改变它们的默认行为的关键字。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">const</td><td style="text-align:left"><strong>const</strong> 定义常量，表示该变量的值不能被修改。</td></tr><tr><td style="text-align:left">volatile</td><td style="text-align:left">修饰符 <strong>volatile</strong> 告诉该变量的值可能会被程序以外的因素改变，如硬件或其他线程。。</td></tr><tr><td style="text-align:left">restrict</td><td style="text-align:left">由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td></tr><tr><td style="text-align:left">mutable</td><td style="text-align:left">mutable 用于修饰类的成员变量。被 mutable 修饰的成员变量可以被修改，即使它们所在的对象是 const 的。</td></tr><tr><td style="text-align:left">static</td><td style="text-align:left">用于定义静态变量，表示该变量的作用域仅限于当前文件或当前函数内，不会被其他文件或函数访问。</td></tr><tr><td style="text-align:left">register</td><td style="text-align:left">用于定义寄存器变量，表示该变量被频繁使用，可以存储在CPU的寄存器中，以提高程序的运行效率。</td></tr></tbody></table><ul><li><p>mutable实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_; <span class="comment">// const 关键字表示该成员函数不会修改对象中的数据成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(<span class="type">int</span> value)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        value_ = value; <span class="comment">// mutable 关键字允许在 const 成员函数中修改成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1>5、存储类</h1><p>存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。包括auto、register（弃用）、static、extern、mutable、thread_local。</p><p><strong>auto</strong> 关键字用于两种情况：<u>声明变量时根据初始化表达式自动推断该变量的类型</u>、声明函数时函数返回值的占位符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=<span class="number">3.14</span>;      <span class="comment">//double</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;  <span class="comment">//const char*</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="built_in">auto</span>(<span class="number">9</span>); <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">5</span>, x2 = <span class="number">5.0</span>, x3=<span class="string">&#x27;r&#x27;</span>;<span class="comment">//错误，必须是初始化为同一类型</span></span><br></pre></td></tr></table></figure><h1>6、函数</h1><h2 id="6-1、参数默认值">6.1、参数默认值</h2><p>与C/Java不同而与Python类似：定义一个函数时，可以为参数列表中后边的每一个参数指定默认值；当调用函数时，如果实际参数的值留空，则使用这个默认值。</p><h2 id="6-2、Lambda函数-表达式">6.2、Lambda函数/表达式</h2><p>表达式及例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)-&gt;<span class="keyword">return</span>-type&#123;body&#125;<span class="comment">// 有返回值</span></span><br><span class="line">[capture](parameters)&#123;body&#125;<span class="comment">// 无返回值</span></span><br><span class="line"></span><br><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y)&#123; <span class="keyword">return</span> x &lt; y ; &#125;</span><br><span class="line">[]&#123; ++global_x; &#125; </span><br><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123; <span class="type">int</span> z = x + y; <span class="keyword">return</span> z + x; &#125;</span><br></pre></td></tr></table></figure><p><code>[]</code>指定了该表达式可以访问的当前作用域的变量（包括引用和传值传递两种形式）。</p><h1>7、字符串</h1><p>C++ 提供了以下两种类型的字符串表示形式：</p><ul><li>C 风格字符串（与C语言用法一致）</li><li>C++ 引入的 string 类类型（相当于Java中一个String类的对象）</li></ul><h1>8、引用</h1><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p><h2 id="8-1、引用-VS-指针">8.1、引用 VS 指针</h2><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><h2 id="8-2、创建引用">8.2、创建引用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i = 17;</span><br></pre></td></tr></table></figure><p>为 i 声明引用变量如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int&amp;  r = i;</span><br><span class="line">double&amp; s = d;</span><br></pre></td></tr></table></figure><p>在这些声明中，&amp; 读作<strong>引用</strong>。</p><blockquote><p>至于C++的输入输出、vector、数据结构等在算法课已经熟悉，就不记了。</p></blockquote><h1>9、类&amp;对象</h1><p>与C/Java区别最大的特点之一。</p><ul><li>定义方法：</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/05/cpp-classes-objects-2020-12-10-11.png" alt="img"></p><ul><li><p>类成员函数定义：可在类中定义，也可在类的外部使用<strong>范围解析运算符 ::</strong> 定义。</p></li><li><p>类访问修饰符：由于不分包，没有Java的默认（包访问权限），默认情况下是定义为 private。</p></li><li><p>构造函数：与Java类似，函数名为类名且无返回值类型，但可以使用初始化列表来初始化字段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C::<span class="built_in">C</span>( <span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c): <span class="built_in">X</span>(a), <span class="built_in">Y</span>(b), <span class="built_in">Z</span>(c) <span class="comment">// 对成员X, Y, Z分别赋值a, b, c</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类的<strong>析构函数</strong>：是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p></li><li><p><strong>拷贝构造函数</strong>：是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数（实现深拷贝）。形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">classname</span> (<span class="type">const</span> classname &amp;obj) &#123;</span><br><span class="line">   <span class="comment">// 拷贝构造函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类的<strong>友元函数/友元类</strong>：定义在类<strong>外部</strong>，但有权访问类的所有私有（private）成员和保护（protected）成员。</p></li><li><p>其他与C/Java类似的：内联函数、this指针、静态成员变量及函数</p></li></ul><h1>10、继承</h1><ul><li><p>与Java不同，C++中一个类可以派生自多个类，可以从多个基类继承数据和函数。多继承使用逗号隔开。</p></li><li><p>定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>-<span class="keyword">class</span>: access-specifier base-<span class="keyword">class</span></span><br></pre></td></tr></table></figure><p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p><ul><li><strong>公有继承（public）：<strong>当一个类派生自</strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li><li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li><li><strong>私有继承（private）：<strong>当一个类派生自</strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li></ul><blockquote><p>与Java不同，Java子类不能缩小父类成员的可见性。</p></blockquote></li></ul><h2 id="11、重载运算符和重载函数">11、重载运算符和重载函数</h2><p>函数重载与Java类似，这里着重记录运算符重载。</p><p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box operator+(const Box&amp;);</span><br></pre></td></tr></table></figure><p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box operator+(const Box&amp;, const Box&amp;);</span><br></pre></td></tr></table></figure><h1>12、多态</h1><p>与Java的多态类似。</p><ul><li>虚函数：使用关键字<code>virtual</code>，子类重写要加<code>override</code>。（可以在基类中提供默认实现）</li><li>纯虚函数（Pure Virtual Functions）：<ul><li>一个包含纯虚函数的类被称为<strong>抽象类</strong>（Abstract Class），它不能被直接实例化。（与Java中的抽象类类似，是C++中的接口）</li><li>纯虚函数没有函数体，声明时使用<code>= 0</code>。（与Java的抽象方法类似）</li></ul></li></ul><h1>13、其他特性</h1><ul><li><p>动态内存：使用new分配堆空间（与Java类似），<u>使用delete释放内存（Java自动垃圾回收机制）</u></p><blockquote><p><strong>对于分配对象空间，C++支持栈分配内存和堆分配内存（需要显示释放），而Java是完全基于堆的。</strong></p></blockquote></li><li><p>命名空间：作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。可以嵌套。使用**范围解析运算符 ::**调用带有命名空间的函数或变量。</p></li><li><p>模板：类似Java的泛型。</p><ul><li><p>函数模板：（与Java泛型不同，使用时不指定的类型，直接使用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt; ret-type func-<span class="built_in">name</span>(parameter list)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类模板：（需要指定类型）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt; <span class="keyword">class</span> <span class="title class_">class</span>-name &#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p>导入标准库、预处理器：与C语言相同。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++单元测试生成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译技术实验总结感想</title>
      <link href="/2025/01/10/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93%E6%84%9F%E6%83%B3/"/>
      <url>/2025/01/10/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1>《编译技术》实验总结感想</h1><h2 id="1-实验总结">1. 实验总结</h2><p>这个学期的编译实验一共分为文法解读、词法分析、语法分析、语义分析、代码生成、代码优化几个部分。总体来说，难度依次递增。</p><p>我选择的编程语言是Java，这也是我最喜欢的一种语言。在实验开始前，我还在庆幸不用像上学期的OS一样整天跟C语言打交道，又能愉快地编写最喜欢的Java了。</p><p>在最初的词法分析和语法分析中，我还体验着迭代开发Java、欣赏自己的设计模式的乐趣中。虽然语法分析的工作量相比于词法分析陡增，但是我个人觉得我的类设计还是比较清晰的，因此写完之后也算是非常有成就感了。</p><p>之后的语义分析其实就是建立符号表并处理语义错误，因此比较简单。但完成这里的时候，我深感对于类设计等的欠缺，几乎把面向对象的语言写成了面向过程的语言。而后面的中端代码生成是在语义分析的基础上做的，因此我总体的设计在此后也变得不忍直视。</p><p>代码生成我选择的是LLVM IR+MIPS。此时能给予我帮助的只有指导书了，然而我觉得指导书并不全面，只提供了最基本的介绍，具体实现大部分都是我自己摸索出来的。比如在LLVM IR生成中，指导书并没有说符号表到底存什么东西，我最后想的是存地址对应的虚拟寄存器，如果存值的话，还需要考虑分支合并时的phi指令等，如果指导书直接说明phi指令建议在后面优化时实现，可能我会花更少的时间了。</p><p>在MIPS的生成时，也有类似情况。我一开始理解错了LLVM IR中”虚拟寄存器“的概念，以为虚拟寄存器就必须得分配一个物理寄存器，所以我直接将后面优化部分的寄存器分配在生成MIPS时就写了，这耗费了我大量的时间。而后来我几乎快完成的时候经同学的提醒，才意识到虚拟寄存器也就是一个变量而已了，完全可以全部放在栈上。</p><p>在代码生成的那段时间，特别是MIPS生成，是整个过程最难、耗费时间最长的、最觉得无助的。中间代码和目标代码生成都花费了我快2周时间。一开始我以为MIPS生成就是简单的逐条指令翻译，但是我直接将寄存器分配纳入，使得整个过程非常坎坷，各种bug、各种问题……那时真的是最想放弃的一瞬。</p><p>好在直接实现了寄存器分配，使我竞速排序的排名不算太靠后。同时由于耗费了太多时间，我也无力做工作量巨大的复杂优化了（比如LLVM IR mem2reg）。但是我本身也无意去卷竞速排名，我感觉我能做出MIPS并在排名里有一席之地就足够了。最后的最后，我尽我所能地实现了一些比较简单的优化，也算是给整个编译实验画上了一个圆满的句号吧。</p><h2 id="2-感想">2. 感想</h2><p>完成整个编译实验是我个人第一次独立完成工作量和复杂度这么庞大的项目了，最后看了一下总共有9216行代码。但肯定不是代码行数越多就越好，我在中后期里类和方法设计方面比较欠缺，代码的质量也不算太高。虽然每次作业都是”万事开头难“，但是每次点击IDEA的”新建类“按钮都满怀着期待，期待着这个类的设计能够足够完美，而足够完美的设计在方便使用的同时真的能给人自豪感；虽然每次编码、debug过程都非常艰辛，但是每次看到AC通过的赏心悦目的绿色时，会感觉一切都值了。</p><h2 id="3-一点建议">3. 一点建议</h2><p>希望指导书可以给一些总体的编码实现思路（但是太具体也不行，否则大家都写成一样的了），毕竟从无到有的开发如果没有参考还是很有难度的，而且容易走弯路。</p>]]></content>
      
      
      <categories>
          
          <category> 编译技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译技术开发文档</title>
      <link href="/2025/01/10/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/"/>
      <url>/2025/01/10/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>《编译技术》实验开发文档</p><p>Author：bush</p></blockquote><h1>1 参考编译器介绍</h1><p>主要参考了教材上PL/0以及tolang</p><h2 id="1-1-总体结构">1.1 总体结构</h2><p>PL/0是一个编译-解释执行程序，总体结构分为两个部分：</p><ol><li>先把PL/0编译成目标程序（P-code指令）</li><li>再对目标程序进行解释执行，得到运行结果</li></ol><h2 id="1-2-接口设计">1.2 接口设计</h2><p>PL/0编译程序采用一遍扫描，以语法分析为核心，由它调用词法分析程序取单词，在语法分析过程中同时进行语义分析处理，并生成目标指令。</p><p>如遇有语法、语义错误，则随时调用出错处理程序，打印出错信息。</p><h2 id="1-3-文件组织">1.3 文件组织</h2><p>前端和后端分包等。</p><h1>2 编译器总体设计</h1><h2 id="2-1-总体结构">2.1 总体结构</h2><p>总体结构与PL/0不同，是编译程序。</p><ol><li>先编译成LLVM IR</li><li>由LLVM IR生成MIPS汇编代码</li><li>直接运行MIPS汇编代码</li></ol><hr><p>编译器总体采用多遍扫描，即先通过一次完整的词法分析得到token序列，再进行语法分析得到语法树。</p><h2 id="2-2-接口设计">2.2 接口设计</h2><h3 id="2-2-1-词法分析器Lexer">2.2.1 词法分析器Lexer</h3><p><code>Lexer.java</code>主要提供一个接口<code>getToken()</code></p><ul><li><strong>调用形式</strong>：<code>token = lexer.getToken()</code></li><li><strong>作用</strong>：根据设置的读取器<code>BufferedReader</code>，每次调用返回下一个解析到的<code>Token</code>类符号</li><li><strong>备注</strong>：当且仅当读到文件流末尾时返回<code>null</code></li></ul><h3 id="2-2-2-语法分析器Parser">2.2.2 语法分析器Parser</h3><p><code>Parser.java</code>主要提供一个接口<code>parse()</code></p><ul><li><strong>调用形式</strong>：<code>compUnit = parser.parse()</code></li><li><strong>作用</strong>：首先调用词法分析器的接口解析得到token序列，然后递归解析以一个<code>CompUnit</code>类实例表示的语法树</li></ul><h2 id="2-3-文件组织">2.3 文件组织</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 主要文件结构如下</span><br><span class="line">├─error</span><br><span class="line">│  └─CompilerError.java</span><br><span class="line">├─frontend</span><br><span class="line">│  ├─lexer</span><br><span class="line">│  │   └─Lexer.java</span><br><span class="line">│  └─parser</span><br><span class="line">│      ├─declaration</span><br><span class="line">│      ├─expression</span><br><span class="line">│      ├─function</span><br><span class="line">│      ├─statement</span><br><span class="line">│      └─terminal</span><br><span class="line">│      └─Parser.java</span><br><span class="line">├─Compiler.java</span><br><span class="line">├─config.json</span><br><span class="line">└─README.md</span><br></pre></td></tr></table></figure><h1>3 词法分析设计</h1><h2 id="3-1-编码前的设计">3.1 编码前的设计</h2><p>主要参考的是教材上的PL/0，以及第三章的词法分析示例。</p><p><img src="../assets/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20241014104848084.png" alt="image-20241014104848084"></p><p>代码大致流程图如上，编码时，主要依靠这张图，其他细节在编码时实现。</p><p><code>Compiler.java</code>这一主程序调用<code>frontedn/Lexer.java</code>中的<code>getSymbol</code>方法。在此次作业中主逻辑还未实现，因此可以在<code>Compiler.java</code>中暂时编写满足本次作业的测试逻辑。</p><h2 id="3-2-编码完成后的修改">3.2 编码完成后的修改</h2><h3 id="3-2-1-设计模式的选择、类的设计">3.2.1 设计模式的选择、类的设计</h3><ul><li>词法分析器<code>Lexer.java</code>采用单例模式（饿汉式）的设计模式，作为一个静态类存放到主类<code>Compiler.java</code>中，其方法也多是静态方法，最主要的是<code>getToken</code>方法；<br><img src="../assets/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20241014104957471.png" alt="image-20241014104957471"></li><li>单词token作为一个类<code>Token</code>，类型作为其内部枚举类<code>TokenType</code>；</li><li>编译错误的处理：<code>CompilerError</code>是一个<code>Exception</code>的子类，在<code>Lexer</code>等各个组件的方法可以被抛出，在主类<code>Compiler</code>中被<code>try-catch</code>处理。</li></ul><h3 id="3-2-2-其他更改或BUG">3.2.2 其他更改或BUG</h3><ol><li>最大的疏忽是忘记添加处理注释的代码了，应该把读入<code>/</code>符号后的逻辑单列出来。</li><li>另外，只考虑到字符常量中只有一个字符的情况了，没有考虑到转义字符</li></ol><h3 id="3-2-3-语法分析完成后的改动">3.2.3 语法分析完成后的改动</h3><ul><li>最大的改动是，由设计之初的一遍扫描改为多遍扫描<ul><li>在词法分析时，设计采用一遍扫描，即语法分析中每次调用词法分析的接口<code>getToken()</code>即返回下一个token。<br>在词法分析程序内部中使用<code>BufferedReader</code>的<code>mark()</code>和<code>reset()</code>两个方法组实现字符读取的回退，在语法分析开始时计划在调用<code>getToken()</code>接口的外层也使用这两个方法实现token的回退和预读。</li><li>但是这样会使得在接口内部再次调用<code>mark()</code>覆盖外层的<code>mark()</code>使得无法回退token等问题，因此改为多遍扫描，即在语法分析前先完成整个程序的词法分析得到token序列，接下来的语法分析便不用通过操作读取器回退token，功能完成解耦。</li></ul></li><li>修改了词法分析解析多行注释的部分：在de完语法分析的bug后，公共测试库全过但测试点16RE，最后发现是词法分析中对多行注释的读取有误</li></ul><h1>4 语法分析设计</h1><h2 id="4-1-编码前的设计">4.1 编码前的设计</h2><ul><li>与词法分析类似，使用单例模式实现<code>Parser.java</code></li><li>主要采用递归下降程序实现</li><li>此外通过预读解决多个规则匹配问题</li></ul><p>以下是编写递归程序时的辅助表格，部分非终结符的FIRST略</p><table><thead><tr><th>非终结符</th><th>FIRST集</th><th>完成</th></tr></thead><tbody><tr><td>CompUnit</td><td>CONSTTK, INTTK, CHARTK, VOIDTK</td><td>V</td></tr><tr><td>Decl</td><td>CONSTTK, INTTK, CHARTK</td><td>V</td></tr><tr><td>FuncDef</td><td>VOIDTK, INTTK, CHARTK</td><td>V</td></tr><tr><td>MainFuncDef</td><td>INTTK</td><td>V</td></tr><tr><td>ConstDecl</td><td>CONSTTK</td><td>V</td></tr><tr><td>VarDecl</td><td>INT, CHAR</td><td>V</td></tr><tr><td>FuncType</td><td>'VOIDTK, INTTK, CHARTK</td><td>V</td></tr><tr><td>BType</td><td>INTTK, CHARTK</td><td>V</td></tr><tr><td>ConstDef</td><td></td><td>V</td></tr><tr><td>Ident</td><td>Vt</td><td>V</td></tr><tr><td>ConstInitVal</td><td></td><td>V</td></tr><tr><td>ConstExp</td><td></td><td>V</td></tr><tr><td>StringConst</td><td>Vt</td><td>V</td></tr><tr><td>AddExp</td><td></td><td>V</td></tr><tr><td>MulExp</td><td></td><td>V</td></tr><tr><td>UnaryExp</td><td>LPARENT, IDENFR, INTCON, CHRCON, PLUS, MINU, NOT</td><td>V</td></tr><tr><td>PrimaryExp</td><td>LPARENT, IDENFR, INTCON, CHRCON</td><td>V</td></tr><tr><td>FuncRParams</td><td></td><td>V</td></tr><tr><td>UnaryOp</td><td>PLUS, MINU, NOT</td><td>V</td></tr><tr><td>LVal</td><td>IDENFR</td><td>V</td></tr><tr><td>Number</td><td>INTCON</td><td>V</td></tr><tr><td>Character</td><td>CHRCON</td><td>V</td></tr><tr><td>IntConst</td><td>Vt</td><td>V</td></tr><tr><td>CharConst</td><td>Vt</td><td>V</td></tr><tr><td>VarDef</td><td></td><td>V</td></tr><tr><td>InitVal</td><td></td><td>V</td></tr><tr><td>Exp</td><td>LPARENT, IDENFR, INTCON, CHRCON, PLUS, MINU, NOT</td><td>V</td></tr><tr><td>FuncFParams</td><td>INTTK, CHARTK</td><td>V</td></tr><tr><td>FuncFParam</td><td>INTTK, CHARTK</td><td>V</td></tr><tr><td>Block</td><td>LPARENT</td><td>V</td></tr><tr><td>BlockItem</td><td></td><td>V</td></tr><tr><td>Stmt</td><td></td><td>V</td></tr><tr><td>ForStmt</td><td></td><td>V</td></tr><tr><td>Cond</td><td></td><td>V</td></tr><tr><td>LOrExp</td><td></td><td>V</td></tr><tr><td>LAndExp</td><td></td><td>V</td></tr><tr><td>EqExp</td><td></td><td>V</td></tr><tr><td>RelExp</td><td></td><td>V</td></tr></tbody></table><h2 id="4-2-编码后的设计">4.2 编码后的设计</h2><h3 id="4-2-1-设计模式">4.2.1 设计模式</h3><ul><li>语法分析器<code>Parser.java</code>与词法分析器类似，采用饿汉式单例模式；</li><li>单例模式的静态方法与非静态方法的实现效果类似，但为了简便，在语法成分类中要频繁调用的<code>getSymbol() currentSymbol()</code>等方法设置为静态方法。</li></ul><h3 id="4-2-2-递归下降读取逻辑">4.2.2 递归下降读取逻辑</h3><ul><li>在一个程序要调用一个分析子程序前，需要使用<code>Parser.getSymbol()</code>读取一个token</li><li>在分析子程序里，分析子程序会递归匹配所有token，但并不会超前读取（例如分析子程序只匹配一个终结符即结束，则不会调用<code>Parser.getSymbol()</code>），因此一个子成分分析完后，<code>symbol</code>停留在最后匹配到的那个token处</li><li>接着继续使用<code>Parser.getSymbol()</code>读取一个token并调用剩下的分析子程序</li><li>在遇到终结符时，匹配后不需要使用<code>Parser.getSymbol()</code>，因为递归过程相当于在匹配之前已经执行一次</li></ul><h3 id="4-2-3-类设计">4.2.3 类设计</h3><ul><li><p>对于语法树的构建，首先设计了一个语法树节点的接口<code>SyntaxNode.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SyntaxNode</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">parse</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">outputString</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于每个语法成分，均设计同名的一个类并实现以上接口；</p><ul><li>对于该语法成分的一条规则，规则右部语法成分作为该类的一个属性存储<ul><li>若有多条规则，则根据FIRST集的不同划分成不同的子类，超类属性类型为超类，但在<code>parse()</code>方法中根据当前符号选择实例化不同的子类（方法重写和多态）</li><li>若右部语法成分可重复多次，则存储对应的列表</li><li>若右部语法成分可选，则值非<code>null</code>时表示存在，否则不存在</li></ul></li><li>类的<code>parse()</code>方法会根据语法分析器当前解析到的符号<code>Parser.currentSymbol()</code>向前解析，并返回自身（<code>return this</code>）</li><li>顶层语法成分调用<code>parse()</code>方法解析时，为下层语法成分属性赋值一个调用过自身<code>parse()</code>方法的<code>new</code>对象，这样就实现了递归</li><li>每个语法成分的<code>outputString()</code>方法按照同样的递归逻辑返回需要输出的内容和格式</li></ul></li><li><p>为了使得结构清晰，按功能将语法成分包为<code>declaration</code>, <code>expression</code>, <code>function</code>, <code>statement</code>, <code>terminal</code>五个包</p></li><li><p>对于有多条规则的语法成分的子类也分包管理，如<code>stmts</code>, <code>unaryexps</code>, <code>primaryexps</code></p></li></ul><h3 id="4-2-4-FIRST集冲突解决方案">4.2.4 FIRST集冲突解决方案</h3><ul><li>若FIRST集冲突，可以类似的查看规则的SECOND集，并使用<code>preReadNext()</code>预读一个token的方法区分（大部分可以解决）</li><li>仅在<code>CompUnit-&gt;Decl|FuncDef</code>，SECOND集仍冲突，则<code>preReadNextNext()</code>预读下下个token可以区分</li><li>仅在<code>Stmt</code>的推导时，使用SECOND集仍然难以区分，此处采用回溯token的方法解决<ul><li>在回溯时需要同时回溯抛出的错误！不然会出现多输出错误的情况</li></ul></li></ul><h3 id="4-2-5-左递归文法解决方案">4.2.5 左递归文法解决方案</h3><ul><li><p>对于左递归文法，将规则改写为扩充的BNF范式。<br>以<code>MulExp → UnaryExp | MulExp ('*' | '/' | '%') UnaryExp</code>这条规则为例，消除左递归后得到<br><code>MulExp → UnaryExp &#123; ('*' | '/' | '%') UnaryExp &#125;</code></p></li><li><p>以这条规则为例，这些具有递归文法的类属性设置为一个<code>UnaryExp</code>类和一个元素为<code>OpUnaryExp</code>类的列表分别表示EBNF范式的两部分</p></li><li><p>其中<code>OpUnaryExp</code>为静态内部类，相当于一个二元组，包含每个重复的符号<code>op</code>和<code>unaryExp</code></p></li><li><p>至此便消除左递归文法，在分析方法中不会递归调用自己，而是不断调用下一层的语法成分分析方法；并且在输出方法<code>outputString()</code>中，也可以通过类似逻辑输出正确的语法树结构</p></li><li><p>从<code>UnaryExp-&gt;MulExp-&gt;AddExp-&gt;RelExp-&gt;EqExp-&gt;LAndExp-&gt;LorExp</code>各层次间关系是一模一样的，因此编写完<code>UnaryExp-&gt;MulExp</code>后，可通过代码查找替换迁移得到后面的层间关系；手稿如下：</p><p><img src="../assets/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/07fae8c98c7d24c7990122f1fc798d0.jpg" alt="07fae8c98c7d24c7990122f1fc798d0"></p></li></ul><h3 id="4-2-6-关于错误处理的修改">4.2.6 关于错误处理的修改</h3><ul><li><p>在之前的词法分析设计时，设计了一个自定义的<code>CompileError</code>并继承<code>Exception</code>类，错误通过throw抛出自<code>CompileError</code>报错并在上层处理，但在此次编码时发现：</p><ul><li>语法分析与词法分析不同，词法分析是顺序执行，可以使用throw抛出异常，在顶层记录错误并继续执行</li><li>而语法分析是递归调用的，不能够被中断，因此把错误暂存而不是抛出</li></ul></li><li><p>并且由一遍扫描改为多遍扫描也不能顺序地依次处理错误。因此，修改处理逻辑，将所有错误先暂存并直接处理，最后一起输出。</p></li><li><p>需要注意的是一遍扫描错误抛出的顺序是按行数升序的，但多遍扫描的顺序一次是词法分析错误、语法分析错误、语义分析错误等，需要在输出前按行数排序再输出</p></li></ul><h1>5 语义分析设计</h1><h2 id="5-1-编码前的设计">5.1 编码前的设计</h2><p>在这一阶段，不需要进行中间代码生成，只需要输出符号表内容。且指导书在中间代码生成这一章写道：</p><blockquote><p>对于符号表的生命周期，可以是遍历 AST 后，生成一张<strong>完整的符号表</strong>，然后再进行代码生成；也可以是在遍历过程中创建<strong>栈式符号表</strong>，随着遍历过程创建和销毁，同时进行代码生成。</p></blockquote><p>因此，暂时设计为先遍历AST生成树形符号表，再在后面的中间代码生成时做增量式开发。</p><hr><p>采用访问者模式：</p><ul><li>设计一个单例<code>Visitor</code>类，其包含不同语法成分的<code>visit()</code>方法，解析语法树并调用下层的<code>visit()</code>方法。</li><li>仅<code>visit(CompUnit compUnit)</code>方法为<code>public</code>以便外层调用，其余语法成分的<code>visit()</code>方法设置为<code>private</code>被其调用。</li></ul><h2 id="5-2-编码后的设计">5.2 编码后的设计</h2><h3 id="5-2-1-符号和符号表的类设计">5.2.1 符号和符号表的类设计</h3><ul><li><p>符号类<code>Symbol</code>设置为抽象类：<code>ConstInt, ConstChar, ConstIntArray, ConstCharArray, ConstInt, ConstChar, ConstIntArray, ConstCharArray</code>这8种符号每种各设置一个子类<code>xxxSymbol</code>继承<code>Symbol</code>；<code>IntFunc, CharFunc, VoidFunc</code>这3种符号设计一个子类<code>FuncSymbol</code>；共9个继承。</p></li><li><p>符号表需要维持树状结构，因此添加<code>fatherTable</code>这一属性。构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SymbolTable</span><span class="params">(SymbolTable fatherTable)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.fatherTable = fatherTable;</span><br><span class="line">    <span class="built_in">this</span>.scopeId = scopeIdCounter++;</span><br><span class="line">    fatherTable.childrenTables.add(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">SymbolTable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.fatherTable = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.scopeId = scopeIdCounter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中根符号表作为静态属性存储以便输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SymbolTable</span> <span class="variable">ROOT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SymbolTable</span>(); <span class="comment">// 根符号表，即全局符号表</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-2-2-访问者设计">5.2.2 访问者设计</h3><ul><li>访问者总体结构与 #5.1 编码前的设计相同；</li><li>在访问者中维护一个<code>curSymbolTab</code>属性保存当前的符号表；</li><li>另有其他属性用来辅助语义分析（直接作为Visitor属性就不用在方法中传递参数了）。</li></ul><h3 id="5-2-3-语义分析后的改动">5.2.3 语义分析后的改动</h3><ul><li>解耦词法分析器和语法分析器，优化了对外接口</li><li>为语法成分属性添加Getter</li><li>UnaryExp → UnaryOp UnaryExp这条规则不应拆分子类而应把UnaryOp作为UnaryExp的属性</li><li>重构多条规则语法成分：将Stmt、BlockItem、PrimaryExp中的自反属性删去；将UnaryExp中的属性更名为UnaryExpWithoutOp。这样避免了在语义分析时，使用<code>unaryExp.getUnaryExp(), primaryExp.getPrimaryExp(), stmt.getStmt() instanceof ReturnStmt</code>等等冗余且易出错的调用。</li></ul><h3 id="5-2-4-完成后的思考">5.2.4 完成后的思考</h3><p>相比于语法分析，这次的主要代码均在一个文件下（<code>Visitor.java</code>），耦合度高、模块化差、难以阅读和调试。但由于这次只是部分的语义分析，不涉及中间代码生成，因此期待在后面的迭代中优化结构、解耦合。</p><h1>6 代码生成设计</h1><h2 id="6-1-编码前的设计">6.1 编码前的设计</h2><h3 id="6-1-1-中间代码生成设计">6.1.1 中间代码生成设计</h3><p>按照教程的构建单元设置相关类：</p><img src="https://judge.buaa.edu.cn/cguserImages?_img=30639449344bc202b2e4ac7ba5b5ab1a.png" alt="图片#50% #center" style="zoom: 50%;" /><p>类里均存放初始化的值，仅仅用于转成LLVM IR文本。实际要输出常量的值应差符号表。</p><p>指令：</p><table><thead><tr><th>LLVM IR</th><th>使用方法</th><th>简介</th></tr></thead><tbody><tr><td><code>add</code></td><td><code>&lt;result&gt; = add &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>/</td></tr><tr><td><code>sub</code></td><td><code>&lt;result&gt; = sub &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>/</td></tr><tr><td><code>mul</code></td><td><code>&lt;result&gt; = mul &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>/</td></tr><tr><td><code>sdiv</code></td><td><code>&lt;result&gt; = sdiv &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>有符号除法</td></tr><tr><td><code>srem</code></td><td><code>&lt;result&gt; = srem &lt;baseType&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>有符号取余</td></tr><tr><td><code>icmp</code></td><td><code>&lt;result&gt; = icmp &lt;cond&gt; &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>比较指令</td></tr><tr><td><code>and</code></td><td><code>&lt;result&gt; = and &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>按位与</td></tr><tr><td><code>or</code></td><td><code>&lt;result&gt; = or &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>按位或</td></tr><tr><td><code>call</code></td><td><code>&lt;result&gt; = call [ret attrs] &lt;ty&gt; &lt;name&gt;(&lt;...args&gt;)</code></td><td>函数调用</td></tr><tr><td><code>alloca</code></td><td><code>&lt;result&gt; = alloca &lt;baseType&gt;</code></td><td>分配内存</td></tr><tr><td><code>load</code></td><td><code>&lt;result&gt; = load &lt;ty&gt;, ptr &lt;pointer&gt;</code></td><td>读取内存</td></tr><tr><td><code>store</code></td><td><code>store &lt;ty&gt; &lt;initValue&gt;, ptr &lt;pointer&gt;</code></td><td>写内存</td></tr><tr><td><code>getelementptr</code></td><td><code>&lt;result&gt; = getelementptr &lt;ty&gt;, ptr &lt;ptrval&gt;&#123;, &lt;ty&gt; &lt;idx&gt;&#125;*</code></td><td>计算目标元素的位置（数组部分会单独详细说明）</td></tr><tr><td><code>phi</code></td><td><code>&lt;result&gt; = phi [fast-math-flags] &lt;ty&gt; [&lt;val0&gt;, &lt;label0&gt;], ...</code></td><td>/</td></tr><tr><td><code>zext..to</code></td><td><code>&lt;result&gt; = zext &lt;ty&gt; &lt;initValue&gt; to &lt;ty2&gt;</code></td><td>将 <code>ty</code> 的 <code>initValue</code> 的 baseType 扩充为 <code>ty2</code>（zero extend）</td></tr><tr><td><code>trunc..to</code></td><td><code>&lt;result&gt; = trunc &lt;ty&gt; &lt;initValue&gt; to &lt;ty2&gt;</code></td><td>将 <code>ty</code> 的 <code>initValue</code> 的 baseType 缩减为 <code>ty2</code>（truncate）</td></tr><tr><td><code>br</code></td><td><code>br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt;</code> <code>br label &lt;dest&gt;</code></td><td>改变控制流</td></tr><tr><td><code>ret</code></td><td><code>ret &lt;baseType&gt; &lt;initValue&gt; </code>, <code>ret void</code></td><td>退出当前函数，并返回值</td></tr></tbody></table><ul><li>在生成对应指令时，将slot加入函数域。例如在<code>visitAddExp</code>中，仅在在生成add指令时将result作为新slot加入函数域，其他slot均在调用的<code>visitMulExp</code>中已加入函数域。</li><li>符号类中新增address字段，存放符号分配到的地址空间</li><li>我们规定数组名只用来（1）函数传参（此时应由FuncRParam一路推导至Ident，不存在任何其他符号），（2）通过索引取数组里面的值。</li></ul><table><thead><tr><th></th><th>全局作用域</th><th>局部作用域</th><th>共性</th></tr></thead><tbody><tr><td><strong>常量</strong></td><td></td><td></td><td>单个常量和常量数组均需给定<code>ConstExp</code>（即可在编译时计算的）初始值</td></tr><tr><td><strong>变量</strong></td><td>若有初始值，则必须是可计算的<code>ConstExp</code>；若无初始值，置零</td><td>可以是不可计算的<code>Exp</code></td><td>可以不带初始值</td></tr><tr><td>共性</td><td>@声明，在顶层，属于<code>GlobalValue</code>；需要保存初始值</td><td>常量和变量jun<code>alloca</code>指令声明，仅保存对应的虚拟寄存器</td><td></td></tr></tbody></table><ul><li><p>一个if语句将当前基本块分为4个基本块（有else）或3个基本块（无else）</p></li><li><p>一个for语句将当前基本块分为5块</p><table><thead><tr><th>B1</th><th>preForStmt（若无preForStmt，则无B1）</th></tr></thead><tbody><tr><td>B2</td><td>Cond，条件跳转指令B3、B5（若无Cond，则是无条件跳转B3）</td></tr><tr><td>B3</td><td>Stmt，无条件跳转B4</td></tr><tr><td>B4</td><td>postStmt，无条件跳转B2 （<strong>continue语句跳点</strong>）</td></tr><tr><td>B5</td><td>（end）（<strong>break语句跳点</strong>）</td></tr></tbody></table></li><li><p>暂时不考虑SSA形式和phi指令，符号表存储地址，每次引用变量使用load，赋值变量使用store。</p></li><li><p>函数传递的非指针参数不能修改，因此<strong>在进入函数时</strong>，需要为其alloca一个地址空间，并将传进的参数赋给它（相当于变量定义）。<strong>不能在第一次使用时再分配并赋值</strong>，因为如果在循环体内使用该变量，则会导致死循环：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun2</span><span class="params">(<span class="type">int</span> a)</span>  <span class="comment">// a=6</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;a &gt;= <span class="number">1</span>;) <span class="comment">// 第一次使用时</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = b * a;</span><br><span class="line">        a = a - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num = num + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a! = %d, num = %d\n&quot;</span>, b, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define dso_local i32 @fun2(i32 %0) &#123;</span><br><span class="line">1:</span><br><span class="line">%2 = alloca i32</span><br><span class="line">store i32 1, i32* %2</span><br><span class="line">%3 = alloca i32</span><br><span class="line">store i32 1, i32* %3</span><br><span class="line">br label %4</span><br><span class="line">4:</span><br><span class="line">%5 = icmp sge i32 %0, 1; for循环的cond块。若不分配，这里会始终会用a的旧值；而如果在此分配并赋值，则会一直赋相同的值给a</span><br><span class="line">%6 = zext i1 %5 to i32</span><br><span class="line">%7 = icmp ne i32 %6, 0</span><br><span class="line">br i1 %7, label %8, label %26</span><br></pre></td></tr></table></figure><h3 id="6-1-2-后端代码生成设计">6.1.2 后端代码生成设计</h3><ul><li><p>以函数为单位管理栈帧、分配全局寄存器，以基本块为单位分配临时寄存器（寄存器分配实现在文档的优化部分）</p></li><li><p>在LLVM IR中，存在i32和i8两种类型，但是在MIPS中，均使用32位字存储。</p></li><li><p>栈帧结构（简化了部分结构）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 栈帧结构（从高到低增长）：</span><br><span class="line"> * sp+size-&gt;|- - - - - - - |   以下为栈帧内容：</span><br><span class="line"> *          |  局部变量      |</span><br><span class="line"> *          |- - - - - - - |   以下调用函数后需生成的：</span><br><span class="line"> *          |  返回地址      |</span><br><span class="line"> *          |- - - - - - - |</span><br><span class="line"> *          |  （保留寄存器） |   （即全局寄存器s0-s7）</span><br><span class="line"> *          |- - - - - - - |</span><br><span class="line"> *          |  被调用者参数  |   （包括a0-a3。从高到低，先压最后一个参数）</span><br><span class="line"> *  sp-&gt;    |- - - - - - - |</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p><img src="../assets/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/mips-stackframe.png" alt="mips-stackframe"></p></li><li><p>函数调用设计：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* 【调用者动作】：</span><br><span class="line">*          1. 保存ra寄存器</span><br><span class="line">*          2. 将后续需要用到的保留寄存器值存入栈中</span><br><span class="line">*          3. 将参数压栈、[如果a0-a3有冲突（需要传递且后续要用到），则需要保存并恢复]</span><br><span class="line">*          4. 更改sp寄存器的值</span><br><span class="line">*          5. 使用jal指令</span><br><span class="line">*          6. 取v0返回值并填入相应寄存器（若有返回值）</span><br><span class="line">*          7. 将sp寄存器的值恢复</span><br><span class="line">*          8. 恢复ra寄存器值、保存的寄存器值、恢复冲突的a0-a3寄存器值</span><br><span class="line">*          9. 继续其他指令……</span><br><span class="line">*  【被调用者动作】：</span><br><span class="line">*          1. 执行函数逻辑，若使用参数则取寄存器值或栈上值</span><br><span class="line">*          2. 执行到ret指令，返回值存入v0（若有）</span><br><span class="line">*          3. 使用jr ra返回</span><br></pre></td></tr></table></figure><ul><li>需要注意的是，由于被调用者需要靠偏移取参数，所以在将参数压栈时，应该保证不会出现寄存器溢出的情况，否则会导致偏移与参数不对应。</li></ul></li></ul><h2 id="6-2-编码后的设计">6.2 编码后的设计</h2><ul><li>遵循<strong>里氏替换原则</strong>和<strong>开放封闭原则</strong>，将LLVM IR和MIPS的指令都设置为一个接口或抽象类，并在具体的每条指令中重写对应的输出方法，调用者使用指令类的多态属性完成每条指令的输出。且当需要新增指令时，不需要修改原来的代码，只需要新增类并继承抽象父类或实现接口即可。</li></ul><h1>7. 代码优化设计</h1><h2 id="7-1-寄存器分配">7.1. 寄存器分配</h2><p>在目标代码生成的指导书中：</p><blockquote><p>在 MIPS 这种<strong>寄存器到寄存器</strong>模型中，每个参与运算的值都必须被加载到寄存器中，因此在我们的 IR 中，参与运算的变量都应该对应一个寄存器，在 IR 中，我们将其称为<strong>虚拟寄存器</strong>。虚拟寄存器数目是无限的，但是当翻译为目标平台的汇编代码时，就需要将其映射到一组有限的寄存器中，这个过程就是<strong>寄存器分配</strong>。</p><p>对于规范的寄存器分配，则需要考虑<strong>全局寄存器</strong>和<strong>局部寄存器</strong>的分配，分别对应 MIPS 中的 <code>s</code> 和 <code>t</code> 寄存器。……</p></blockquote><p>因此，<strong>我在生成目标代码时就已经分配了寄存器</strong>（因此优化前和优化后finalCycle差距可能不大）。以下是具体实现思路。</p><h3 id="7-1-1-跨块活跃变量：采用图着色法分配全局寄存器">7.1.1 跨块活跃变量：采用图着色法分配全局寄存器</h3><h4 id="7-1-1-1-数据流分析">7.1.1.1 数据流分析</h4><p>在LLVM IR每条具体指令类中添加<code>def</code>和<code>use</code>集，并在构造方法中将对应变量加入这两个集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当有集合的in集发生变化时，继续迭代</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(changed) &#123;</span><br><span class="line">    changed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> basicBlocks.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">BasicBlock</span> <span class="variable">basicBlock</span> <span class="operator">=</span> basicBlocks.get(i);</span><br><span class="line">        <span class="comment">// BasicBlock的liveOut集合为其所有后继的liveIn集合的并集</span></span><br><span class="line">        <span class="keyword">for</span> (BasicBlock succ: basicBlock.succs) &#123;</span><br><span class="line">            basicBlock.liveOut.addAll(succ.liveIn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算每条指令的in集和out集</span></span><br><span class="line">        List&lt;Instruction&gt; instructions = basicBlock.instructions;</span><br><span class="line">        <span class="comment">// BasicBlock的最后一条指令的liveOut集合即为liveOut集合</span></span><br><span class="line">        Set&lt;Slot&gt; succsLiveIn = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(basicBlock.liveOut);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> instructions.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">Instruction</span> <span class="variable">instruction</span> <span class="operator">=</span> instructions.get(j);</span><br><span class="line">            instruction.liveOut = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(succsLiveIn);   <span class="comment">// 每条指令的liveOut集合为其后继的liveIn集合</span></span><br><span class="line">            instruction.liveIn = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(instruction.liveOut);</span><br><span class="line">            instruction.liveIn.removeAll(instruction.def);</span><br><span class="line">            instruction.liveIn.addAll(instruction.use);</span><br><span class="line">            succsLiveIn = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(instruction.liveIn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一条指令的liveIn集合即为BasicBlock的liveIn集合</span></span><br><span class="line">        <span class="keyword">if</span> (!basicBlock.liveIn.equals(succsLiveIn)) &#123;</span><br><span class="line">            changed = <span class="literal">true</span>;</span><br><span class="line">            basicBlock.liveIn = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(succsLiveIn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在对每条指令的<code>liveIn</code>和<code>liveOut</code>集计算的基础上，计算基本块的<code>liveIn</code>和<code>liveOut</code>集。</p><p>需要注意在计算函数的跨块活跃变量时，将所有的<code>liveIn</code>和<code>liveOut</code>集变量加入后，需要删除所有作为函数参数的变量（包括指针型）。<br>这是因为函数参数一概不分配寄存器，因此尽管在参数中出现，也不加入跨块活跃变量集合。</p><h4 id="7-1-1-2-图着色算法">7.1.1.2 图着色算法</h4><p>为了简便，我在实现中对冲突的定义是：活跃范围重合。因此，在数据流分析后，同时出现在<code>liveIn</code>或<code>liveOut</code>集合的、以及在块内活跃范围冲突的变量视为冲突。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造冲突图</span></span><br><span class="line"><span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(); <span class="comment">// 用于移除节点得到队列</span></span><br><span class="line"><span class="type">Graph</span> <span class="variable">conflict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(); <span class="comment">// 副本，用于保存冲突图</span></span><br><span class="line"><span class="keyword">for</span> (Slot node: function.interBlockLive) &#123;</span><br><span class="line">    graph.addNode(node);</span><br><span class="line">    conflict.addNode(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在liveIn和liveOut中同时出现的变量，即为冲突变量，添加边</span></span><br><span class="line"><span class="keyword">for</span> (BasicBlock block: function.basicBlocks) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Slot slot1: block.liveIn) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Slot slot2: block.liveIn) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slot1 != slot2 &amp;&amp;</span><br><span class="line">                function.interBlockLive.contains(slot1) &amp;&amp;</span><br><span class="line">                function.interBlockLive.contains(slot2)) &#123;</span><br><span class="line">                graph.addEdge(slot1, slot2);</span><br><span class="line">                conflict.addEdge(slot1, slot2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Slot slot1: block.liveOut) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Slot slot2: block.liveOut) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slot1 != slot2 &amp;&amp;</span><br><span class="line">                function.interBlockLive.contains(slot1) &amp;&amp;</span><br><span class="line">                function.interBlockLive.contains(slot2)) &#123;</span><br><span class="line">                graph.addEdge(slot1, slot2);</span><br><span class="line">                conflict.addEdge(slot1, slot2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对每个基本块，检查只出现在 in 或 out 中的变量，若活性范围冲突则也添加冲突边</span></span><br><span class="line"><span class="keyword">for</span> (BasicBlock block: function.basicBlocks) &#123;</span><br><span class="line">    Set&lt;Slot&gt; intersection = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(block.liveIn);   <span class="comment">// 交集</span></span><br><span class="line">    intersection.retainAll(block.liveOut);</span><br><span class="line"></span><br><span class="line">    Set&lt;Slot&gt; liveInRemoveInter = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(block.liveIn);</span><br><span class="line">    liveInRemoveInter.removeAll(intersection);</span><br><span class="line">    Set&lt;Slot&gt; liveOutRemoveInter = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(block.liveOut);</span><br><span class="line">    liveOutRemoveInter.removeAll(intersection);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Slot slot1: liveInRemoveInter) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Slot slot2: liveOutRemoveInter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (function.interBlockLive.contains(slot1) &amp;&amp;</span><br><span class="line">                    function.interBlockLive.contains(slot2)) &#123;</span><br><span class="line">                <span class="comment">// 滤去函数参数等不跨块活跃的变量</span></span><br><span class="line">                <span class="type">Instruction</span> <span class="variable">defInst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (Instruction inst: block.instructions) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (inst.def.contains(slot2)) &#123;</span><br><span class="line">                        <span class="comment">// slot2只出现在liveOut中，则有一条定义它的指令</span></span><br><span class="line">                        defInst = inst;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 定义后，slot1仍活跃，即为冲突</span></span><br><span class="line">                <span class="keyword">if</span> (defInst.liveOut.contains(slot1)) &#123;</span><br><span class="line">                    graph.addEdge(slot1, slot2);</span><br><span class="line">                    conflict.addEdge(slot1, slot2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中保存冲突图的副本是为了在后续移走节点也能查询到每个变量的冲突情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Slot&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 执行图着色算法</span></span><br><span class="line"><span class="keyword">while</span> (graph.getNodesNum() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">canRemove</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 【为保证移出顺序，先对邻接表排序】</span></span><br><span class="line">    List&lt;Map.Entry&lt;Slot, Set&lt;Slot&gt;&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(graph.adjacencyList.entrySet());</span><br><span class="line">    list.sort(Comparator.comparingInt(o -&gt; o.getKey().slotId));</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Slot, Set&lt;Slot&gt;&gt; entry : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph.getDegree(entry.getKey()) &lt; RegisterPool.savedRegisters.size()) &#123;</span><br><span class="line">            queue.addLast(entry.getKey());</span><br><span class="line">            graph.removeNode(entry.getKey());</span><br><span class="line">            canRemove = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;remove &quot;</span> + entry.getKey().toText());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!canRemove) &#123;</span><br><span class="line">        <span class="comment">// 若无法删除节点，即图中存在度数大于等于寄存器数量的节点，保存在栈上</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 优化时，选择引用次数最少的节点进行合并</span></span><br><span class="line">        <span class="type">Slot</span> <span class="variable">remove</span> <span class="operator">=</span> list.get(<span class="number">0</span>).getKey();</span><br><span class="line">        graph.removeNode(remove);</span><br><span class="line">        conflict.removeNode(remove);    <span class="comment">// 【不分配，移出冲突图】</span></span><br><span class="line">        System.out.println(<span class="string">&quot;spill &quot;</span> + remove.toText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照结点移走的反向顺序将点和边添加回去，并分配颜色</span></span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="type">Slot</span> <span class="variable">slot</span> <span class="operator">=</span> queue.removeLast();</span><br><span class="line">    graph.addNode(slot);</span><br><span class="line">    List&lt;Register&gt; available = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(RegisterPool.savedRegisters);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Slot, Set&lt;Slot&gt;&gt; entry: graph.adjacencyList.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (conflict.adjacencyList.get(slot).contains(entry.getKey())) &#123;</span><br><span class="line">            <span class="comment">// 若已在图中的节点与此节点存在冲突</span></span><br><span class="line">            available.remove(registerPool.globalAllocation.get(entry.getKey()));</span><br><span class="line">            graph.addEdge(slot, entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 挑选一个可用的寄存器着色</span></span><br><span class="line">    <span class="keyword">assert</span> !available.isEmpty();</span><br><span class="line">    registerPool.globalAllocation.put(slot, available.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对于选择哪个节点移除暂时没有实现选择算法，后续可能优化为引用次数最少的不分配全局寄存器。</p><p>需要注意由于<code>HashMap</code>遍历顺序的不确定性，需要先将其排序再进行后续操作。</p><h3 id="7-1-2-不跨块活跃的变量：采用寄存器池分配临时寄存器">7.1.2 不跨块活跃的变量：采用寄存器池分配临时寄存器</h3><p>在后端实现了一个<code>RegisterPool.java</code>类，虽然全局寄存器不使用寄存器池分配，但是实现这个类可以便于对变量对应的寄存器统一管理。生成目标代码时，可以统一使用提供的接口找到对应的寄存器。</p><p>总的来说，我实现的临时寄存器池使用<strong>FIFO算法</strong>，维护一个<code>allocated</code>表和<code>tempQueue</code>，前者存储变量对应的寄存器，后者是一个记录分配顺序的队列。当新增变量时，从寄存器池中分配一个变量，并添加<code>allocated</code>表项、加入<code>tempQueue</code>队尾；当释放寄存器时，移除<code>allocated</code>表项以及<code>tempQueue</code>对应寄存器；当寄存器不够需要溢出时，取<code>tempQueue</code>的队首溢出到内存并分配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配临时寄存器并与Slot【绑定】</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> slot 需要分配的slot</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> curStackFrame 当前的栈帧</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 分配的寄存器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Register <span class="title function_">bindAllocTemp</span><span class="params">(Slot slot, StackFrame curStackFrame)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是跨块活跃变量，分配保留寄存器，否则分配临时寄存器</span></span><br><span class="line">    <span class="keyword">for</span> (Register r: tempRegisters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!allocated.containsValue(r)) &#123;</span><br><span class="line">            <span class="comment">// 若空闲，即找到</span></span><br><span class="line">            tempQueue.addLast(r);</span><br><span class="line">            allocated.put(slot, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 溢出处理</span></span><br><span class="line">    <span class="keyword">return</span> spill(slot, curStackFrame);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 溢出处理，将溢出寄存器的值存到栈上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> curStackFrame 当前的栈帧</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> slot 需要分配的slot，可为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Register <span class="title function_">spill</span><span class="params">(Slot slot, StackFrame curStackFrame)</span> &#123;</span><br><span class="line">    <span class="comment">// FIFO算法，取出最早分配的寄存器</span></span><br><span class="line">    <span class="type">Register</span> <span class="variable">spillRegister</span> <span class="operator">=</span> tempQueue.removeFirst();</span><br><span class="line">    <span class="type">Slot</span> <span class="variable">spillSlot</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Slot, Register&gt; entry: allocated.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == spillRegister) &#123;</span><br><span class="line">            spillSlot = entry.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将寄存器的值存到栈上</span></span><br><span class="line">    curStackFrame.recordLocal(spillSlot, <span class="number">4</span>);</span><br><span class="line">    mipsCode.addMIPSInst(<span class="keyword">new</span> <span class="title class_">SW</span>(spillRegister, Register.SP, -curStackFrame.getSize()).setComment(<span class="string">&quot;\tspill reg of &quot;</span> + spillSlot.toText()));</span><br><span class="line">    <span class="comment">// 移除allocated中的记录</span></span><br><span class="line">    allocated.remove(spillSlot);</span><br><span class="line">    <span class="keyword">if</span> (slot != <span class="literal">null</span>) &#123;</span><br><span class="line">        tempQueue.addLast(spillRegister);</span><br><span class="line">        allocated.put(slot, spillRegister);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> spillRegister;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，每条指令的翻译步骤即：</p><blockquote><ol><li>使用 find 获取 use 的寄存器</li><li>使用 deallocUse 回收 use 中不活跃变量的寄存器</li><li>使用 allocDef 分配 def 使用的寄存器【allocDef可能返回null，此时需要保存到栈上】</li><li>使用 allocTemp 分配不绑定slot的寄存器</li><li>生成MIPS指令</li></ol></blockquote><p>这些步骤不能随意调换顺序。具体来说：</p><ul><li>先<code>find</code>再<code>deallocUse</code>（否则找不到就释放了）</li><li>先<code>deallocUse</code>再<code>allocDef</code>（这样可以立即使用use不再使用的寄存器，例如addiu $t0, $t0, -4这种指令）</li><li>先<code>allocDef</code>再<code>allocTemp</code>。（否则，因为后者不绑定Slot，会分配到一样的寄存器而出错）</li></ul><blockquote><p>此优化与MIPS生成一起完成，因此提交的优化前目标代码与此一致。</p></blockquote><h2 id="7-2-基本块合并">7.2. 基本块合并</h2><p>例如，在公开testcase7中，生成了如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">101:                          ; preds = 96</span><br><span class="line">    %102 = load i32, i32* %1      ;load value of i</span><br><span class="line">    %103 = getelementptr [10 x i32], [10 x i32]* @a, i32 0, i32 %102      ;get &amp;a[%102]</span><br><span class="line">    %104 = load i32, i32* %103    ;load value of a[%102]</span><br><span class="line">    call void @putint(i32 %104)</span><br><span class="line">    call void @putstr(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.0, i64 0, i64 0))</span><br><span class="line">    %105 = load i32, i32* %1      ;load value of i</span><br><span class="line">    %106 = add i32 %105, 1</span><br><span class="line">    store i32 %106, i32* %1</span><br><span class="line">    br label %107</span><br><span class="line">107:                          ; preds = 101</span><br><span class="line">    br label %96</span><br><span class="line">108: ; preds = 96</span><br></pre></td></tr></table></figure><p>经过基本块合并优化后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">101:                          ; preds = 96</span><br><span class="line">    %102 = load i32, i32* %1      ;load value of i</span><br><span class="line">    %103 = getelementptr [10 x i32], [10 x i32]* @a, i32 0, i32 %102      ;get &amp;a[%102]</span><br><span class="line">    %104 = load i32, i32* %103    ;load value of a[%102]</span><br><span class="line">    call void @putint(i32 %104)</span><br><span class="line">    call void @putstr(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.0, i64 0, i64 0))</span><br><span class="line">    %105 = load i32, i32* %1      ;load value of i</span><br><span class="line">    %106 = add i32 %105, 1</span><br><span class="line">    store i32 %106, i32* %1</span><br><span class="line">    br label %96</span><br><span class="line">107:                          ; preds = 96</span><br></pre></td></tr></table></figure><h2 id="7-3-乘除法优化">7.3. 乘除法优化</h2><p>只针对第二个操作数为立即数的乘除指令进行优化。</p><h3 id="7-3-1-乘法优化">7.3.1 乘法优化</h3><p>对于乘数为0、1、2的整数幂、2的整数幂的相反数、2的整数幂-1、2的整数幂-2、2的整数幂+1进行优化，转为若干移位指令和加减指令。</p><h3 id="7-3-2-除法优化">7.3.2 除法优化</h3><p>对于除数为2的整数幂、2的整数幂的相反数进行优化。</p><p>此外，对于能转化为乘法和移位运算的进行优化，例如对于testcase7中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div $t0, $t0, 5</span><br></pre></td></tr></table></figure><p>被优化为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    slt $t1, $zero, $t0</span><br><span class="line">    bnez $t1, _L_divOptimize_0</span><br><span class="line">    subu $t0, $zero, $t0</span><br><span class="line">_L_divOptimize_0:</span><br><span class="line">    li $t2, 3435973837</span><br><span class="line">    multu $t0, $t2</span><br><span class="line">    mfhi $t0</span><br><span class="line">    sra $t0, $t0, 2</span><br><span class="line">    bnez $t1, _L_divOptimize_1</span><br><span class="line">    subu $t0, $zero, $t0</span><br><span class="line">_L_divOptimize_1:</span><br></pre></td></tr></table></figure><p>需要注意，优化时，需要分正负两种情况，不然会产生错误。</p><h2 id="其他说明">其他说明</h2><p>由于生成MIPS时直接完成寄存器分配这一“优化任务”，因此耗费了许多时间。最后因时间紧迫，其他优化暂时没有完成。</p><blockquote><p>Author：bush</p><p>更新日志：</p><ul><li>2024.9.24：完成词法分析，完成文档#1、#2、#3</li><li>2024.10.14：完成语法分析及此部分文档#4，修改#2.2，新增#3.2.3</li><li>2024.10.19：在期中模拟考发现回溯时未回溯已抛出错误导致多输出错误，修改#4.2.5</li><li>2024.11.2：完成语义分析，完成文档#5</li><li>2024.12.12：完成MIPS代码生成，完成文档#6</li><li>2024.12.17：完成优化文档#7</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编译技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
